[
    {
        "prompt": "# Given a cost matrix and a position (m, n), find the minimum cost path to reach (m, n) from (0, 0).\n# >>> min_cost {{1 2 3} {4 8 2} {1 5 3}} 2 2\n# 8\nproc min_cost {cost m n} {",
        "canonical_solution": "    set R [llength $cost]\n    set C [llength [lindex $cost 0]]\n    set tc [lrepeat $R [lrepeat $C 0]]\n    lset tc 0 0 [lindex $cost 0 0]\n    for {set i 1} {$i <= $m} {incr i} {\n        lset tc $i 0 [expr {[lindex $tc [expr {$i - 1}] 0] + [lindex $cost $i 0]}]\n    }\n    for {set j 1} {$j <= $n} {incr j} {\n        lset tc 0 $j [expr {[lindex $tc 0 [expr {$j - 1}]] + [lindex $cost 0 $j]}]\n    }\n    for {set i 1} {$i <= $m} {incr i} {\n        for {set j 1} {$j <= $n} {incr j} {\n            set min_val [expr {min([lindex $tc [expr {$i - 1}] [expr {$j - 1}]], [lindex $tc [expr {$i - 1}] $j], [lindex $tc $i [expr {$j - 1}]])}]\n            lset tc $i $j [expr {$min_val + [lindex $cost $i $j]}]\n        }\n    }\n    return [lindex $tc $m $n]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_cost {{1 2 3} {4 8 2} {1 5 3}} 2 2] == 8}\nassert {[min_cost {{2 3 4} {5 9 3} {2 6 4}} 2 2] == 12}\nassert {[min_cost {{3 4 5} {6 10 4} {3 7 5}} 2 2] == 16}",
        "declaration": "proc min_cost {cost m n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_cost {{1 2 3} {4 8 2} {1 5 3}} 2 2] == 8}",
        "prompt_text": "Given a cost matrix and a position (m, n), find the minimum cost path to reach (m, n) from (0, 0).",
        "prompt_explain": "Given a cost matrix and a position (m, n), find the minimum cost path to reach (m, n) from (0, 0).\n>>> min_cost {{1 2 3} {4 8 2} {1 5 3}} 2 2\n8",
        "func_title": "proc min_cost {cost m n}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the two numbers differ at one bit position only or not.\n# >>> differ_At_One_Bit_Pos 13 9\n# 1\nproc differ_At_One_Bit_Pos {a b} {",
        "canonical_solution": "    set xor_result [expr {$a ^ $b}]\n    if {$xor_result == 0} {\n        return 0\n    }\n    while {[expr {$xor_result % 2}] == 0} {\n        set xor_result [expr {$xor_result / 2}]\n    }\n    if {[expr {$xor_result == 1}]} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[differ_At_One_Bit_Pos 13 9] == 1}\nassert {[differ_At_One_Bit_Pos 15 8] == 0}\nassert {[differ_At_One_Bit_Pos 2 4] == 0}",
        "declaration": "proc differ_At_One_Bit_Pos {a b} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[differ_At_One_Bit_Pos 13 9] == 1}",
        "prompt_text": "Write a Tcl function to check whether the two numbers differ at one bit position only or not.",
        "prompt_explain": "Write a Tcl function to check whether the two numbers differ at one bit position only or not.\n>>> differ_At_One_Bit_Pos 13 9\n1",
        "func_title": "proc differ_At_One_Bit_Pos {a b}"
    },
    {
        "prompt": "# Write a function to find the perimeter of a square.\n# >>> square_perimeter 10\n# 40\nproc square_perimeter {a} {",
        "canonical_solution": "    set perimeter [expr {4 * $a}]\n    return $perimeter\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[square_perimeter 10] == 40}\nassert {[square_perimeter 5] == 20}\nassert {[square_perimeter 4] == 16}",
        "declaration": "proc square_perimeter {a} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[square_perimeter 10] == 40}",
        "prompt_text": "Write a function to find the perimeter of a square.",
        "prompt_explain": "Write a function to find the perimeter of a square.\n>>> square_perimeter 10\n40",
        "func_title": "proc square_perimeter {a}"
    },
    {
        "prompt": "# Write a function to check if the given number is woodball or not.\n# >>> is_woodall 383\n# 1\n# >>> is_woodall 254\n# 0\nproc is_woodall {x} {",
        "canonical_solution": "    if {$x % 2 == 0} {\n        return 0\n    }\n    if {$x == 1} {\n        return 1\n    }\n    set x [expr {$x + 1}]\n    set p 0\n    while {$x % 2 == 0} {\n        set x [expr {$x / 2}]\n        incr p\n        if {$p == $x} {\n            return 1\n        }\n    }\n    return 0\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_woodall 383] == 1}\nassert {[is_woodall 254] == 0}\nassert {[is_woodall 200] == 0}",
        "declaration": "proc is_woodall {x} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_woodall 383] == 1}",
        "prompt_text": "Write a function to check if the given number is woodball or not.",
        "prompt_explain": "Write a function to check if the given number is woodball or not.\n>>> is_woodall 383\n1\n>>> is_woodall 254\n0",
        "func_title": "proc is_woodall {x}",
        "challenge_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_woodall 32212254719] == 1}\nassert {[is_woodall 32212254718] == 0}\nassert {[is_woodall 159] == 1}"
    },
    {
        "prompt": "# Given a list of lists, find the maximum sum of elements of any list.\n# >>> maximum_Sum {{1 2 3} {4 5 6} {10 11 12} {7 8 9}}\n# 33\nproc maximum_Sum {list1} {",
        "canonical_solution": "    set maxi -100000\n    foreach x $list1 {\n        set sum 0\n        foreach y $x {\n            incr sum $y\n        }\n        if {$sum > $maxi} {\n            set maxi $sum\n        }\n    }\n    return $maxi\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[maximum_Sum {{1 2 3} {4 5 6} {10 11 12} {7 8 9}}] == 33}\nassert {[maximum_Sum {{0 1 1} {1 1 2} {3 2 1}}] == 6}\nassert {[maximum_Sum {{0 1 3} {1 2 1} {9 8 2} {0 1 0} {6 4 8}}] == 19}",
        "declaration": "proc maximum_Sum {list1} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[maximum_Sum {{1 2 3} {4 5 6} {10 11 12} {7 8 9}}] == 33}",
        "prompt_text": "Given a list of lists, find the maximum sum of elements of any list.",
        "prompt_explain": "Given a list of lists, find the maximum sum of elements of any list.\n>>> maximum_Sum {{1 2 3} {4 5 6} {10 11 12} {7 8 9}}\n33",
        "func_title": "proc maximum_Sum {list1}",
        "challenge_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[maximum_Sum {{0 -1 -1} {-1 -1 -2} {-3 -2 -1}}] == -2}"
    },
    {
        "prompt": "# Given a list of integers, find the product of non-repeated elements in the list.\n# >>> find_Product {1 1 2 3}\n# 6\nproc find_Product {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set arr [lsort -integer $arr]\n    set prod 1\n    for {set i 0} {$i < $n} {incr i} {\n        if {$i == 0 || [lindex $arr [expr {$i - 1}]] != [lindex $arr $i]} {\n            set prod [expr {$prod * [lindex $arr $i]}]\n        }\n    }\n    return $prod\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Product {1 1 2 3}] == 6}\nassert {[find_Product {1 2 3 1 1}] == 6}\nassert {[find_Product {1 1 4 5 6}] == 120}",
        "declaration": "proc find_Product {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Product {1 1 2 3}] == 6}",
        "prompt_text": "Given a list of integers, find the product of non-repeated elements in the list.",
        "prompt_explain": "Given a list of integers, find the product of non-repeated elements in the list.\n>>> find_Product {1 1 2 3}\n6",
        "func_title": "proc find_Product {arr}"
    },
    {
        "prompt": "# Given a list of integers, find the element that occurs an odd number of times.\n# >>> get_Odd_Occurrence {1 2 3 1 2 3 1}\n# 1\nproc get_Odd_Occurrence {arr} {",
        "canonical_solution": "    set arr_size [llength $arr]\n    for {set i 0} {$i < $arr_size} {incr i} {\n        set count 0\n        for {set j 0} {$j < $arr_size} {incr j} {\n            if {[lindex $arr $i] == [lindex $arr $j]} {\n                incr count\n            }\n        }\n        if {$count % 2 != 0} {\n            return [lindex $arr $i]\n        }\n    }\n    return -1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Odd_Occurrence {1 2 3 1 2 3 1}] == 1}\nassert {[get_Odd_Occurrence {1 2 3 2 3 1 3}] == 3}\nassert {[get_Odd_Occurrence {2 3 5 4 5 2 4 3 5 2 4 4 2}] == 5}",
        "declaration": "proc get_Odd_Occurrence {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Odd_Occurrence {1 2 3 1 2 3 1}] == 1}",
        "prompt_text": "Given a list of integers, find the element that occurs an odd number of times.",
        "prompt_explain": "Given a list of integers, find the element that occurs an odd number of times.\n>>> get_Odd_Occurrence {1 2 3 1 2 3 1}\n1",
        "func_title": "proc get_Odd_Occurrence {arr}"
    },
    {
        "prompt": "# Given a string, count all the substrings starting and ending with same characters.\n# >>> count_Substring_With_Equal_Ends \"abc\"\n# 3\nproc count_Substring_With_Equal_Ends {s} {",
        "canonical_solution": "    set result 0\n    set n [string length $s]\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j 1} {$j <= [expr {$n - $i}]} {incr j} {\n            set substring [string range $s $i [expr {$i + $j - 1}]]\n            if {[string index $substring 0] eq [string index $substring end]} {\n                incr result\n            }\n        }\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Substring_With_Equal_Ends \"abc\"] == 3}\nassert {[count_Substring_With_Equal_Ends \"abcda\"] == 6}\nassert {[count_Substring_With_Equal_Ends \"ab\"] == 2}",
        "declaration": "proc count_Substring_With_Equal_Ends {s} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Substring_With_Equal_Ends \"abc\"] == 3}",
        "prompt_text": "Given a string, count all the substrings starting and ending with same characters.",
        "prompt_explain": "Given a string, count all the substrings starting and ending with same characters.\n>>> count_Substring_With_Equal_Ends \"abc\"\n3",
        "func_title": "proc count_Substring_With_Equal_Ends {s}"
    },
    {
        "prompt": "# Write a Tcl function to convert a decimal number to a binary number.\n# >>> decimal_To_Binary 10\n# 1010\nproc decimal_To_Binary {N} {",
        "canonical_solution": "    set B_Number 0\n    set cnt 0\n    while {$N != 0} {\n        set rem [expr {$N % 2}]\n        set c [expr {pow(10, $cnt)}]\n        set B_Number [expr {$B_Number + $rem * $c}]\n        set N [expr {$N / 2}]\n        incr cnt\n    }\n    return $B_Number\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[decimal_To_Binary 10] == 1010}\nassert {[decimal_To_Binary 1] == 1}\nassert {[decimal_To_Binary 20] == 10100}",
        "declaration": "proc decimal_To_Binary {N} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[decimal_To_Binary 10] == 1010}",
        "prompt_text": "Write a Tcl function to convert a decimal number to a binary number.",
        "prompt_explain": "Write a Tcl function to convert a decimal number to a binary number.\n>>> decimal_To_Binary 10\n1010",
        "func_title": "proc decimal_To_Binary {N}"
    },
    {
        "prompt": "# Given a sorted array of integers with one missing number, find the missing number.\n# >>> find_missing {1 2 3 5} 4\n# 4\nproc find_missing {ar N} {",
        "canonical_solution": "    set l 0\n    set r [expr {$N - 1}]\n    while {$l <= $r} {\n        set mid [expr {($l + $r) / 2}]\n        set mid [expr {int($mid)}]\n        if {[lindex $ar $mid] != [expr {$mid + 1}] && [lindex $ar [expr {$mid - 1}]] == $mid} {\n            return [expr {$mid + 1}]\n        } elseif {[lindex $ar $mid] != [expr {$mid + 1}]} {\n            set r [expr {$mid - 1}]\n        } else {\n            set l [expr {$mid + 1}]\n        }\n    }\n    return -1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_missing {1 2 3 5} 4] == 4}\nassert {[find_missing {1 3 4 5} 4] == 2}\nassert {[find_missing {1 2 3 5 6 7} 5] == 4}",
        "declaration": "proc find_missing {ar N} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_missing {1 2 3 5} 4] == 4}",
        "prompt_text": "Given a sorted array of integers with one missing number, find the missing number.",
        "prompt_explain": "Given a sorted array of integers with one missing number, find the missing number.\n>>> find_missing {1 2 3 5} 4\n4",
        "func_title": "proc find_missing {ar N}"
    },
    {
        "prompt": "# Write a function to find the n-th rectangular number.\n# >>> find_rect_num 4\n# 20\nproc find_rect_num {n} {",
        "canonical_solution": "    return [expr {$n * ($n + 1)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_rect_num 4] == 20}\nassert {[find_rect_num 5] == 30}\nassert {[find_rect_num 6] == 42}",
        "declaration": "proc find_rect_num {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_rect_num 4] == 20}",
        "prompt_text": "Write a function to find the n-th rectangular number.",
        "prompt_explain": "Write a function to find the n-th rectangular number.\n>>> find_rect_num 4\n20",
        "func_title": "proc find_rect_num {n}"
    },
    {
        "prompt": "# Given two numbers p and q, find the nth digit in the proper fraction of p/q.\n# >>> find_Nth_Digit 1 2 1\n# 5\nproc find_Nth_Digit {p q N} {",
        "canonical_solution": "    while {$N > 0} {\n        incr N -1\n        set p [expr {$p * 10}]\n        set res [expr {$p / $q}]\n        set p [expr {$p % $q}]\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Nth_Digit 1 2 1] == 5}\nassert {[find_Nth_Digit 3 5 1] == 6}\nassert {[find_Nth_Digit 5 6 5] == 3}",
        "declaration": "proc find_Nth_Digit {p q N} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Nth_Digit 1 2 1] == 5}",
        "prompt_text": "Given two numbers p and q, find the nth digit in the proper fraction of p/q.",
        "prompt_explain": "Given two numbers p and q, find the nth digit in the proper fraction of p/q.\n>>> find_Nth_Digit 1 2 1\n5",
        "func_title": "proc find_Nth_Digit {p q N}"
    },
    {
        "prompt": "# Given a list of integers, find the sum of repeated elements.\n# >>> find_Sum {1 2 3 1 1 4 5 6}\n# 3\nproc find_Sum {arr} {",
        "canonical_solution": "    set sum 0\n    foreach x $arr {\n        if {[llength [lsearch -all $arr $x]] > 1} {\n            incr sum $x\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Sum {1 2 3 1 1 4 5 6}] == 3}\nassert {[find_Sum {1 2 3 1 1}] == 3}\nassert {[find_Sum {1 1 2}] == 2}",
        "declaration": "proc find_Sum {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Sum {1 2 3 1 1 4 5 6}] == 3}",
        "prompt_text": "Given a list of integers, find the sum of repeated elements.",
        "prompt_explain": "Given a list of integers, find the sum of repeated elements.\n>>> find_Sum {1 2 3 1 1 4 5 6}\n3",
        "func_title": "proc find_Sum {arr}",
        "challenge_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Sum {1 1 2 3 4 5 6 3 5}] == 18}"
    },
    {
        "prompt": "# Given a list of integers, determine whether all the numbers are different from each other or not.\n# >>> test_distinct {1 5 7 9}\n# 1\n# >>> test_distinct {2 4 5 5 7 9}\n# 0\nproc test_distinct {data} {",
        "canonical_solution": "    if {[llength $data] == [llength [lsort -unique $data]]} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[test_distinct {1 5 7 9}] == 1}\nassert {[test_distinct {2 4 5 5 7 9}] == 0}\nassert {[test_distinct {1 2 3}] == 1}",
        "declaration": "proc test_distinct {data} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[test_distinct {1 5 7 9}] == 1}",
        "prompt_text": "Given a list of integers, determine whether all the numbers are different from each other or not.",
        "prompt_explain": "Given a list of integers, determine whether all the numbers are different from each other or not.\n>>> test_distinct {1 5 7 9}\n1\n>>> test_distinct {2 4 5 5 7 9}\n0",
        "func_title": "proc test_distinct {data}"
    },
    {
        "prompt": "# Write a Tcl function to find the last digit when factorial of a divides factorial of b.\n# >>> compute_Last_Digit 2 4\n# 2\nproc compute_Last_Digit {A B} {",
        "canonical_solution": "    set variable 1\n    if {$A == $B} {\n        return 1\n    } elseif {($B - $A) >= 5} {\n        return 0\n    } else {\n        for {set i [expr {$A + 1}]} {$i <= $B} {incr i} {\n            set variable [expr {($variable * ($i % 10)) % 10}]\n        }\n        return [expr {$variable % 10}]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[compute_Last_Digit 2 4] == 2}\nassert {[compute_Last_Digit 6 8] == 6}\nassert {[compute_Last_Digit 1 2] == 2}",
        "declaration": "proc compute_Last_Digit {A B} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[compute_Last_Digit 2 4] == 2}",
        "prompt_text": "Write a Tcl function to find the last digit when factorial of a divides factorial of b.",
        "prompt_explain": "Write a Tcl function to find the last digit when factorial of a divides factorial of b.\n>>> compute_Last_Digit 2 4\n2",
        "func_title": "proc compute_Last_Digit {A B}",
        "challenge_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[compute_Last_Digit 3 7] == 0}\nassert {[compute_Last_Digit 20 23] == 6}\nassert {[compute_Last_Digit 1021 1024] == 4}"
    },
    {
        "prompt": "# Write a function to check if the triangle is equilateral or not.\n# >>> check_equilateral 6 6 6\n# True\n# >>> check_equilateral 6 8 12\n# False\nproc check_equilateral {x y z} {",
        "canonical_solution": "    if {$x == $y && $y == $z} {\n        return True\n    } else {\n        return False\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_equilateral 6 8 12] == False}\nassert {[check_equilateral 6 6 12] == False}\nassert {[check_equilateral 6 6 6] == True}",
        "declaration": "proc check_equilateral {x y z} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_equilateral 6 6 6] == True}",
        "prompt_text": "Write a function to check if the triangle is equilateral or not.",
        "prompt_explain": "Write a function to check if the triangle is equilateral or not.\n>>> check_equilateral 6 6 6\nTrue\n>>> check_equilateral 6 8 12\nFalse",
        "func_title": "proc check_equilateral {x y z}"
    },
    {
        "prompt": "# Write a function to calculate the area of a parallelogram.\n# >>> parallelogram_area 10 20\n# 200\nproc parallelogram_area {b h} {",
        "canonical_solution": "    set area [expr {$b * $h}]\n    return $area\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[parallelogram_area 10 20] == 200}\nassert {[parallelogram_area 15 20] == 300}\nassert {[parallelogram_area 8 9] == 72}",
        "declaration": "proc parallelogram_area {b h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[parallelogram_area 10 20] == 200}",
        "prompt_text": "Write a function to calculate the area of a parallelogram.",
        "prompt_explain": "Write a function to calculate the area of a parallelogram.\n>>> parallelogram_area 10 20\n200",
        "func_title": "proc parallelogram_area {b h}"
    },
    {
        "prompt": "# Given the first term 'a', term number 'n', and common ratio 'r' of a geometric series, return the nth term.\n# >>> tn_gp 1 5 2\n# 16\nproc tn_gp {a n r} {",
        "canonical_solution": "    set tn [expr {$a * pow($r, $n - 1)}]\n    return $tn\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[tn_gp 1 5 2] == 16}\nassert {[tn_gp 1 5 4] == 256}\nassert {[tn_gp 2 6 3] == 486}",
        "declaration": "proc tn_gp {a n r} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[tn_gp 1 5 2] == 16}",
        "prompt_text": "Given the first term 'a', term number 'n', and common ratio 'r' of a geometric series, return the nth term.",
        "prompt_explain": "Given the first term 'a', term number 'n', and common ratio 'r' of a geometric series, return the nth term.\n>>> tn_gp 1 5 2\n16",
        "func_title": "proc tn_gp {a n r}"
    },
    {
        "prompt": "# Given a number, check if it is one less than twice its reverse.\n# >>> check 70\n# 0\n# >>> check 23\n# 0\n# >>> check 73\n# 1\nproc check {n} {",
        "canonical_solution": "    proc rev {num} {\n        set rev_num 0\n        while {$num > 0} {\n            set rev_num [expr {$rev_num * 10 + $num % 10}]\n            set num [expr {$num / 10}]\n        }\n        return $rev_num\n    }\n    return [expr {2 * [rev $n] == $n + 1}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check 70] == 0}\nassert {[check 23] == 0}\nassert {[check 73] == 1}",
        "declaration": "proc check {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check 70] == 0}",
        "prompt_text": "Given a number, check if it is one less than twice its reverse.",
        "prompt_explain": "Given a number, check if it is one less than twice its reverse.\n>>> check 70\n0\n>>> check 23\n0\n>>> check 73\n1",
        "func_title": "proc check {n}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the given two integers have opposite sign or not.\n# >>> opposite_Signs 1 -2\n# 1\n# >>> opposite_Signs 3 2\n# 0\n# >>> opposite_Signs -10 -10\n# 0\nproc opposite_Signs {x y} {",
        "canonical_solution": "    return [expr {($x ^ $y) < 0}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[opposite_Signs 1 -2] == 1}\nassert {[opposite_Signs 3 2] == 0}\nassert {[opposite_Signs -10 -10] == 0}",
        "declaration": "proc opposite_Signs {x y} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[opposite_Signs 1 -2] == 1}",
        "prompt_text": "Write a Tcl function to check whether the given two integers have opposite sign or not.",
        "prompt_explain": "Write a Tcl function to check whether the given two integers have opposite sign or not.\n>>> opposite_Signs 1 -2\n1\n>>> opposite_Signs 3 2\n0\n>>> opposite_Signs -10 -10\n0",
        "func_title": "proc opposite_Signs {x y}"
    },
    {
        "prompt": "# Given an array of integers, find the maximum length of the subsequence with difference between adjacent elements not more than 1.\n# >>> max_len_sub {2 5 6 3 7 6 5 8}\n# 5\nproc max_len_sub {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set mls {}\n    set max 0\n    for {set i 0} {$i < $n} {incr i} {\n        lappend mls 1\n    }\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j 0} {$j < $i} {incr j} {\n            if {abs([lindex $arr $i] - [lindex $arr $j]) <= 1 && [lindex $mls $i] < [expr {[lindex $mls $j] + 1}]} {\n                lset mls $i [expr {[lindex $mls $j] + 1}]\n            }\n        }\n    }\n    for {set i 0} {$i < $n} {incr i} {\n        if {$max < [lindex $mls $i]} {\n            set max [lindex $mls $i]\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_len_sub {2 5 6 3 7 6 5 8}] == 5}\nassert {[max_len_sub {-2 -1 5 -1 4 0 3}] == 4}\nassert {[max_len_sub {9 11 13 15 18}] == 1}",
        "declaration": "proc max_len_sub {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_len_sub {2 5 6 3 7 6 5 8}] == 5}",
        "prompt_text": "Given an array of integers, find the maximum length of the subsequence with difference between adjacent elements not more than 1.",
        "prompt_explain": "Given an array of integers, find the maximum length of the subsequence with difference between adjacent elements not more than 1.\n>>> max_len_sub {2 5 6 3 7 6 5 8}\n5",
        "func_title": "proc max_len_sub {arr}"
    },
    {
        "prompt": "# Given a list of integers, return the smallest number in the list.\n# >>> smallest_num {10 20 1 45 99}\n# 1\nproc smallest_num {xs} {",
        "canonical_solution": "    set smallest [lindex $xs 0]\n    foreach x $xs {\n        if {$x < $smallest} {\n            set smallest $x\n        }\n    }\n    return $smallest\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smallest_num {10 20 1 45 99}] == 1}\nassert {[smallest_num {1 2 3}] == 1}\nassert {[smallest_num {45 46 50 60}] == 45}",
        "declaration": "proc smallest_num {xs} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smallest_num {10 20 1 45 99}] == 1}",
        "prompt_text": "Given a list of integers, return the smallest number in the list.",
        "prompt_explain": "Given a list of integers, return the smallest number in the list.\n>>> smallest_num {10 20 1 45 99}\n1",
        "func_title": "proc smallest_num {xs}"
    },
    {
        "prompt": "# Given a list of integers, possibly containing nested lists, return the sum of all integers in the list. Use recursion to handle nested lists.\n# >>> recursive_list_sum {1 2 {3 4} {5 6}}\n# 21\nproc recursive_list_sum {data_list} {",
        "canonical_solution": "    set total 0\n    foreach element $data_list {\n        if {[llength $element] > 1} {\n            set total [expr {$total + [recursive_list_sum $element]}]\n        } else {\n            set total [expr {$total + $element}]\n        }\n    }\n    return $total\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[recursive_list_sum {1 2 {3 4} {5 6}}] == 21}\nassert {[recursive_list_sum {7 10 {15 14} {19 41}}] == 106}\nassert {[recursive_list_sum {10 20 {30 40} {50 60}}] == 210}",
        "declaration": "proc recursive_list_sum {data_list} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[recursive_list_sum {1 2 {3 4} {5 6}}] == 21}",
        "prompt_text": "Given a list of integers, possibly containing nested lists, return the sum of all integers in the list. Use recursion to handle nested lists.",
        "prompt_explain": "Given a list of integers, possibly containing nested lists, return the sum of all integers in the list. Use recursion to handle nested lists.\n>>> recursive_list_sum {1 2 {3 4} {5 6}}\n21",
        "func_title": "proc recursive_list_sum {data_list}"
    },
    {
        "prompt": "# Write a function to find the number of ways to partition a set of bell numbers.\n# >>> bell_number 2\n# 2\nproc bell_number {n} {",
        "canonical_solution": "    set bell [lrepeat [expr {$n + 1}] [lrepeat [expr {$n + 1}] 0]]\n    lset bell 0 0 1\n    for {set i 1} {$i <= $n} {incr i} {\n        lset bell $i 0 [lindex $bell [expr {$i - 1}] [expr {$i - 1}]]\n        for {set j 1} {$j <= $i} {incr j} {\n            lset bell $i $j [expr {[lindex $bell [expr {$i - 1}] [expr {$j - 1}]] + [lindex $bell $i [expr {$j - 1}]]}]\n        }\n    }\n    return [lindex $bell $n 0]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[bell_number 2] == 2}\nassert {[bell_number 10] == 115975}\nassert {[bell_number 56] == 6775685320645824322581483068371419745979053216268760300}",
        "declaration": "proc bell_number {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[bell_number 2] == 2}",
        "prompt_text": "Write a function to find the number of ways to partition a set of bell numbers.",
        "prompt_explain": "Write a function to find the number of ways to partition a set of bell numbers.\n>>> bell_number 2\n2",
        "func_title": "proc bell_number {n}"
    },
    {
        "prompt": "# Given a list, check whether it contains the given sublist or not.\n# >>> is_sublist {2 4 3 5 7} {3 7}\n# 0\n# >>> is_sublist {2 4 3 5 7} {4 3}\n# 1\nproc is_sublist {l s} {",
        "canonical_solution": "    set sub_set 0\n    if {$s eq {}} {\n        set sub_set 1\n    } elseif {$s eq $l} {\n        set sub_set 1\n    } elseif {[llength $s] > [llength $l]} {\n        set sub_set 0\n    } else {\n        for {set i 0} {$i < [llength $l]} {incr i} {\n            if {[lindex $l $i] == [lindex $s 0]} {\n                set n 1\n                while {$n < [llength $s] && [lindex $l [expr {$i + $n}]] == [lindex $s $n]} {\n                    incr n\n                }\n                if {$n == [llength $s]} {\n                    set sub_set 1\n                }\n            }\n        }\n    }\n    return $sub_set\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_sublist {2 4 3 5 7} {3 7}] == 0}\nassert {[is_sublist {2 4 3 5 7} {4 3}] == 1}\nassert {[is_sublist {2 4 3 5 7} {1 6}] == 0}",
        "declaration": "proc is_sublist {l s} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_sublist {2 4 3 5 7} {3 7}] == 0}",
        "prompt_text": "Given a list, check whether it contains the given sublist or not.",
        "prompt_explain": "Given a list, check whether it contains the given sublist or not.\n>>> is_sublist {2 4 3 5 7} {3 7}\n0\n>>> is_sublist {2 4 3 5 7} {4 3}\n1",
        "func_title": "proc is_sublist {l s}"
    },
    {
        "prompt": "# Given two lists, one of colors and one of patterns, check if the colors follow the sequence given in the patterns array.\n# >>> is_samepatterns {red green green} {a b b}\n# 1\nproc is_samepatterns {colors patterns} {",
        "canonical_solution": "    if {[llength $colors] != [llength $patterns]} {\n        return 0\n    }\n    array set sdict {}\n    set pset {}\n    set sset {}\n    for {set i 0} {$i < [llength $patterns]} {incr i} {\n        lappend pset [lindex $patterns $i]\n        lappend sset [lindex $colors $i]\n        if {![info exists sdict([lindex $patterns $i])]} {\n            set sdict([lindex $patterns $i]) {}\n        }\n        lappend sdict([lindex $patterns $i]) [lindex $colors $i]\n    }\n    if {[llength [lsort -unique $pset]] != [llength [lsort -unique $sset]]} {\n        return 0\n    }\n    foreach {key values} [array get sdict] {\n        for {set i 0} {$i < [expr {[llength $values] - 1}]} {incr i} {\n            if {[lindex $values $i] != [lindex $values [expr {$i + 1}]]} {\n                return 0\n            }\n        }\n    }\n    return 1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_samepatterns {red green green} {a b b}] == 1}\nassert {[is_samepatterns {red green greenn} {a b b}] == 0}\nassert {[is_samepatterns {red green greenn} {a b}] == 0}",
        "declaration": "proc is_samepatterns {colors patterns} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_samepatterns {red green green} {a b b}] == 1}",
        "prompt_text": "Given two lists, one of colors and one of patterns, check if the colors follow the sequence given in the patterns array.",
        "prompt_explain": "Given two lists, one of colors and one of patterns, check if the colors follow the sequence given in the patterns array.\n>>> is_samepatterns {red green green} {a b b}\n1",
        "func_title": "proc is_samepatterns {colors patterns}"
    },
    {
        "prompt": "# Given a rectangle of size m x n, count the number of squares in it.\n# >>> count_Squares 4 3\n# 20\nproc count_Squares {m n} {",
        "canonical_solution": "    if {$n < $m} {\n        set temp $m\n        set m $n\n        set n $temp\n    }\n    return [expr {($m * ($m + 1) * (2 * $m + 1) / 6 + ($n - $m) * $m * ($m + 1) / 2)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Squares 4 3] == 20}\nassert {[count_Squares 2 2] == 5}\nassert {[count_Squares 1 1] == 1}",
        "declaration": "proc count_Squares {m n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Squares 4 3] == 20}",
        "prompt_text": "Given a rectangle of size m x n, count the number of squares in it.",
        "prompt_explain": "Given a rectangle of size m x n, count the number of squares in it.\n>>> count_Squares 4 3\n20",
        "func_title": "proc count_Squares {m n}"
    },
    {
        "prompt": "# Given a word, check whether the length of the word is odd or not.\n# >>> word_len \"Hadoop\"\n# 0\n# >>> word_len \"great\"\n# 1\nproc word_len {s} {",
        "canonical_solution": "    set words [split $s \" \"]\n    foreach word $words {\n        if {[expr {[string length $word] % 2}] != 0} {\n            return 1\n        } else {\n            return 0\n        }\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[word_len \"Hadoop\"] == 0}\nassert {[word_len \"great\"] == 1}\nassert {[word_len \"structure\"] == 1}",
        "declaration": "proc word_len {s} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[word_len \"Hadoop\"] == 0}",
        "prompt_text": "Given a word, check whether the length of the word is odd or not.",
        "prompt_explain": "Given a word, check whether the length of the word is odd or not.\n>>> word_len \"Hadoop\"\n0\n>>> word_len \"great\"\n1",
        "func_title": "proc word_len {s}"
    },
    {
        "prompt": "# Write a function to find the volume of a sphere.\n# >>> volume_sphere 10\n# 4188.790204786391\nproc volume_sphere {r} {",
        "canonical_solution": "    set pi [expr {acos(-1)}]\n    set volume [expr {(4.0/3.0) * $pi * $r * $r * $r}]\n    return $volume\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_sphere 10] == 4188.790204786391}\nassert {[volume_sphere 25] == 65449.84694978735}\nassert {[volume_sphere 20] == 33510.32163829113}",
        "declaration": "proc volume_sphere {r} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_sphere 10] == 4188.790204786391}",
        "prompt_text": "Write a function to find the volume of a sphere.",
        "prompt_explain": "Write a function to find the volume of a sphere.\n>>> volume_sphere 10\n4188.790204786391",
        "func_title": "proc volume_sphere {r}"
    },
    {
        "prompt": "# Given a string, find the character made by adding all the characters of the given string.\n# >>> get_Char \"abc\"\n# f\nproc get_Char {strr} {",
        "canonical_solution": "    set summ 0\n    for {set i 0} {$i < [string length $strr]} {incr i} {\n        set char [string index $strr $i]\n        set summ [expr {$summ + ([scan $char %c] - [scan \"a\" %c] + 1)}]\n    }\n    if {$summ % 26 == 0} {\n        return [format %c [scan \"z\" %c]]\n    } else {\n        set summ [expr {$summ % 26}]\n        return [format %c [expr {[scan \"a\" %c] + $summ - 1}]]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Char \"abc\"] eq \"f\"}\nassert {[get_Char \"gfg\"] eq \"t\"}\nassert {[get_Char \"ab\"] eq \"c\"}",
        "declaration": "proc get_Char {strr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Char \"abc\"] eq \"f\"}",
        "prompt_text": "Given a string, find the character made by adding all the characters of the given string.",
        "prompt_explain": "Given a string, find the character made by adding all the characters of the given string.\n>>> get_Char \"abc\"\nf",
        "func_title": "proc get_Char {strr}"
    },
    {
        "prompt": "# Write a function to find the n-th number in the Newman-Conway sequence.\n# >>> sequence 10\n# 6\nproc sequence {n} {",
        "canonical_solution": "    if {$n == 1 || $n == 2} {\n        return 1\n    } else {\n        return [expr {[sequence [sequence [expr {$n - 1}]]] + [sequence [expr {$n - [sequence [expr {$n - 1}]]}]]}]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sequence 10] == 6}\nassert {[sequence 2] == 1}\nassert {[sequence 3] == 2}",
        "declaration": "proc sequence {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sequence 10] == 6}",
        "prompt_text": "Write a function to find the n-th number in the Newman-Conway sequence.",
        "prompt_explain": "Write a function to find the n-th number in the Newman-Conway sequence.\n>>> sequence 10\n6",
        "func_title": "proc sequence {n}"
    },
    {
        "prompt": "# Write a function to find the surface area of a sphere.\n# >>> surfacearea_sphere 10\n# 1256.6370614359173\nproc surfacearea_sphere {r} {",
        "canonical_solution": "    set pi 3.141592653589793\n    set surfacearea [expr {4 * $pi * $r * $r}]\n    return $surfacearea\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surfacearea_sphere 10] == 1256.6370614359173}\nassert {[surfacearea_sphere 15] == 2827.4333882308138}\nassert {[surfacearea_sphere 20] == 5026.548245743669}",
        "declaration": "proc surfacearea_sphere {r} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surfacearea_sphere 10] == 1256.6370614359173}",
        "prompt_text": "Write a function to find the surface area of a sphere.",
        "prompt_explain": "Write a function to find the surface area of a sphere.\n>>> surfacearea_sphere 10\n1256.6370614359173",
        "func_title": "proc surfacearea_sphere {r}"
    },
    {
        "prompt": "# Write a function to find the closest smaller number than n.\n# >>> closest_num 11\n# 10\nproc closest_num {n} {",
        "canonical_solution": "    return [expr {$n - 1}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[closest_num 11] == 10}\nassert {[closest_num 7] == 6}\nassert {[closest_num 12] == 11}",
        "declaration": "proc closest_num {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[closest_num 11] == 10}",
        "prompt_text": "Write a function to find the closest smaller number than n.",
        "prompt_explain": "Write a function to find the closest smaller number than n.\n>>> closest_num 11\n10",
        "func_title": "proc closest_num {n}"
    },
    {
        "prompt": "# Given a list of words, return the length of the longest word.\n# >>> len_log {python PHP bigdata}\n# 7\nproc len_log {list1} {",
        "canonical_solution": "    set max [string length [lindex $list1 0]]\n    foreach i $list1 {\n        if {[string length $i] > $max} {\n            set max [string length $i]\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[len_log {python PHP bigdata}] == 7}\nassert {[len_log {a ab abc}] == 3}\nassert {[len_log {small big tall}] == 5}",
        "declaration": "proc len_log {list1} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[len_log {python PHP bigdata}] == 7}",
        "prompt_text": "Given a list of words, return the length of the longest word.",
        "prompt_explain": "Given a list of words, return the length of the longest word.\n>>> len_log {python PHP bigdata}\n7",
        "func_title": "proc len_log {list1}"
    },
    {
        "prompt": "# Given a list of strings, check if a substring is present in any of the strings in the list.\n# >>> find_substring {\"red\" \"black\" \"white\" \"green\" \"orange\"} \"ack\"\n# true\nproc find_substring {str1 sub_str} {",
        "canonical_solution": "    foreach s $str1 {\n        if {[string first $sub_str $s] != -1} {\n            return true\n        }\n    }\n    return false\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_substring {\"red\" \"black\" \"white\" \"green\" \"orange\"} \"ack\"] == true}\nassert {[find_substring {\"red\" \"black\" \"white\" \"green\" \"orange\"} \"abc\"] == false}\nassert {[find_substring {\"red\" \"black\" \"white\" \"green\" \"orange\"} \"ange\"] == true}",
        "declaration": "proc find_substring {str1 sub_str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_substring {\"red\" \"black\" \"white\" \"green\" \"orange\"} \"ack\"] == true}",
        "prompt_text": "Given a list of strings, check if a substring is present in any of the strings in the list.",
        "prompt_explain": "Given a list of strings, check if a substring is present in any of the strings in the list.\n>>> find_substring {\"red\" \"black\" \"white\" \"green\" \"orange\"} \"ack\"\ntrue",
        "func_title": "proc find_substring {str1 sub_str}"
    },
    {
        "prompt": "# Write a function to check whether the given number is undulating or not.\n# >>> is_undulating \"1212121\"\n# 1\n# >>> is_undulating \"1991\"\n# 0\n# >>> is_undulating \"121\"\n# 1\nproc is_undulating {n} {",
        "canonical_solution": "    if {[string length $n] <= 2} {\n        return 0\n    }\n    for {set i 2} {$i < [string length $n]} {incr i} {\n        if {[string index $n [expr {$i - 2}]] != [string index $n $i]} {\n            return 0\n        }\n    }\n    return 1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_undulating \"1212121\"] == 1}\nassert {[is_undulating \"1991\"] == 0}\nassert {[is_undulating \"121\"] == 1}",
        "declaration": "proc is_undulating {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_undulating \"1212121\"] == 1}",
        "prompt_text": "Write a function to check whether the given number is undulating or not.",
        "prompt_explain": "Write a function to check whether the given number is undulating or not.\n>>> is_undulating \"1212121\"\n1\n>>> is_undulating \"1991\"\n0\n>>> is_undulating \"121\"\n1",
        "func_title": "proc is_undulating {n}"
    },
    {
        "prompt": "# Write a function to calculate the value of 'a' to the power 'b'.\n# >>> power 3 4\n# 81\nproc power {a b} {",
        "canonical_solution": "    if {$b == 0} {\n        return 1\n    } elseif {$a == 0} {\n        return 0\n    } elseif {$b == 1} {\n        return $a\n    } else {\n        return [expr {$a * [power $a [expr {$b - 1}]]}]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[power 3 4] == 81}\nassert {[power 2 3] == 8}\nassert {[power 5 5] == 3125}",
        "declaration": "proc power {a b} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[power 3 4] == 81}",
        "prompt_text": "Write a function to calculate the value of 'a' to the power 'b'.",
        "prompt_explain": "Write a function to calculate the value of 'a' to the power 'b'.\n>>> power 3 4\n81",
        "func_title": "proc power {a b}"
    },
    {
        "prompt": "# Given a list of sublists, find the minimum length of the sublists.\n# >>> Find_Min_Length {{1} {1 2}}\n# 1\nproc Find_Min_Length {lst} {",
        "canonical_solution": "    set minLength [lindex [lsort -integer [lmap x $lst {llength $x}]] 0]\n    return $minLength\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Find_Min_Length {{1} {1 2}}] == 1}\nassert {[Find_Min_Length {{1 2} {1 2 3} {1 2 3 4}}] == 2}\nassert {[Find_Min_Length {{3 3 3} {4 4 4 4}}] == 3}",
        "declaration": "proc Find_Min_Length {lst} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Find_Min_Length {{1} {1 2}}] == 1}",
        "prompt_text": "Given a list of sublists, find the minimum length of the sublists.",
        "prompt_explain": "Given a list of sublists, find the minimum length of the sublists.\n>>> Find_Min_Length {{1} {1 2}}\n1",
        "func_title": "proc Find_Min_Length {lst}"
    },
    {
        "prompt": "# Given a number, find the next smallest palindrome.\n# >>> next_smallest_palindrome 99\n# 101\nproc next_smallest_palindrome {num} {",
        "canonical_solution": "    while {1} {\n        incr num\n        set numstr [string reverse $num]\n        if {$num == $numstr} {\n            return $num\n        }\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[next_smallest_palindrome 99] == 101}\nassert {[next_smallest_palindrome 1221] == 1331}\nassert {[next_smallest_palindrome 120] == 121}",
        "declaration": "proc next_smallest_palindrome {num} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[next_smallest_palindrome 99] == 101}",
        "prompt_text": "Given a number, find the next smallest palindrome.",
        "prompt_explain": "Given a number, find the next smallest palindrome.\n>>> next_smallest_palindrome 99\n101",
        "func_title": "proc next_smallest_palindrome {num}"
    },
    {
        "prompt": "# Given a list of integers, find the kth smallest element in the list. Do not use the built-in sort command.\n# >>> kth_element {12 3 5 7 19} 5 2\n# 5\nproc kth_element {arr n k} {",
        "canonical_solution": "    for {set i 0} {$i < $n} {incr i} {\n        for {set j 0} {$j < [expr {$n - $i - 1}]} {incr j} {\n            if {[lindex $arr $j] > [lindex $arr [expr {$j + 1}]]} {\n                set temp [lindex $arr $j]\n                lset arr $j [lindex $arr [expr {$j + 1}]]\n                lset arr [expr {$j + 1}] $temp\n            }\n        }\n    }\n    return [lindex $arr [expr {$k - 1}]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[kth_element {12 3 5 7 19} 5 2] == 5}\nassert {[kth_element {17 24 8 23} 4 3] == 8}\nassert {[kth_element {16 21 25 36 4} 5 4] == 36}",
        "declaration": "proc kth_element {arr n k} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[kth_element {12 3 5 7 19} 5 2] == 5}",
        "prompt_text": "Given a list of integers, find the kth smallest element in the list. Do not use the built-in sort command.",
        "prompt_explain": "Given a list of integers, find the kth smallest element in the list. Do not use the built-in sort command.\n>>> kth_element {12 3 5 7 19} 5 2\n5",
        "func_title": "proc kth_element {arr n k}"
    },
    {
        "prompt": "# Write a Tcl function to count hexadecimal numbers for a given range.\n# >>> count_Hexadecimal 10 15\n# 6\nproc count_Hexadecimal {L R} {",
        "canonical_solution": "    set count 0\n    for {set i $L} {$i <= $R} {incr i} {\n        if {$i >= 10 && $i <= 15} {\n            incr count\n        } elseif {$i > 15} {\n            set k $i\n            while {$k != 0} {\n                if {[expr {$k % 16}] >= 10} {\n                    incr count\n                }\n                set k [expr {$k / 16}]\n            }\n        }\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Hexadecimal 10 15] == 6}\nassert {[count_Hexadecimal 2 4] == 0}\nassert {[count_Hexadecimal 15 16] == 1}",
        "declaration": "proc count_Hexadecimal {L R} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Hexadecimal 10 15] == 6}",
        "prompt_text": "Write a Tcl function to count hexadecimal numbers for a given range.",
        "prompt_explain": "Write a Tcl function to count hexadecimal numbers for a given range.\n>>> count_Hexadecimal 10 15\n6",
        "func_title": "proc count_Hexadecimal {L R}"
    },
    {
        "prompt": "# Write a Tcl function to find the perimeter of a cylinder.\n# >>> perimeter 2 4\n# 12\nproc perimeter {diameter height} {",
        "canonical_solution": "    return [expr {2 * ($diameter + $height)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[perimeter 2 4] == 12}\nassert {[perimeter 1 2] == 6}\nassert {[perimeter 3 1] == 8}",
        "declaration": "proc perimeter {diameter height} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[perimeter 2 4] == 12}",
        "prompt_text": "Write a Tcl function to find the perimeter of a cylinder.",
        "prompt_explain": "Write a Tcl function to find the perimeter of a cylinder.\n>>> perimeter 2 4\n12",
        "func_title": "proc perimeter {diameter height}"
    },
    {
        "prompt": "# Write a function to check if a string represents an integer or not.\n# >>> check_integer \"python\"\n# 0\n# >>> check_integer \"1\"\n# 1\n# >>> check_integer \"12345\"\n# 1\nproc check_integer {text} {",
        "canonical_solution": "    set text [string trim $text]\n    if {[string length $text] < 1} {\n        return 0\n    } else {\n        if {[regexp {^[+-]?\\d+$} $text]} {\n            return 1\n        } else {\n            return 0\n        }\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_integer \"python\"] == 0}\nassert {[check_integer \"1\"] == 1}\nassert {[check_integer \"12345\"] == 1}",
        "declaration": "proc check_integer {text} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_integer \"python\"] == 0}",
        "prompt_text": "Write a function to check if a string represents an integer or not.",
        "prompt_explain": "Write a function to check if a string represents an integer or not.\n>>> check_integer \"python\"\n0\n>>> check_integer \"1\"\n1\n>>> check_integer \"12345\"\n1",
        "func_title": "proc check_integer {text}"
    },
    {
        "prompt": "# Given a tuple of positive integers, convert it into an integer.\n# >>> tuple_to_int {1 2 3}\n# 123\nproc tuple_to_int {nums} {",
        "canonical_solution": "    set result \"\"\n    foreach num $nums {\n        append result $num\n    }\n    return [expr {$result + 0}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[tuple_to_int {1 2 3}] == 123}\nassert {[tuple_to_int {4 5 6}] == 456}\nassert {[tuple_to_int {5 6 7}] == 567}",
        "declaration": "proc tuple_to_int {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[tuple_to_int {1 2 3}] == 123}",
        "prompt_text": "Given a tuple of positive integers, convert it into an integer.",
        "prompt_explain": "Given a tuple of positive integers, convert it into an integer.\n>>> tuple_to_int {1 2 3}\n123",
        "func_title": "proc tuple_to_int {nums}"
    },
    {
        "prompt": "# Given a sorted list of integers where all elements appear twice except for one, find the element that appears only once.\n# >>> search {1 1 2 2 3}\n# 3\nproc search {arr} {",
        "canonical_solution": "    set XOR 0\n    foreach num $arr {\n        set XOR [expr {$XOR ^ $num}]\n    }\n    return $XOR\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[search {1 1 2 2 3}] == 3}\nassert {[search {1 1 3 3 4 4 5 5 7 7 8}] == 8}\nassert {[search {1 2 2 3 3 4 4}] == 1}",
        "declaration": "proc search {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[search {1 1 2 2 3}] == 3}",
        "prompt_text": "Given a sorted list of integers where all elements appear twice except for one, find the element that appears only once.",
        "prompt_explain": "Given a sorted list of integers where all elements appear twice except for one, find the element that appears only once.\n>>> search {1 1 2 2 3}\n3",
        "func_title": "proc search {arr}"
    },
    {
        "prompt": "# Write a function to find nth smart number.\n# >>> smartNumber 1\n# 30\n# >>> smartNumber 50\n# 273\n# >>> smartNumber 1000\n# 2664\nproc smartNumber {n} {",
        "canonical_solution": "    set MAX 3000\n    set primes [lrepeat $MAX 0]\n    set result {}\n    for {set i 2} {$i < $MAX} {incr i} {\n        if {[lindex $primes $i] == 0} {\n            lset primes $i 1\n            set j [expr {$i * 2}]\n            while {$j < $MAX} {\n                lset primes $j [expr {[lindex $primes $j] - 1}]\n                if {[expr {[lindex $primes $j] + 3}] == 0} {\n                    lappend result $j\n                }\n                set j [expr {$j + $i}]\n            }\n        }\n    }\n    set result [lsort -integer $result]\n    return [lindex $result [expr {$n - 1}]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smartNumber 1] == 30}\nassert {[smartNumber 50] == 273}\nassert {[smartNumber 1000] == 2664}",
        "declaration": "proc smartNumber {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smartNumber 1] == 30}",
        "prompt_text": "Write a function to find nth smart number.",
        "prompt_explain": "Write a function to find nth smart number.\n>>> smartNumber 1\n30\n>>> smartNumber 50\n273\n>>> smartNumber 1000\n2664",
        "func_title": "proc smartNumber {n}"
    },
    {
        "prompt": "# Write a function to find the nth hexagonal number.\n# >>> hexagonal_num 10\n# 190\nproc hexagonal_num {n} {",
        "canonical_solution": "    return [expr {$n * (2 * $n - 1)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[hexagonal_num 10] == 190}\nassert {[hexagonal_num 5] == 45}\nassert {[hexagonal_num 7] == 91}",
        "declaration": "proc hexagonal_num {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[hexagonal_num 10] == 190}",
        "prompt_text": "Write a function to find the nth hexagonal number.",
        "prompt_explain": "Write a function to find the nth hexagonal number.\n>>> hexagonal_num 10\n190",
        "func_title": "proc hexagonal_num {n}"
    },
    {
        "prompt": "# Write a function to calculate electricity bill.\n# >>> cal_electbill 75\n# 246.25\nproc cal_electbill {units} {",
        "canonical_solution": "    if {$units < 50} {\n        set amount [expr {$units * 2.60}]\n        set surcharge 25\n    } elseif {$units <= 100} {\n        set amount [expr {130 + (($units - 50) * 3.25)}]\n        set surcharge 35\n    } elseif {$units <= 200} {\n        set amount [expr {130 + 162.50 + (($units - 100) * 5.26)}]\n        set surcharge 45\n    } else {\n        set amount [expr {130 + 162.50 + 526 + (($units - 200) * 8.45)}]\n        set surcharge 75\n    }\n    set total [expr {$amount + $surcharge}]\n    return $total\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[cal_electbill 75] == 246.25}\nassert {[cal_electbill 265] == 1442.75}\nassert {[cal_electbill 100] == 327.5}",
        "declaration": "proc cal_electbill {units} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[cal_electbill 75] == 246.25}",
        "prompt_text": "Write a function to calculate electricity bill.",
        "prompt_explain": "Write a function to calculate electricity bill.\n>>> cal_electbill 75\n246.25",
        "func_title": "proc cal_electbill {units}"
    },
    {
        "prompt": "# Given a list of integers, return the ratio of zeroes in the list.\n# >>> zero_count {0 1 2 -1 -5 6 0 -3 -2 3 4 6 8}\n# 0.15\nproc zero_count {nums} {",
        "canonical_solution": "    set n [llength $nums]\n    set n1 0\n    foreach x $nums {\n        if {$x == 0} {\n            incr n1\n        }\n    }\n    return [expr {round(double($n1)/$n*100)/100.0}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[zero_count {0 1 2 -1 -5 6 0 -3 -2 3 4 6 8}] == 0.15}\nassert {[zero_count {2 1 2 -1 -5 6 4 -3 -2 3 4 6 8}] == 0.00}\nassert {[zero_count {2 4 -6 -9 11 -12 14 -5 17}] == 0.00}",
        "declaration": "proc zero_count {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[zero_count {0 1 2 -1 -5 6 0 -3 -2 3 4 6 8}] == 0.15}",
        "prompt_text": "Given a list of integers, return the ratio of zeroes in the list.",
        "prompt_explain": "Given a list of integers, return the ratio of zeroes in the list.\n>>> zero_count {0 1 2 -1 -5 6 0 -3 -2 3 4 6 8}\n0.15",
        "func_title": "proc zero_count {nums}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\n# >>> is_Sum_Of_Powers_Of_Two 10\n# 1\n# >>> is_Sum_Of_Powers_Of_Two 7\n# 0\nproc is_Sum_Of_Powers_Of_Two {n} {",
        "canonical_solution": "    if {$n % 2 == 1} {\n        return 0\n    } else {\n        return 1\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Sum_Of_Powers_Of_Two 10] == 1}\nassert {[is_Sum_Of_Powers_Of_Two 7] == 0}\nassert {[is_Sum_Of_Powers_Of_Two 14] == 1}",
        "declaration": "proc is_Sum_Of_Powers_Of_Two {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Sum_Of_Powers_Of_Two 10] == 1}",
        "prompt_text": "Write a Tcl function to check whether the given number can be represented as sum of non-zero powers of 2 or not.",
        "prompt_explain": "Write a Tcl function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\n>>> is_Sum_Of_Powers_Of_Two 10\n1\n>>> is_Sum_Of_Powers_Of_Two 7\n0",
        "func_title": "proc is_Sum_Of_Powers_Of_Two {n}"
    },
    {
        "prompt": "# Write a function to find the circumference of a circle.\n# >>> circle_circumference 10\n# 62.830000000000005\nproc circle_circumference {r} {",
        "canonical_solution": "    set perimeter [expr {2 * 3.1415 * $r}]\n    return $perimeter\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[circle_circumference 10] == 62.830000000000005}\nassert {[circle_circumference 5] == 31.415000000000003}\nassert {[circle_circumference 4] == 25.132}",
        "declaration": "proc circle_circumference {r} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[circle_circumference 10] == 62.830000000000005}",
        "prompt_text": "Write a function to find the circumference of a circle.",
        "prompt_explain": "Write a function to find the circumference of a circle.\n>>> circle_circumference 10\n62.830000000000005",
        "func_title": "proc circle_circumference {r}"
    },
    {
        "prompt": "# Given three lists of integers, return the count of positions where all three lists have the same element.\n# >>> count_samepair {1 2 3 4 5 6 7 8} {2 2 3 1 2 6 7 9} {2 1 3 1 2 6 7 9}\n# 3\nproc count_samepair {list1 list2 list3} {",
        "canonical_solution": "    set count 0\n    foreach m $list1 n $list2 o $list3 {\n        if {$m == $n && $n == $o} {\n            incr count\n        }\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_samepair {1 2 3 4 5 6 7 8} {2 2 3 1 2 6 7 9} {2 1 3 1 2 6 7 9}] == 3}\nassert {[count_samepair {1 2 3 4 5 6 7 8} {2 2 3 1 2 6 7 8} {2 1 3 1 2 6 7 8}] == 4}\nassert {[count_samepair {1 2 3 4 2 6 7 8} {2 2 3 1 2 6 7 8} {2 1 3 1 2 6 7 8}] == 5}",
        "declaration": "proc count_samepair {list1 list2 list3} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_samepair {1 2 3 4 5 6 7 8} {2 2 3 1 2 6 7 9} {2 1 3 1 2 6 7 9}] == 3}",
        "prompt_text": "Given three lists of integers, return the count of positions where all three lists have the same element.",
        "prompt_explain": "Given three lists of integers, return the count of positions where all three lists have the same element.\n>>> count_samepair {1 2 3 4 5 6 7 8} {2 2 3 1 2 6 7 9} {2 1 3 1 2 6 7 9}\n3",
        "func_title": "proc count_samepair {list1 list2 list3}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of absolute differences in all pairs of the given array.\n# >>> sum_Pairs {1 8 9 15 16}\n# 74\nproc sum_Pairs {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set sum 0\n    for {set i [expr {$n - 1}]} {$i >= 0} {incr i -1} {\n        set sum [expr {$sum + $i * [lindex $arr $i] - ($n - 1 - $i) * [lindex $arr $i]}]\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_Pairs {1 8 9 15 16}] == 74}\nassert {[sum_Pairs {1 2 3 4}] == 10}\nassert {[sum_Pairs {1 2 3 4 5 7 9 11 14}] == 188}",
        "declaration": "proc sum_Pairs {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_Pairs {1 8 9 15 16}] == 74}",
        "prompt_text": "Given a list of integers, return the sum of absolute differences in all pairs of the given array.",
        "prompt_explain": "Given a list of integers, return the sum of absolute differences in all pairs of the given array.\n>>> sum_Pairs {1 8 9 15 16}\n74",
        "func_title": "proc sum_Pairs {arr}"
    },
    {
        "prompt": "# Given a list of integers, find the maximum difference between any two elements in the list.\n# >>> max_Abs_Diff {2 1 5 3}\n# 4\nproc max_Abs_Diff {arr} {",
        "canonical_solution": "    set minEle [lindex $arr 0]\n    set maxEle [lindex $arr 0]\n    set n [llength $arr]\n    for {set i 1} {$i < $n} {incr i} {\n        set current [lindex $arr $i]\n        if {$current < $minEle} {\n            set minEle $current\n        }\n        if {$current > $maxEle} {\n            set maxEle $current\n        }\n    }\n    return [expr {$maxEle - $minEle}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_Abs_Diff {2 1 5 3}] == 4}\nassert {[max_Abs_Diff {9 3 2 5 1}] == 8}\nassert {[max_Abs_Diff {3 2 1}] == 2}",
        "declaration": "proc max_Abs_Diff {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_Abs_Diff {2 1 5 3}] == 4}",
        "prompt_text": "Given a list of integers, find the maximum difference between any two elements in the list.",
        "prompt_explain": "Given a list of integers, find the maximum difference between any two elements in the list.\n>>> max_Abs_Diff {2 1 5 3}\n4",
        "func_title": "proc max_Abs_Diff {arr}"
    },
    {
        "prompt": "# Given an array of integers, find the length of the longest subsequence such that the difference between adjacent elements is one.\n# >>> longest_subseq_with_diff_one {1 2 3 4 5 3 2}\n# 6\nproc longest_subseq_with_diff_one {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set dp [lrepeat $n 1]\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j 0} {$j < $i} {incr j} {\n            if {[expr {abs([lindex $arr $i] - [lindex $arr $j])}] == 1} {\n                lset dp $i [expr {max([lindex $dp $i], [lindex $dp $j] + 1)}]\n            }\n        }\n    }\n    set result 1\n    for {set i 0} {$i < $n} {incr i} {\n        if {[lindex $dp $i] > $result} {\n            set result [lindex $dp $i]\n        }\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[longest_subseq_with_diff_one {1 2 3 4 5 3 2}] == 6}\nassert {[longest_subseq_with_diff_one {10 9 4 5 4 8 6}] == 3}\nassert {[longest_subseq_with_diff_one {1 2 3 2 3 7 2 1}] == 7}",
        "declaration": "proc longest_subseq_with_diff_one {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[longest_subseq_with_diff_one {1 2 3 4 5 3 2}] == 6}",
        "prompt_text": "Given an array of integers, find the length of the longest subsequence such that the difference between adjacent elements is one.",
        "prompt_explain": "Given an array of integers, find the length of the longest subsequence such that the difference between adjacent elements is one.\n>>> longest_subseq_with_diff_one {1 2 3 4 5 3 2}\n6",
        "func_title": "proc longest_subseq_with_diff_one {arr}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the given two numbers are co-prime or not.\n# Two numbers are co-prime if their greatest common divisor (GCD) is 1.\n# >>> is_coprime 17 13\n# 1\n# >>> is_coprime 15 21\n# 0\nproc is_coprime {x y} {",
        "canonical_solution": "    proc gcd {p q} {\n        while {$q != 0} {\n            set temp $q\n            set q [expr {$p % $q}]\n            set p $temp\n        }\n        return $p\n    }\n    return [expr {[gcd $x $y] == 1}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_coprime 17 13] == 1}\nassert {[is_coprime 15 21] == 0}\nassert {[is_coprime 25 45] == 0}",
        "declaration": "proc is_coprime {x y} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_coprime 17 13] == 1}",
        "prompt_text": "Write a Tcl function to check whether the given two numbers are co-prime or not. Two numbers are co-prime if their greatest common divisor (GCD) is 1.",
        "prompt_explain": "Write a Tcl function to check whether the given two numbers are co-prime or not. Two numbers are co-prime if their greatest common divisor (GCD) is 1.\n>>> is_coprime 17 13\n1\n>>> is_coprime 15 21\n0",
        "func_title": "proc is_coprime {x y}"
    },
    {
        "prompt": "# Write a Tcl function to toggle all even bits of a given number.\n# >>> even_bit_toggle_number 10\n# 0\n# >>> even_bit_toggle_number 20\n# 30\n# >>> even_bit_toggle_number 30\n# 20\nproc even_bit_toggle_number {n} {",
        "canonical_solution": "    set res 0\n    set count 0\n    set temp $n\n    while {$temp > 0} {\n        if {$count % 2 == 1} {\n            set res [expr {$res | (1 << $count)}]\n        }\n        incr count\n        set temp [expr {$temp >> 1}]\n    }\n    return [expr {$n ^ $res}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_bit_toggle_number 10] == 0}\nassert {[even_bit_toggle_number 20] == 30}\nassert {[even_bit_toggle_number 30] == 20}",
        "declaration": "proc even_bit_toggle_number {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_bit_toggle_number 10] == 0}",
        "prompt_text": "Write a Tcl function to toggle all even bits of a given number.",
        "prompt_explain": "Write a Tcl function to toggle all even bits of a given number.\n>>> even_bit_toggle_number 10\n0\n>>> even_bit_toggle_number 20\n30\n>>> even_bit_toggle_number 30\n20",
        "func_title": "proc even_bit_toggle_number {n}"
    },
    {
        "prompt": "# Given a list of integers and a number k, find the minimum number of operations required to make all elements equal. Each operation consists of adding k to an element.\n# >>> min_Ops {2 2 2 2} 4 3\n# 0\n# >>> min_Ops {4 2 6 8} 4 3\n# -1\n# >>> min_Ops {21 33 9 45 63} 5 6\n# 24\nproc min_Ops {arr n k} {",
        "canonical_solution": "    set max1 [tcl::mathfunc::max {*}$arr]\n    set res 0\n    for {set i 0} {$i < $n} {incr i} {\n        if {([expr {$max1 - [lindex $arr $i]}] % $k) != 0} {\n            return -1\n        } else {\n            set res [expr {$res + (($max1 - [lindex $arr $i]) / $k)}]\n        }\n    }\n    return [expr {int($res)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_Ops {2 2 2 2} 4 3] == 0}\nassert {[min_Ops {4 2 6 8} 4 3] == -1}\nassert {[min_Ops {21 33 9 45 63} 5 6] == 24}",
        "declaration": "proc min_Ops {arr n k} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_Ops {2 2 2 2} 4 3] == 0}",
        "prompt_text": "Given a list of integers and a number k, find the minimum number of operations required to make all elements equal. Each operation consists of adding k to an element.",
        "prompt_explain": "Given a list of integers and a number k, find the minimum number of operations required to make all elements equal. Each operation consists of adding k to an element.\n>>> min_Ops {2 2 2 2} 4 3\n0\n>>> min_Ops {4 2 6 8} 4 3\n-1\n>>> min_Ops {21 33 9 45 63} 5 6\n24",
        "func_title": "proc min_Ops {arr n k}"
    },
    {
        "prompt": "# Write a function to calculate the sum of the positive integers of n+(n-2)+(n-4)... (until n-x =< 0).\n# >>> sum_series 6\n# 12\nproc sum_series {n} {",
        "canonical_solution": "    if {$n < 1} {\n        return 0\n    } else {\n        return [expr {$n + [sum_series [expr {$n - 2}]]}]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_series 6] == 12}\nassert {[sum_series 10] == 30}\nassert {[sum_series 9] == 25}",
        "declaration": "proc sum_series {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_series 6] == 12}",
        "prompt_text": "Write a function to calculate the sum of the positive integers of n+(n-2)+(n-4)... (until n-x =< 0).",
        "prompt_explain": "Write a function to calculate the sum of the positive integers of n+(n-2)+(n-4)... (until n-x =< 0).\n>>> sum_series 6\n12",
        "func_title": "proc sum_series {n}"
    },
    {
        "prompt": "# Write a function to calculate the area of a regular polygon.\n# >>> area_polygon 4 20\n# 400.00000000000006\nproc area_polygon {s l} {",
        "canonical_solution": "    set pi [expr {acos(-1)}]\n    set area [expr {$s * ($l ** 2) / (4 * tan($pi / $s))}]\n    return $area\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[area_polygon 4 20] == 400.00000000000006}\nassert {[area_polygon 10 15] == 1731.1969896610804}\nassert {[area_polygon 9 7] == 302.90938549487214}",
        "declaration": "proc area_polygon {s l} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[area_polygon 4 20] == 400.00000000000006}",
        "prompt_text": "Write a function to calculate the area of a regular polygon.",
        "prompt_explain": "Write a function to calculate the area of a regular polygon.\n>>> area_polygon 4 20\n400.00000000000006",
        "func_title": "proc area_polygon {s l}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the sum of divisors are same or not.\n# >>> areEquivalent 36 57\n# 0\n# >>> areEquivalent 2 4\n# 0\n# >>> areEquivalent 23 47\n# 1\nproc areEquivalent {num1 num2} {",
        "canonical_solution": "    proc divSum {n} {\n        set sum 1\n        for {set i 2} {$i * $i <= $n} {incr i} {\n            if {$n % $i == 0} {\n                set sum [expr {$sum + $i + $n / $i}]\n            }\n        }\n        return $sum\n    }\n    return [expr {[divSum $num1] == [divSum $num2]}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[areEquivalent 36 57] == 0}\nassert {[areEquivalent 2 4] == 0}\nassert {[areEquivalent 23 47] == 1}",
        "declaration": "proc areEquivalent {num1 num2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[areEquivalent 36 57] == 0}",
        "prompt_text": "Write a Tcl function to check whether the sum of divisors are same or not.",
        "prompt_explain": "Write a Tcl function to check whether the sum of divisors are same or not.\n>>> areEquivalent 36 57\n0\n>>> areEquivalent 2 4\n0\n>>> areEquivalent 23 47\n1",
        "func_title": "proc areEquivalent {num1 num2}"
    },
    {
        "prompt": "# Write a Tcl function to count characters at same position in a given string (lower and uppercase characters) as in English alphabet.\n# >>> count_char_position \"xbcefg\"\n# 2\nproc count_char_position {str1} {",
        "canonical_solution": "    set count_chars 0\n    set length [string length $str1]\n    for {set i 0} {$i < $length} {incr i} {\n        set char [string index $str1 $i]\n        if {[expr {$i == [expr {[scan $char %c] - [scan \"A\" %c]}]}] || [expr {$i == [expr {[scan $char %c] - [scan \"a\" %c]}]}]} {\n            incr count_chars\n        }\n    }\n    return $count_chars\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_char_position \"xbcefg\"] == 2}\nassert {[count_char_position \"ABcED\"] == 3}\nassert {[count_char_position \"AbgdeF\"] == 5}",
        "declaration": "proc count_char_position {str1} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_char_position \"xbcefg\"] == 2}",
        "prompt_text": "Write a Tcl function to count characters at same position in a given string (lower and uppercase characters) as in English alphabet.",
        "prompt_explain": "Write a Tcl function to count characters at same position in a given string (lower and uppercase characters) as in English alphabet.\n>>> count_char_position \"xbcefg\"\n2",
        "func_title": "proc count_char_position {str1}"
    },
    {
        "prompt": "# Given a list of integers, return the count of pairs whose XOR is an even number.\n# >>> find_even_Pair {5 4 7 2 1}\n# 4\nproc find_even_Pair {A N} {",
        "canonical_solution": "    set evenPair 0\n    for {set i 0} {$i < $N} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $N} {incr j} {\n            if {([lindex $A $i] ^ [lindex $A $j]) % 2 == 0} {\n                incr evenPair\n            }\n        }\n    }\n    return $evenPair\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_even_Pair {5 4 7 2 1} 5] == 4}\nassert {[find_even_Pair {7 2 8 1 0 5 11} 7] == 9}\nassert {[find_even_Pair {1 2 3} 3] == 1}",
        "declaration": "proc find_even_Pair {A N} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_even_Pair {5 4 7 2 1} 5] == 4}",
        "prompt_text": "Given a list of integers, return the count of pairs whose XOR is an even number.",
        "prompt_explain": "Given a list of integers, return the count of pairs whose XOR is an even number.\n>>> find_even_Pair {5 4 7 2 1}\n4",
        "func_title": "proc find_even_Pair {A N}"
    },
    {
        "prompt": "# Write a Tcl function to find the smallest power of 2 greater than or equal to n.\n# >>> next_Power_Of_2 0\n# 1\n# >>> next_Power_Of_2 5\n# 8\n# >>> next_Power_Of_2 17\n# 32\nproc next_Power_Of_2 {n} {",
        "canonical_solution": "    set count 0\n    if {$n && !($n & ($n - 1))} {\n        return $n\n    }\n    while {$n != 0} {\n        set n [expr {$n >> 1}]\n        incr count\n    }\n    return [expr {1 << $count}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[next_Power_Of_2 0] == 1}\nassert {[next_Power_Of_2 5] == 8}\nassert {[next_Power_Of_2 17] == 32}",
        "declaration": "proc next_Power_Of_2 {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[next_Power_Of_2 0] == 1}",
        "prompt_text": "Write a Tcl function to find the smallest power of 2 greater than or equal to n.",
        "prompt_explain": "Write a Tcl function to find the smallest power of 2 greater than or equal to n.\n>>> next_Power_Of_2 0\n1\n>>> next_Power_Of_2 5\n8\n>>> next_Power_Of_2 17\n32",
        "func_title": "proc next_Power_Of_2 {n}"
    },
    {
        "prompt": "# Write a function to calculate the nth pell number.\n# >>> get_pell 4\n# 12\nproc get_pell {n} {",
        "canonical_solution": "    if {$n <= 2} {\n        return $n\n    }\n    set a 1\n    set b 2\n    for {set i 3} {$i <= $n} {incr i} {\n        set c [expr {2 * $b + $a}]\n        set a $b\n        set b $c\n    }\n    return $b\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_pell 4] == 12}\nassert {[get_pell 7] == 169}\nassert {[get_pell 8] == 408}",
        "declaration": "proc get_pell {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_pell 4] == 12}",
        "prompt_text": "Write a function to calculate the nth pell number.",
        "prompt_explain": "Write a function to calculate the nth pell number.\n>>> get_pell 4\n12",
        "func_title": "proc get_pell {n}"
    },
    {
        "prompt": "# Write a function to find the perimeter of a pentagon.\n# >>> perimeter_pentagon 5\n# 25\nproc perimeter_pentagon {a} {",
        "canonical_solution": "    set perimeter [expr {5 * $a}]\n    return $perimeter\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[perimeter_pentagon 5] == 25}\nassert {[perimeter_pentagon 10] == 50}\nassert {[perimeter_pentagon 15] == 75}",
        "declaration": "proc perimeter_pentagon {a} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[perimeter_pentagon 5] == 25}",
        "prompt_text": "Write a function to find the perimeter of a pentagon.",
        "prompt_explain": "Write a function to find the perimeter of a pentagon.\n>>> perimeter_pentagon 5\n25",
        "func_title": "proc perimeter_pentagon {a}"
    },
    {
        "prompt": "# Write a function to find the perimeter of a triangle.\n# >>> perimeter_triangle 10 20 30\n# 60\nproc perimeter_triangle {a b c} {",
        "canonical_solution": "    set perimeter [expr {$a + $b + $c}]\n    return $perimeter\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[perimeter_triangle 10 20 30] == 60}\nassert {[perimeter_triangle 3 4 5] == 12}\nassert {[perimeter_triangle 25 35 45] == 105}",
        "declaration": "proc perimeter_triangle {a b c} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[perimeter_triangle 10 20 30] == 60}",
        "prompt_text": "Write a function to find the perimeter of a triangle.",
        "prompt_explain": "Write a function to find the perimeter of a triangle.\n>>> perimeter_triangle 10 20 30\n60",
        "func_title": "proc perimeter_triangle {a b c}"
    },
    {
        "prompt": "# Write a function to find if the given number is a keith number or not.\n# A Keith number is a number that appears in a special sequence generated using its digits.\n# >>> is_num_keith 14\n# 1\n# >>> is_num_keith 12\n# 0\nproc is_num_keith {x} {",
        "canonical_solution": "    set terms {}\n    set temp $x\n    set n 0\n    while {$temp > 0} {\n        lappend terms [expr {$temp % 10}]\n        set temp [expr {$temp / 10}]\n        incr n\n    }\n    set terms [lreverse $terms]\n    set next_term 0\n    set i $n\n    while {$next_term < $x} {\n        set next_term 0\n        for {set j 1} {$j <= $n} {incr j} {\n            set next_term [expr {$next_term + [lindex $terms [expr {$i - $j}]]}]\n        }\n        lappend terms $next_term\n        incr i\n    }\n    return [expr {$next_term == $x ? 1 : 0}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_num_keith 14] == 1}\nassert {[is_num_keith 12] == 0}\nassert {[is_num_keith 197] == 1}",
        "declaration": "proc is_num_keith {x} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_num_keith 14] == 1}",
        "prompt_text": "Write a function to find if the given number is a keith number or not.",
        "prompt_explain": "Write a function to find if the given number is a keith number or not.\nA Keith number is a number that appears in a special sequence generated using its digits.\n>>> is_num_keith 14\n1\n>>> is_num_keith 12\n0",
        "func_title": "proc is_num_keith {x}"
    },
    {
        "prompt": "# Given two sequences, find the length of the longest common subsequence.\n# >>> longest_common_subsequence \"AGGTAB\" \"GXTXAYB\"\n# 4\nproc longest_common_subsequence {X Y} {",
        "canonical_solution": "    set m [string length $X]\n    set n [string length $Y]\n    if {$m == 0 || $n == 0} {\n        return 0\n    } elseif {[string index $X [expr {$m - 1}]] == [string index $Y [expr {$n - 1}]]} {\n        return [expr {1 + [longest_common_subsequence [string range $X 0 [expr {$m - 2}]] [string range $Y 0 [expr {$n - 2}]]]}]\n    } else {\n        return [expr {max([longest_common_subsequence $X [string range $Y 0 [expr {$n - 2}]]], [longest_common_subsequence [string range $X 0 [expr {$m - 2}]] $Y])}]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[longest_common_subsequence \"AGGTAB\" \"GXTXAYB\"] == 4}\nassert {[longest_common_subsequence \"ABCDGH\" \"AEDFHR\"] == 3}\nassert {[longest_common_subsequence \"AXYT\" \"AYZX\"] == 2}",
        "declaration": "proc longest_common_subsequence {X Y} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[longest_common_subsequence \"AGGTAB\" \"GXTXAYB\"] == 4}",
        "prompt_text": "Given two sequences, find the length of the longest common subsequence.",
        "prompt_explain": "Given two sequences, find the length of the longest common subsequence.\n>>> longest_common_subsequence \"AGGTAB\" \"GXTXAYB\"\n4",
        "func_title": "proc longest_common_subsequence {X Y}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the given number can be represented by product of two squares or not.\n# >>> prod_Square 25\n# 0\n# >>> prod_Square 30\n# 0\n# >>> prod_Square 16\n# 1\nproc prod_Square {n} {",
        "canonical_solution": "    for {set i 2} {$i <= $n} {incr i} {\n        if {$i * $i < ($n + 1)} {\n            for {set j 2} {$j <= $n} {incr j} {\n                if {($i * $i * $j * $j) == $n} {\n                    return 1\n                }\n            }\n        }\n    }\n    return 0\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[prod_Square 25] == 0}\nassert {[prod_Square 30] == 0}\nassert {[prod_Square 16] == 1}",
        "declaration": "proc prod_Square {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[prod_Square 25] == 0}",
        "prompt_text": "Write a Tcl function to check whether the given number can be represented by product of two squares or not.",
        "prompt_explain": "Write a Tcl function to check whether the given number can be represented by product of two squares or not.\n>>> prod_Square 25\n0\n>>> prod_Square 30\n0\n>>> prod_Square 16\n1",
        "func_title": "proc prod_Square {n}"
    },
    {
        "prompt": "# Given the coordinates of two opposite corners of a square, count the number of integral coordinates that lie inside the square.\n# >>> count_Intgral_Points 1 1 4 4\n# 4\nproc count_Intgral_Points {x1 y1 x2 y2} {",
        "canonical_solution": "    return [expr {($y2 - $y1 - 1) * ($x2 - $x1 - 1)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Intgral_Points 1 1 4 4] == 4}\nassert {[count_Intgral_Points 1 2 1 2] == 1}\nassert {[count_Intgral_Points 4 2 6 4] == 1}",
        "declaration": "proc count_Intgral_Points {x1 y1 x2 y2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Intgral_Points 1 1 4 4] == 4}",
        "prompt_text": "Given the coordinates of two opposite corners of a square, count the number of integral coordinates that lie inside the square.",
        "prompt_explain": "Given the coordinates of two opposite corners of a square, count the number of integral coordinates that lie inside the square.\n>>> count_Intgral_Points 1 1 4 4\n4",
        "func_title": "proc count_Intgral_Points {x1 y1 x2 y2}"
    },
    {
        "prompt": "# Given a month name, check whether the given month name contains 30 days or not.\n# >>> check_monthname \"February\"\n# 0\n# >>> check_monthname \"June\"\n# 1\nproc check_monthname {monthname} {",
        "canonical_solution": "    if {$monthname eq \"April\" || $monthname eq \"June\" || $monthname eq \"September\" || $monthname eq \"November\"} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_monthname \"February\"] == 0}\nassert {[check_monthname \"June\"] == 1}\nassert {[check_monthname \"April\"] == 1}",
        "declaration": "proc check_monthname {monthname} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_monthname \"February\"] == 0}",
        "prompt_text": "Given a month name, check whether the given month name contains 30 days or not.",
        "prompt_explain": "Given a month name, check whether the given month name contains 30 days or not.\n>>> check_monthname \"February\"\n0\n>>> check_monthname \"June\"\n1",
        "func_title": "proc check_monthname {monthname}"
    },
    {
        "prompt": "# Write a function to find the largest triangle that can be inscribed in an ellipse.\n# >>> largest_triangle 4 2\n# 10.392304845413264\nproc largest_triangle {a b} {",
        "canonical_solution": "    if {$a < 0 || $b < 0} {\n        return -1\n    }\n    set area [expr {(3 * sqrt(3) * pow($a, 2)) / (4 * $b)}]\n    return $area\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[largest_triangle 4 2] == 10.392304845413264}\nassert {[largest_triangle 5 7] == 4.639421805988064}\nassert {[largest_triangle 9 1] == 105.2220865598093}",
        "declaration": "proc largest_triangle {a b} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[largest_triangle 4 2] == 10.392304845413264}",
        "prompt_text": "Write a function to find the largest triangle that can be inscribed in an ellipse.",
        "prompt_explain": "Write a function to find the largest triangle that can be inscribed in an ellipse.\n>>> largest_triangle 4 2\n10.392304845413264",
        "func_title": "proc largest_triangle {a b}"
    },
    {
        "prompt": "# Write a Tcl function to find the highest power of 2 less than or equal to a given number.\n# >>> highest_Power_of_2 10\n# 8\nproc highest_Power_of_2 {n} {",
        "canonical_solution": "    set res 0\n    for {set i $n} {$i > 0} {incr i -1} {\n        if {($i & ($i - 1)) == 0} {\n            set res $i\n            break\n        }\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[highest_Power_of_2 10] == 8}\nassert {[highest_Power_of_2 19] == 16}\nassert {[highest_Power_of_2 32] == 32}",
        "declaration": "proc highest_Power_of_2 {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[highest_Power_of_2 10] == 8}",
        "prompt_text": "Write a Tcl function to find the highest power of 2 less than or equal to a given number.",
        "prompt_explain": "Write a Tcl function to find the highest power of 2 less than or equal to a given number.\n>>> highest_Power_of_2 10\n8",
        "func_title": "proc highest_Power_of_2 {n}"
    },
    {
        "prompt": "# Given a list of integers, return a new list containing the index positions of all maximum values in the list.\n# >>> position_max {12 33 23 10 67 89 45 667 23 12 11 10 54}\n# {7}\nproc position_max {list1} {",
        "canonical_solution": "    set max_val [lindex $list1 0]\n    set max_result {}\n    foreach i [lrange $list1 1 end] {\n        if {$i > $max_val} {\n            set max_val $i\n            set max_result {}\n        }\n        if {$i == $max_val} {\n            lappend max_result [expr {[lsearch -exact $list1 $i] + [llength $max_result]}]\n        }\n    }\n    return $max_result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[position_max {12 33 23 10 67 89 45 667 23 12 11 10 54}] eq {7}}\nassert {[position_max {1 2 2 2 4 4 4 5 5 5 5}] eq {7 8 9 10}}\nassert {[position_max {2 1 5 6 8 3 4 9 10 11 8 12}] eq {11}}",
        "declaration": "proc position_max {list1} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[position_max {12 33 23 10 67 89 45 667 23 12 11 10 54}] eq {7}}",
        "prompt_text": "Given a list of integers, return a new list containing the index positions of all maximum values in the list.",
        "prompt_explain": "Given a list of integers, return a new list containing the index positions of all maximum values in the list.\n>>> position_max {12 33 23 10 67 89 45 667 23 12 11 10 54}\n{7}",
        "func_title": "proc position_max {list1}"
    },
    {
        "prompt": "# Given a list, check whether the elements in the list are the same or not.\n# >>> chkList {one one one}\n# 1\nproc chkList {lst} {",
        "canonical_solution": "    set unique_elements [lsort -unique $lst]\n    if {[llength $unique_elements] == 1} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[chkList {one one one}] == 1}\nassert {[chkList {one Two Three}] == 0}\nassert {[chkList {bigdata python Django}] == 0}",
        "declaration": "proc chkList {lst} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[chkList {one one one}] == 1}",
        "prompt_text": "Given a list, check whether the elements in the list are the same or not.",
        "prompt_explain": "Given a list, check whether the elements in the list are the same or not.\n>>> chkList {one one one}\n1",
        "func_title": "proc chkList {lst}"
    },
    {
        "prompt": "# Write a Tcl function to find the hamming distance between given two integers.\n# >>> hamming_Distance 4 8\n# 2\nproc hamming_Distance {n1 n2} {",
        "canonical_solution": "    set x [expr {$n1 ^ $n2}]\n    set setBits 0\n    while {$x > 0} {\n        incr setBits [expr {$x & 1}]\n        set x [expr {$x >> 1}]\n    }\n    return $setBits\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[hamming_Distance 4 8] == 2}\nassert {[hamming_Distance 2 4] == 2}\nassert {[hamming_Distance 1 2] == 2}",
        "declaration": "proc hamming_Distance {n1 n2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[hamming_Distance 4 8] == 2}",
        "prompt_text": "Write a Tcl function to find the hamming distance between given two integers.",
        "prompt_explain": "Write a Tcl function to find the hamming distance between given two integers.\n>>> hamming_Distance 4 8\n2",
        "func_title": "proc hamming_Distance {n1 n2}"
    },
    {
        "prompt": "# Write a Tcl function to count the occurrence of a given character in a string.\n# >>> count \"abcc\" \"c\"\n# 2\nproc count {s c} {",
        "canonical_solution": "    set res 0\n    for {set i 0} {$i < [string length $s]} {incr i} {\n        if {[string index $s $i] eq $c} {\n            incr res\n        }\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count \"abcc\" \"c\"] == 2}\nassert {[count \"ababca\" \"a\"] == 3}\nassert {[count \"mnmm0pm\" \"m\"] == 4}",
        "declaration": "proc count {s c} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count \"abcc\" \"c\"] == 2}",
        "prompt_text": "Write a Tcl function to count the occurrence of a given character in a string.",
        "prompt_explain": "Write a Tcl function to count the occurrence of a given character in a string.\n>>> count \"abcc\" \"c\"\n2",
        "func_title": "proc count {s c}"
    },
    {
        "prompt": "# Given a string, find the length of the longest repeating subsequence such that the two subsequences dont have same string characters at same positions.\n# >>> find_longest_repeating_subseq \"AABEBCDD\"\n# 3\nproc find_longest_repeating_subseq {str} {",
        "canonical_solution": "    set n [string length $str]\n    set dp [lrepeat [expr {$n + 1}] [lrepeat [expr {$n + 1}] 0]]\n    for {set i 1} {$i <= $n} {incr i} {\n        for {set j 1} {$j <= $n} {incr j} {\n            if {[string index $str [expr {$i - 1}]] == [string index $str [expr {$j - 1}]] && $i != $j} {\n                lset dp $i $j [expr {1 + [lindex $dp [expr {$i - 1}] [expr {$j - 1}]]}]\n            } else {\n                lset dp $i $j [expr {max([lindex $dp $i [expr {$j - 1}]], [lindex $dp [expr {$i - 1}] $j])}]\n            }\n        }\n    }\n    return [lindex $dp $n $n]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_longest_repeating_subseq \"AABEBCDD\"] == 3}\nassert {[find_longest_repeating_subseq \"aabb\"] == 2}\nassert {[find_longest_repeating_subseq \"aab\"] == 1}",
        "declaration": "proc find_longest_repeating_subseq {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_longest_repeating_subseq \"AABEBCDD\"] == 3}",
        "prompt_text": "Given a string, find the length of the longest repeating subsequence such that the two subsequences dont have same string characters at same positions.",
        "prompt_explain": "Given a string, find the length of the longest repeating subsequence such that the two subsequences dont have same string characters at same positions.\n>>> find_longest_repeating_subseq \"AABEBCDD\"\n3",
        "func_title": "proc find_longest_repeating_subseq {str}"
    },
    {
        "prompt": "# Write a function to check that the given string contains only a certain set of characters (in this case a-z, A-Z, and 0-9) by using regex.\n# >>> is_allowed_specific_char \"ABCDEFabcdef123450\"\n# 1\n# >>> is_allowed_specific_char \"*&%@#!}{\"\n# 0\nproc is_allowed_specific_char {string} {",
        "canonical_solution": "    if {[regexp {[^a-zA-Z0-9]} $string]} {\n        return 0\n    } else {\n        return 1\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_allowed_specific_char \"ABCDEFabcdef123450\"] == 1}\nassert {[is_allowed_specific_char \"*&%@#!}{\"] == 0}\nassert {[is_allowed_specific_char \"HELLOhowareyou98765\"] == 1}",
        "declaration": "proc is_allowed_specific_char {string} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_allowed_specific_char \"ABCDEFabcdef123450\"] == 1}",
        "prompt_text": "Write a function to check that the given string contains only a certain set of characters (in this case a-z, A-Z, and 0-9) by using regex.",
        "prompt_explain": "Write a function to check that the given string contains only a certain set of characters (in this case a-z, A-Z, and 0-9) by using regex.\n>>> is_allowed_specific_char \"ABCDEFabcdef123450\"\n1\n>>> is_allowed_specific_char \"*&%@#!}{\"\n0",
        "func_title": "proc is_allowed_specific_char {string}"
    },
    {
        "prompt": "# Write a Tcl function to count numbers whose 0th and nth bits are set.\n# >>> count_Num 2\n# 1\n# >>> count_Num 3\n# 2\n# >>> count_Num 1\n# 1\nproc count_Num {n} {",
        "canonical_solution": "    if {$n == 1} {\n        return 1\n    }\n    set count [expr {pow(2, $n - 2)}]\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Num 2] == 1}\nassert {[count_Num 3] == 2}\nassert {[count_Num 1] == 1}",
        "declaration": "proc count_Num {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Num 2] == 1}",
        "prompt_text": "Write a Tcl function to count numbers whose 0th and nth bits are set.",
        "prompt_explain": "Write a Tcl function to count numbers whose 0th and nth bits are set.\n>>> count_Num 2\n1\n>>> count_Num 3\n2\n>>> count_Num 1\n1",
        "func_title": "proc count_Num {n}"
    },
    {
        "prompt": "# Write a function to convert radians to degrees.\n# >>> degree_radian 90\n# 5156.620156177409\nproc degree_radian {radian} {",
        "canonical_solution": "    set degree [expr {$radian * (180 / 3.141592653589793)}]\n    return $degree\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[degree_radian 90] == 5156.620156177409}\nassert {[degree_radian 60] == 3437.746770784939}\nassert {[degree_radian 120] == 6875.493541569878}",
        "declaration": "proc degree_radian {radian} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[degree_radian 90] == 5156.620156177409}",
        "prompt_text": "Write a function to convert radians to degrees.",
        "prompt_explain": "Write a function to convert radians to degrees.\n>>> degree_radian 90\n5156.620156177409",
        "func_title": "proc degree_radian {radian}"
    },
    {
        "prompt": "# Write a function to check if a nested list is a subset of another nested list.\n# >>> check_subset_list {1 2 3 4 5 6 7 8 9 10 11 12 13 14} {{12 18 23 25 45} {7 11 19 24 28} {1 5 8 18 15 16}}\n# 0\nproc check_subset_list {list1 list2} {",
        "canonical_solution": "    set exist 1\n    foreach sublist2 $list2 {\n        set found 0\n        foreach sublist1 $list1 {\n            if {$sublist2 eq $sublist1} {\n                set found 1\n                break\n            }\n        }\n        if {!$found} {\n            set exist 0\n            break\n        }\n    }\n    return $exist\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_subset_list {1 2 3 4 5 6 7 8 9 10 11 12 13 14} {{12 18 23 25 45} {7 11 19 24 28} {1 5 8 18 15 16}}] == 0}\nassert {[check_subset_list {{2 3 1} {4 5} {6 8}} {{4 5} {6 8}}] == 1}\nassert {[check_subset_list {{a b} {e} {c d}} {{g}}] == 0}",
        "declaration": "proc check_subset_list {list1 list2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_subset_list {1 2 3 4 5 6 7 8 9 10 11 12 13 14} {{12 18 23 25 45} {7 11 19 24 28} {1 5 8 18 15 16}}] == 0}",
        "prompt_text": "Write a function to check if a nested list is a subset of another nested list.",
        "prompt_explain": "Write a function to check if a nested list is a subset of another nested list.\n>>> check_subset_list {1 2 3 4 5 6 7 8 9 10 11 12 13 14} {{12 18 23 25 45} {7 11 19 24 28} {1 5 8 18 15 16}}\n0",
        "func_title": "proc check_subset_list {list1 list2}"
    },
    {
        "prompt": "# Given a tuple, check if all the elements in the tuple have the same data type or not.\n# >>> check_type {5 6 7 3 5 6}\n# 1\n# >>> check_type {1 2 \"4\"}\n# 0\nproc check_type {test_tuple} {",
        "canonical_solution": "    set res 1\n    set first_type [lindex $test_tuple 0]\n    foreach ele $test_tuple {\n        if {[string is integer -strict $first_type] != [string is integer -strict $ele]} {\n            set res 0\n            break\n        }\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_type {5 6 7 3 5 6}] == 1}\nassert {[check_type {1 2 \"4\"}] == 0}\nassert {[check_type {3 2 1 4 5}] == 1}",
        "declaration": "proc check_type {test_tuple} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_type {5 6 7 3 5 6}] == 1}",
        "prompt_text": "Given a tuple, check if all the elements in the tuple have the same data type or not.",
        "prompt_explain": "Given a tuple, check if all the elements in the tuple have the same data type or not.\n>>> check_type {5 6 7 3 5 6}\n1\n>>> check_type {1 2 \"4\"}\n0",
        "func_title": "proc check_type {test_tuple}"
    },
    {
        "prompt": "# Given a sorted array of integers, check if a given element is the majority element. A majority element in a sorted array is an element that appears more than n/2 times.\n# >>> is_majority {1 2 3 3 3 3 10} 7 3\n# 1\nproc is_majority {arr n x} {",
        "canonical_solution": "    set i [binary_search $arr 0 [expr {$n - 1}] $x]\n    if {$i == -1} {\n        return 0\n    }\n    if {[expr {$i + $n / 2}] <= [expr {$n - 1}] && [lindex $arr [expr {$i + $n / 2}]] == $x} {\n        return 1\n    } else {\n        return 0\n    }\n}\nproc binary_search {arr low high x} {\n    if {$high >= $low} {\n        set mid [expr {($low + $high) / 2}]\n        if {($mid == 0 || $x > [lindex $arr [expr {$mid - 1}]]) && [lindex $arr $mid] == $x} {\n            return $mid\n        } elseif {$x > [lindex $arr $mid]} {\n            return [binary_search $arr [expr {$mid + 1}] $high $x]\n        } else {\n            return [binary_search $arr $low [expr {$mid - 1}] $x]\n        }\n    }\n    return -1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_majority {1 2 3 3 3 3 10} 7 3] == 1}\nassert {[is_majority {1 1 2 4 4 4 6 6} 8 4] == 0}\nassert {[is_majority {1 1 1 2 2} 5 1] == 1}",
        "declaration": "proc is_majority {arr n x} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_majority {1 2 3 3 3 3 10} 7 3] == 1}",
        "prompt_text": "Given a sorted array of integers, check if a given element is the majority element. A majority element in a sorted array is an element that appears more than n/2 times.",
        "prompt_explain": "Given a sorted array of integers, check if a given element is the majority element. A majority element in a sorted array is an element that appears more than n/2 times.\n>>> is_majority {1 2 3 3 3 3 10} 7 3\n1",
        "func_title": "proc is_majority {arr n x}"
    },
    {
        "prompt": "# Write a Tcl function to count set bits of a given number.\n# >>> count_Set_Bits 2\n# 1\nproc count_Set_Bits {n} {",
        "canonical_solution": "    set count 0\n    while {$n != 0} {\n        set count [expr {$count + ($n & 1)}]\n        set n [expr {$n >> 1}]\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Set_Bits 2] == 1}\nassert {[count_Set_Bits 4] == 1}\nassert {[count_Set_Bits 6] == 2}",
        "declaration": "proc count_Set_Bits {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Set_Bits 2] == 1}",
        "prompt_text": "Write a Tcl function to count set bits of a given number.",
        "prompt_explain": "Write a Tcl function to count set bits of a given number.\n>>> count_Set_Bits 2\n1",
        "func_title": "proc count_Set_Bits {n}"
    },
    {
        "prompt": "# Given a sorted and rotated array, find the minimum element.\n# >>> find_Min {3 4 5 1 2} 0 4\n# 1\nproc find_Min {arr low high} {",
        "canonical_solution": "    while {$low < $high} {\n        set mid [expr {$low + ($high - $low) / 2}]\n        if {[lindex $arr $mid] == [lindex $arr $high]} {\n            incr high -1\n        } elseif {[lindex $arr $mid] > [lindex $arr $high]} {\n            set low [expr {$mid + 1}]\n        } else {\n            set high $mid\n        }\n    }\n    return [lindex $arr $high]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Min {1 2 3 4 5} 0 4] == 1}\nassert {[find_Min {4 6 8} 0 2] == 4}\nassert {[find_Min {2 3 5 7 9} 0 4] == 2}",
        "declaration": "proc find_Min {arr low high} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Min {1 2 3 4 5} 0 4] == 1}",
        "prompt_text": "Given a sorted and rotated array, find the minimum element.",
        "prompt_explain": "Given a sorted and rotated array, find the minimum element.\n>>> find_Min {3 4 5 1 2} 0 4\n1",
        "func_title": "proc find_Min {arr low high}"
    },
    {
        "prompt": "# Write a function to find minimum of three numbers.\n# >>> min_of_three 10 20 0\n# 0\nproc min_of_three {a b c} {",
        "canonical_solution": "    if {$a <= $b && $a <= $c} {\n        return $a\n    } elseif {$b <= $a && $b <= $c} {\n        return $b\n    } else {\n        return $c\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_of_three 10 20 0] == 0}\nassert {[min_of_three 19 15 18] == 15}\nassert {[min_of_three -10 -20 -30] == -30}",
        "declaration": "proc min_of_three {a b c} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_of_three 10 20 0] == 0}",
        "prompt_text": "Write a function to find minimum of three numbers.",
        "prompt_explain": "Write a function to find minimum of three numbers.\n>>> min_of_three 10 20 0\n0",
        "func_title": "proc min_of_three {a b c}"
    },
    {
        "prompt": "# Write a function to find the lateral surface area of a cylinder.\n# >>> lateralsuface_cylinder 10 5\n# 314.15000000000003\nproc lateralsuface_cylinder {r h} {",
        "canonical_solution": "    set lateralsurface [expr {2 * 3.1415 * $r * $h}]\n    return $lateralsurface\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[lateralsuface_cylinder 10 5] == 314.15000000000003}\nassert {[lateralsuface_cylinder 4 5] == 125.66000000000001}\nassert {[lateralsuface_cylinder 4 10] == 251.32000000000002}",
        "declaration": "proc lateralsuface_cylinder {r h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[lateralsuface_cylinder 10 5] == 314.15000000000003}",
        "prompt_text": "Write a function to find the lateral surface area of a cylinder.",
        "prompt_explain": "Write a function to find the lateral surface area of a cylinder.\n>>> lateralsuface_cylinder 10 5\n314.15000000000003",
        "func_title": "proc lateralsuface_cylinder {r h}"
    },
    {
        "prompt": "# Write a function to find the volume of a cube.\n# >>> volume_cube 3\n# 27\nproc volume_cube {l} {",
        "canonical_solution": "    set volume [expr {$l * $l * $l}]\n    return $volume\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_cube 3] == 27}\nassert {[volume_cube 2] == 8}\nassert {[volume_cube 5] == 125}",
        "declaration": "proc volume_cube {l} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_cube 3] == 27}",
        "prompt_text": "Write a function to find the volume of a cube.",
        "prompt_explain": "Write a function to find the volume of a cube.\n>>> volume_cube 3\n27",
        "func_title": "proc volume_cube {l}"
    },
    {
        "prompt": "# Write a Tcl function to set all even bits of a given number.\n# >>> even_bit_set_number 10\n# 10\n# >>> even_bit_set_number 20\n# 30\n# >>> even_bit_set_number 30\n# 30\nproc even_bit_set_number {n} {",
        "canonical_solution": "    set count 0\n    set res 0\n    set temp $n\n    while {$temp > 0} {\n        if {$count % 2 == 1} {\n            set res [expr {$res | (1 << $count)}]\n        }\n        incr count\n        set temp [expr {$temp >> 1}]\n    }\n    return [expr {$n | $res}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_bit_set_number 10] == 10}\nassert {[even_bit_set_number 20] == 30}\nassert {[even_bit_set_number 30] == 30}",
        "declaration": "proc even_bit_set_number {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_bit_set_number 10] == 10}",
        "prompt_text": "Write a Tcl function to set all even bits of a given number.",
        "prompt_explain": "Write a Tcl function to set all even bits of a given number.\n>>> even_bit_set_number 10\n10\n>>> even_bit_set_number 20\n30\n>>> even_bit_set_number 30\n30",
        "func_title": "proc even_bit_set_number {n}"
    },
    {
        "prompt": "# Write a Tcl function to find the next perfect square greater than a given number.\n# >>> next_Perfect_Square 35\n# 36\nproc next_Perfect_Square {N} {",
        "canonical_solution": "    set nextN [expr {int(sqrt($N)) + 1}]\n    return [expr {$nextN * $nextN}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[next_Perfect_Square 35] == 36}\nassert {[next_Perfect_Square 6] == 9}\nassert {[next_Perfect_Square 9] == 16}",
        "declaration": "proc next_Perfect_Square {N} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[next_Perfect_Square 35] == 36}",
        "prompt_text": "Write a Tcl function to find the next perfect square greater than a given number.",
        "prompt_explain": "Write a Tcl function to find the next perfect square greater than a given number.\n>>> next_Perfect_Square 35\n36",
        "func_title": "proc next_Perfect_Square {N}"
    },
    {
        "prompt": "# Given a list of integers, find the maximum sum of a bi-tonic sub-sequence.\n# >>> max_sum {1 15 51 45 33 100 12 18 9}\n# 194\nproc max_sum {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set MSIBS $arr\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j 0} {$j < $i} {incr j} {\n            if {[lindex $arr $i] > [lindex $arr $j] && [lindex $MSIBS $i] < [expr {[lindex $MSIBS $j] + [lindex $arr $i]}]} {\n                lset MSIBS $i [expr {[lindex $MSIBS $j] + [lindex $arr $i]}]\n            }\n        }\n    }\n    set MSDBS $arr\n    for {set i [expr {$n - 1}]} {$i >= 0} {incr i -1} {\n        for {set j [expr {$n - 1}]} {$j > $i} {incr j -1} {\n            if {[lindex $arr $i] > [lindex $arr $j] && [lindex $MSDBS $i] < [expr {[lindex $MSDBS $j] + [lindex $arr $i]}]} {\n                lset MSDBS $i [expr {[lindex $MSDBS $j] + [lindex $arr $i]}]\n            }\n        }\n    }\n    set max_sum [expr {-(1 << 31)}]\n    for {set i 0} {$i < $n} {incr i} {\n        set sum [expr {[lindex $MSIBS $i] + [lindex $MSDBS $i] - [lindex $arr $i]}]\n        if {$sum > $max_sum} {\n            set max_sum $sum\n        }\n    }\n    return $max_sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sum {1 15 51 45 33 100 12 18 9}] == 194}\nassert {[max_sum {80 60 30 40 20 10}] == 210}\nassert {[max_sum {2 3 14 16 21 23 29 30}] == 138}",
        "declaration": "proc max_sum {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sum {1 15 51 45 33 100 12 18 9}] == 194}",
        "prompt_text": "Given a list of integers, find the maximum sum of a bi-tonic sub-sequence.",
        "prompt_explain": "Given a list of integers, find the maximum sum of a bi-tonic sub-sequence.\n>>> max_sum {1 15 51 45 33 100 12 18 9}\n194",
        "func_title": "proc max_sum {arr}"
    },
    {
        "prompt": "# Write a function for computing square roots using the babylonian method.\n# >>> babylonian_squareroot 10\n# 3.162277660168379\nproc babylonian_squareroot {number} {",
        "canonical_solution": "    if {$number == 0} {\n        return 0\n    }\n    set g [expr {$number / 2.0}]\n    set g2 [expr {$g + 1}]\n    while {$g != $g2} {\n        set n [expr {$number / $g}]\n        set g2 $g\n        set g [expr {($g + $n) / 2}]\n    }\n    return $g\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[babylonian_squareroot 10] == 3.162277660168379}\nassert {[babylonian_squareroot 2] == 1.414213562373095}\nassert {[babylonian_squareroot 9] == 3.0}",
        "declaration": "proc babylonian_squareroot {number} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[babylonian_squareroot 10] == 3.162277660168379}",
        "prompt_text": "Write a function for computing square roots using the babylonian method.",
        "prompt_explain": "Write a function for computing square roots using the babylonian method.\n>>> babylonian_squareroot 10\n3.162277660168379",
        "func_title": "proc babylonian_squareroot {number}"
    },
    {
        "prompt": "# Write a function to calculate the harmonic sum of n-1.\n# >>> harmonic_sum 7\n# 2.5928571428571425\nproc harmonic_sum {n} {",
        "canonical_solution": "    if {$n < 2} {\n        return 1\n    } else {\n        return [expr {1.0 / $n + [harmonic_sum [expr {$n - 1}]]}]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[harmonic_sum 7] == 2.5928571428571425}\nassert {[harmonic_sum 4] == 2.083333333333333}\nassert {[harmonic_sum 19] == 3.547739657143682}",
        "declaration": "proc harmonic_sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[harmonic_sum 7] == 2.5928571428571425}",
        "prompt_text": "Write a function to calculate the harmonic sum of n-1.",
        "prompt_explain": "Write a function to calculate the harmonic sum of n-1.\n>>> harmonic_sum 7\n2.5928571428571425",
        "func_title": "proc harmonic_sum {n}"
    },
    {
        "prompt": "# Given a non-negative number, return the count of prime numbers less than that number.\n# >>> count_Primes_nums 5\n# 2\nproc count_Primes_nums {n} {",
        "canonical_solution": "    set ctr 0\n    for {set num 0} {$num < $n} {incr num} {\n        if {$num <= 1} {\n            continue\n        }\n        set is_prime 1\n        for {set i 2} {$i < $num} {incr i} {\n            if {[expr {$num % $i}] == 0} {\n                set is_prime 0\n                break\n            }\n        }\n        if {$is_prime} {\n            incr ctr\n        }\n    }\n    return $ctr\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Primes_nums 5] == 2}\nassert {[count_Primes_nums 10] == 4}\nassert {[count_Primes_nums 100] == 25}",
        "declaration": "proc count_Primes_nums {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Primes_nums 5] == 2}",
        "prompt_text": "Given a non-negative number, return the count of prime numbers less than that number.",
        "prompt_explain": "Given a non-negative number, return the count of prime numbers less than that number.\n>>> count_Primes_nums 5\n2",
        "func_title": "proc count_Primes_nums {n}"
    },
    {
        "prompt": "# Write a function to calculate a dog's age in dog's years.\n# >>> dog_age 12\n# 61\n# >>> dog_age 15\n# 73\n# >>> dog_age 24\n# 109\nproc dog_age {h_age} {",
        "canonical_solution": "    if {$h_age < 0} {\n        exit\n    } elseif {$h_age <= 2} {\n        set d_age [expr {$h_age * 10.5}]\n    } else {\n        set d_age [expr {21 + ($h_age - 2) * 4}]\n    }\n    return $d_age\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[dog_age 12] == 61}\nassert {[dog_age 15] == 73}\nassert {[dog_age 24] == 109}",
        "declaration": "proc dog_age {h_age} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[dog_age 12] == 61}",
        "prompt_text": "Write a function to calculate a dog's age in dog's years.",
        "prompt_explain": "Write a function to calculate a dog's age in dog's years.\n>>> dog_age 12\n61\n>>> dog_age 15\n73\n>>> dog_age 24\n109",
        "func_title": "proc dog_age {h_age}"
    },
    {
        "prompt": "# Write a function to find the lateral surface area of a cube.\n# >>> lateralsurface_cube 5\n# 100\nproc lateralsurface_cube {l} {",
        "canonical_solution": "    set LSA [expr {4 * ($l * $l)}]\n    return $LSA\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[lateralsurface_cube 5] == 100}\nassert {[lateralsurface_cube 9] == 324}\nassert {[lateralsurface_cube 10] == 400}",
        "declaration": "proc lateralsurface_cube {l} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[lateralsurface_cube 5] == 100}",
        "prompt_text": "Write a function to find the lateral surface area of a cube.",
        "prompt_explain": "Write a function to find the lateral surface area of a cube.\n>>> lateralsurface_cube 5\n100",
        "func_title": "proc lateralsurface_cube {l}"
    },
    {
        "prompt": "# Write a Tcl function to find the sum of fifth power of first n even natural numbers.\n# >>> even_Power_Sum 2\n# 1056\nproc even_Power_Sum {n} {",
        "canonical_solution": "    set sum 0\n    for {set i 1} {$i <= $n} {incr i} {\n        set j [expr {2 * $i}]\n        set sum [expr {$sum + pow($j, 5)}]\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_Power_Sum 2] == 1056}\nassert {[even_Power_Sum 3] == 8832}\nassert {[even_Power_Sum 1] == 32}",
        "declaration": "proc even_Power_Sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_Power_Sum 2] == 1056}",
        "prompt_text": "Write a Tcl function to find the sum of fifth power of first n even natural numbers.",
        "prompt_explain": "Write a Tcl function to find the sum of fifth power of first n even natural numbers.\n>>> even_Power_Sum 2\n1056",
        "func_title": "proc even_Power_Sum {n}"
    },
    {
        "prompt": "# Given two tuples of integers, return a new tuple with the elements of the first tuple subtracted by the corresponding elements of the second tuple.\n# >>> substract_elements {10 4 5} {2 5 18}\n# {8 -1 -13}\nproc substract_elements {test_tup1 test_tup2} {",
        "canonical_solution": "    set res {}\n    foreach i $test_tup1 j $test_tup2 {\n        lappend res [expr {$i - $j}]\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[substract_elements {10 4 5} {2 5 18}] eq {8 -1 -13}}\nassert {[substract_elements {11 2 3} {24 45 16}] eq {-13 -43 -13}}\nassert {[substract_elements {7 18 9} {10 11 12}] eq {-3 7 -3}}",
        "declaration": "proc substract_elements {test_tup1 test_tup2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[substract_elements {10 4 5} {2 5 18}] eq {8 -1 -13}}",
        "prompt_text": "Given two tuples of integers, return a new tuple with the elements of the first tuple subtracted by the corresponding elements of the second tuple.",
        "prompt_explain": "Given two tuples of integers, return a new tuple with the elements of the first tuple subtracted by the corresponding elements of the second tuple.\n>>> substract_elements {10 4 5} {2 5 18}\n{8 -1 -13}",
        "func_title": "proc substract_elements {test_tup1 test_tup2}"
    },
    {
        "prompt": "# Write a Tcl function to find the sum of even index binomial coefficients.\n# >>> even_binomial_Coeff_Sum 4\n# 8\nproc even_binomial_Coeff_Sum {n} {",
        "canonical_solution": "    return [expr {1 << ($n - 1)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_binomial_Coeff_Sum 4] == 8}\nassert {[even_binomial_Coeff_Sum 6] == 32}\nassert {[even_binomial_Coeff_Sum 2] == 2}",
        "declaration": "proc even_binomial_Coeff_Sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_binomial_Coeff_Sum 4] == 8}",
        "prompt_text": "Write a Tcl function to find the sum of even index binomial coefficients.",
        "prompt_explain": "Write a Tcl function to find the sum of even index binomial coefficients.\n>>> even_binomial_Coeff_Sum 4\n8",
        "func_title": "proc even_binomial_Coeff_Sum {n}"
    },
    {
        "prompt": "# Given a list of integers, find the position of the last removed element from the given array.\n# >>> get_Position {2 5 4} 3 2\n# 2\nproc get_Position {a n m} {",
        "canonical_solution": "    for {set i 0} {$i < $n} {incr i} {\n        set a [lreplace $a $i $i [expr {[lindex $a $i] / $m + ([lindex $a $i] % $m != 0)}]]\n    }\n    set result -1\n    set maxx -1\n    for {set i [expr {$n - 1}]} {$i >= 0} {incr i -1} {\n        if {$maxx < [lindex $a $i]} {\n            set maxx [lindex $a $i]\n            set result $i\n        }\n    }\n    return [expr {$result + 1}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Position {2 5 4} 3 2] == 2}\nassert {[get_Position {4 3} 2 2] == 2}\nassert {[get_Position {1 2 3 4} 4 1] == 4}",
        "declaration": "proc get_Position {a n m} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Position {2 5 4} 3 2] == 2}",
        "prompt_text": "Given a list of integers, find the position of the last removed element from the given array.",
        "prompt_explain": "Given a list of integers, find the position of the last removed element from the given array.\n>>> get_Position {2 5 4} 3 2\n2",
        "func_title": "proc get_Position {a n m}"
    },
    {
        "prompt": "# Write a function to find the volume of a cylinder.\n# >>> volume_cylinder 10 5\n# 1570.7500000000002\nproc volume_cylinder {r h} {",
        "canonical_solution": "    set volume [expr {3.1415 * $r * $r * $h}]\n    return $volume\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_cylinder 10 5] == 1570.7500000000002}\nassert {[volume_cylinder 4 5] == 251.32000000000002}\nassert {[volume_cylinder 4 10] == 502.64000000000004}",
        "declaration": "proc volume_cylinder {r h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_cylinder 10 5] == 1570.7500000000002}",
        "prompt_text": "Write a function to find the volume of a cylinder.",
        "prompt_explain": "Write a function to find the volume of a cylinder.\n>>> volume_cylinder 10 5\n1570.7500000000002",
        "func_title": "proc volume_cylinder {r h}"
    },
    {
        "prompt": "# Given a list of integers, check if all elements are unique.\n# >>> all_unique {1 2 3}\n# 1\n# >>> all_unique {1 2 1 2}\n# 0\nproc all_unique {test_list} {",
        "canonical_solution": "    set unique_elements [lsort -unique $test_list]\n    if {[llength $test_list] == [llength $unique_elements]} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[all_unique {1 2 3}] == 1}\nassert {[all_unique {1 2 1 2}] == 0}\nassert {[all_unique {1 2 3 4 5}] == 1}",
        "declaration": "proc all_unique {test_list} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[all_unique {1 2 3}] == 1}",
        "prompt_text": "Given a list of integers, check if all elements are unique.",
        "prompt_explain": "Given a list of integers, check if all elements are unique.\n>>> all_unique {1 2 3}\n1\n>>> all_unique {1 2 1 2}\n0",
        "func_title": "proc all_unique {test_list}"
    },
    {
        "prompt": "# Given a number, check whether the frequency of each digit is less than or equal to the digit itself.\n# >>> validate 1234\n# 1\n# >>> validate 51241\n# 0\nproc validate {n} {",
        "canonical_solution": "    for {set i 0} {$i < 10} {incr i} {\n        set temp $n\n        set count 0\n        while {$temp != 0} {\n            if {[expr {$temp % 10}] == $i} {\n                incr count\n            }\n            if {$count > $i} {\n                return 0\n            }\n            set temp [expr {$temp / 10}]\n        }\n    }\n    return 1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[validate 1234] == 1}\nassert {[validate 51241] == 0}\nassert {[validate 321] == 1}",
        "declaration": "proc validate {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[validate 1234] == 1}",
        "prompt_text": "Given a number, check whether the frequency of each digit is less than or equal to the digit itself.",
        "prompt_explain": "Given a number, check whether the frequency of each digit is less than or equal to the digit itself.\n>>> validate 1234\n1\n>>> validate 51241\n0",
        "func_title": "proc validate {n}"
    },
    {
        "prompt": "# Given a list of integers and a prime number p, count the number of elements in the list that have a modular inverse under p equal to themselves.\n# >>> modular_inverse {1 6 4 5} 7\n# 2\nproc modular_inverse {arr P} {",
        "canonical_solution": "    set count 0\n    foreach element $arr {\n        if {[expr {($element * $element) % $P}] == 1} {\n            incr count\n        }\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[modular_inverse {1 6 4 5} 7] == 2}\nassert {[modular_inverse {1 3 8 12 12} 13] == 3}\nassert {[modular_inverse {2 3 4 5} 6] == 1}",
        "declaration": "proc modular_inverse {arr P} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[modular_inverse {1 6 4 5} 7] == 2}",
        "prompt_text": "Given a list of integers and a prime number p, count the number of elements in the list that have a modular inverse under p equal to themselves.",
        "prompt_explain": "Given a list of integers and a prime number p, count the number of elements in the list that have a modular inverse under p equal to themselves.\n>>> modular_inverse {1 6 4 5} 7\n2",
        "func_title": "proc modular_inverse {arr P}"
    },
    {
        "prompt": "# Given a year, calculate the number of odd days in that year.\n# >>> odd_Days 100\n# 5\nproc odd_Days {N} {",
        "canonical_solution": "    set hund1 [expr {$N / 100}]\n    set hund4 [expr {$N / 400}]\n    set leap [expr {$N >> 2}]\n    set ordd [expr {$N - $leap}]\n    if {$hund1} {\n        set ordd [expr {$ordd + $hund1}]\n        set leap [expr {$leap - $hund1}]\n    }\n    if {$hund4} {\n        set ordd [expr {$ordd - $hund4}]\n        set leap [expr {$leap + $hund4}]\n    }\n    set days [expr {$ordd + $leap * 2}]\n    set odd [expr {$days % 7}]\n    return $odd\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[odd_Days 100] == 5}\nassert {[odd_Days 50] == 6}\nassert {[odd_Days 75] == 2}",
        "declaration": "proc odd_Days {N} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[odd_Days 100] == 5}",
        "prompt_text": "Given a year, calculate the number of odd days in that year.",
        "prompt_explain": "Given a year, calculate the number of odd days in that year.\n>>> odd_Days 100\n5",
        "func_title": "proc odd_Days {N}"
    },
    {
        "prompt": "# Given a fence with n posts and k colors, write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color.\n# >>> count_no_of_ways 2 4\n# 16\nproc count_no_of_ways {n k} {",
        "canonical_solution": "    if {$n == 0} {return 0}\n    if {$n == 1} {return $k}\n    if {$n == 2} {return [expr {$k * $k}]}\n    set mod 1000000007\n    set dp [list]\n    lappend dp $k\n    lappend dp [expr {$k * $k}]\n    for {set i 2} {$i < $n} {incr i} {\n        set next [expr {($k - 1) * ([lindex $dp [expr {$i - 1}]] + [lindex $dp [expr {$i - 2}]]) % $mod}]\n        lappend dp $next\n    }\n    return [lindex $dp [expr {$n - 1}]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_no_of_ways 2 4] == 16}\nassert {[count_no_of_ways 3 2] == 6}\nassert {[count_no_of_ways 4 4] == 228}",
        "declaration": "proc count_no_of_ways {n k} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_no_of_ways 2 4] == 16}",
        "prompt_text": "Given a fence with n posts and k colors, write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color.",
        "prompt_explain": "Given a fence with n posts and k colors, write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color.\n>>> count_no_of_ways 2 4\n16",
        "func_title": "proc count_no_of_ways {n k}"
    },
    {
        "prompt": "# Write a Tcl function to find the quotient of two numbers.\n# >>> find 10 3\n# 3\nproc find {n m} {",
        "canonical_solution": "    set q [expr {$n / $m}]\n    return $q\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find 10 3] == 3}\nassert {[find 4 2] == 2}\nassert {[find 20 5] == 4}",
        "declaration": "proc find {n m} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find 10 3] == 3}",
        "prompt_text": "Write a Tcl function to find the quotient of two numbers.",
        "prompt_explain": "Write a Tcl function to find the quotient of two numbers.\n>>> find 10 3\n3",
        "func_title": "proc find {n m}"
    },
    {
        "prompt": "# Write a function to find the third side of a right angled triangle.\n# >>> otherside_rightangle 7 8\n# 10.63014581273465\nproc otherside_rightangle {w h} {",
        "canonical_solution": "    set s [expr {sqrt($w * $w + $h * $h)}]\n    return $s\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[otherside_rightangle 7 8] == 10.63014581273465}\nassert {[otherside_rightangle 3 4] == 5}\nassert {[otherside_rightangle 7 15] == 16.55294535724685}",
        "declaration": "proc otherside_rightangle {w h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[otherside_rightangle 7 8] == 10.63014581273465}",
        "prompt_text": "Write a function to find the third side of a right angled triangle.",
        "prompt_explain": "Write a function to find the third side of a right angled triangle.\n>>> otherside_rightangle 7 8\n10.63014581273465",
        "func_title": "proc otherside_rightangle {w h}"
    },
    {
        "prompt": "# Write a function to return the sum of all divisors of a number.\n# >>> sum_div 8\n# 7\nproc sum_div {number} {",
        "canonical_solution": "    set divisors {1}\n    for {set i 2} {$i < $number} {incr i} {\n        if {$number % $i == 0} {\n            lappend divisors $i\n        }\n    }\n    return [expr [join $divisors +]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_div 8] == 7}\nassert {[sum_div 12] == 16}\nassert {[sum_div 7] == 1}",
        "declaration": "proc sum_div {number} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_div 8] == 7}",
        "prompt_text": "Write a function to return the sum of all divisors of a number.",
        "prompt_explain": "Write a function to return the sum of all divisors of a number.\n>>> sum_div 8\n7",
        "func_title": "proc sum_div {number}"
    },
    {
        "prompt": "# Given a list of integers, return the count of inversions in the list.\n# An inversion is a pair of indices (i, j) such that i < j and list[i] > list[j].\n# >>> get_Inv_Count {1 20 6 4 5}\n# 5\nproc get_Inv_Count {arr} {",
        "canonical_solution": "    set inv_count 0\n    set n [llength $arr]\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $n} {incr j} {\n            if {[lindex $arr $i] > [lindex $arr $j]} {\n                incr inv_count\n            }\n        }\n    }\n    return $inv_count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Inv_Count {1 20 6 4 5}] == 5}\nassert {[get_Inv_Count {1 2 1}] == 1}\nassert {[get_Inv_Count {1 2 5 6 1}] == 3}",
        "declaration": "proc get_Inv_Count {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Inv_Count {1 20 6 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the count of inversions in the list. An inversion is a pair of indices (i, j) such that i < j and list[i] > list[j].",
        "prompt_explain": "Given a list of integers, return the count of inversions in the list. An inversion is a pair of indices (i, j) such that i < j and list[i] > list[j].\n>>> get_Inv_Count {1 20 6 4 5}\n5",
        "func_title": "proc get_Inv_Count {arr}"
    },
    {
        "prompt": "# Write a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.\n# >>> count_binary_seq 1\n# 2.0\nproc count_binary_seq {n} {",
        "canonical_solution": "    set nCr 1\n    set res 1\n    for {set r 1} {$r <= $n} {incr r} {\n        set nCr [expr {($nCr * ($n + 1 - $r)) / $r}]\n        set res [expr {$res + $nCr * $nCr}]\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_binary_seq 1] == 2.0}\nassert {[count_binary_seq 2] == 6.0}\nassert {[count_binary_seq 3] == 20.0}",
        "declaration": "proc count_binary_seq {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_binary_seq 1] == 2.0}",
        "prompt_text": "Write a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.",
        "prompt_explain": "Write a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.\n>>> count_binary_seq 1\n2.0",
        "func_title": "proc count_binary_seq {n}"
    },
    {
        "prompt": "# Write a Tcl function to find the most significant bit number which is also a set bit.\n# >>> set_Bit_Number 6\n# 4\nproc set_Bit_Number {n} {",
        "canonical_solution": "    if {$n == 0} {\n        return 0\n    }\n    set msb 0\n    set n [expr {$n / 2}]\n    while {$n > 0} {\n        set n [expr {$n / 2}]\n        incr msb\n    }\n    return [expr {1 << $msb}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[set_Bit_Number 6] == 4}\nassert {[set_Bit_Number 10] == 8}\nassert {[set_Bit_Number 18] == 16}",
        "declaration": "proc set_Bit_Number {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[set_Bit_Number 6] == 4}",
        "prompt_text": "Write a Tcl function to find the most significant bit number which is also a set bit.",
        "prompt_explain": "Write a Tcl function to find the most significant bit number which is also a set bit.\n>>> set_Bit_Number 6\n4",
        "func_title": "proc set_Bit_Number {n}"
    },
    {
        "prompt": "# Given a list of integers, a list of ranges, the number of rotations, and an index, return the element at the given index after performing the specified number of rotations on the ranges.\n# >>> find_Element {1 2 3 4 5} {{0 2} {0 3}} 2 1\n# 3\nproc find_Element {arr ranges rotations index} {",
        "canonical_solution": "    for {set i [expr {$rotations - 1}]} {$i >= 0} {incr i -1} {\n        set left [lindex [lindex $ranges $i] 0]\n        set right [lindex [lindex $ranges $i] 1]\n        if {$left <= $index && $right >= $index} {\n            if {$index == $left} {\n                set index $right\n            } else {\n                set index [expr {$index - 1}]\n            }\n        }\n    }\n    return [lindex $arr $index]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Element {1 2 3 4 5} {{0 2} {0 3}} 2 1] == 3}\nassert {[find_Element {1 2 3 4} {{0 1} {0 2}} 1 2] == 3}\nassert {[find_Element {1 2 3 4 5 6} {{0 1} {0 2}} 1 1] == 1}",
        "declaration": "proc find_Element {arr ranges rotations index} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Element {1 2 3 4 5} {{0 2} {0 3}} 2 1] == 3}",
        "prompt_text": "Given a list of integers, a list of ranges, the number of rotations, and an index, return the element at the given index after performing the specified number of rotations on the ranges.",
        "prompt_explain": "Given a list of integers, a list of ranges, the number of rotations, and an index, return the element at the given index after performing the specified number of rotations on the ranges.\n>>> find_Element {1 2 3 4 5} {{0 2} {0 3}} 2 1\n3",
        "func_title": "proc find_Element {arr ranges rotations index}"
    },
    {
        "prompt": "# Write a Tcl function to find the maximum of two numbers.\n# >>> maximum 5 10\n# 10\nproc maximum {a b} {",
        "canonical_solution": "    if {$a >= $b} {\n        return $a\n    } else {\n        return $b\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[maximum 5 10] == 10}\nassert {[maximum -1 -2] == -1}\nassert {[maximum 9 7] == 9}",
        "declaration": "proc maximum {a b} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[maximum 5 10] == 10}",
        "prompt_text": "Write a Tcl function to find the maximum of two numbers.",
        "prompt_explain": "Write a Tcl function to find the maximum of two numbers.\n>>> maximum 5 10\n10",
        "func_title": "proc maximum {a b}"
    },
    {
        "prompt": "# Given an integer, set the left most unset bit.\n# >>> set_left_most_unset_bit 10\n# 14\nproc set_left_most_unset_bit {n} {",
        "canonical_solution": "    if {$n == 0} { return 1 }\n    if {($n & ($n + 1)) == 0} { return $n }\n    set pos 0\n    set temp $n\n    set count 0\n    while {$temp != 0} {\n        if {($temp & 1) == 0} {\n            set pos $count\n        }\n        incr count\n        set temp [expr {$temp >> 1}]\n    }\n    return [expr {$n | (1 << $pos)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[set_left_most_unset_bit 10] == 14}\nassert {[set_left_most_unset_bit 12] == 14}\nassert {[set_left_most_unset_bit 15] == 15}",
        "declaration": "proc set_left_most_unset_bit {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[set_left_most_unset_bit 10] == 14}",
        "prompt_text": "Given an integer, set the left most unset bit.",
        "prompt_explain": "Given an integer, set the left most unset bit.\n>>> set_left_most_unset_bit 10\n14",
        "func_title": "proc set_left_most_unset_bit {n}"
    },
    {
        "prompt": "# Write a function to find the volume of a cone.\n# >>> volume_cone 5 12\n# 314.15926535897927\nproc volume_cone {r h} {",
        "canonical_solution": "    set pi 3.141592653589793\n    set volume [expr {(1.0/3) * $pi * $r * $r * $h}]\n    return $volume\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_cone 5 12] == 314.15926535897927}\nassert {[volume_cone 10 15] == 1570.7963267948965}\nassert {[volume_cone 19 17] == 6426.651371693521}",
        "declaration": "proc volume_cone {r h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_cone 5 12] == 314.15926535897927}",
        "prompt_text": "Write a function to find the volume of a cone.",
        "prompt_explain": "Write a function to find the volume of a cone.\n>>> volume_cone 5 12\n314.15926535897927",
        "func_title": "proc volume_cone {r h}"
    },
    {
        "prompt": "# Given a rectangular grid of dimension 2 x n, write a function to find out the maximum sum such that no two chosen numbers are adjacent.\n# >>> max_sum_rectangular_grid { {1 4 5} {2 0 0} } 3\n# 7\nproc max_sum_rectangular_grid {grid n} {",
        "canonical_solution": "    set incl [expr {max([lindex $grid 0 0], [lindex $grid 1 0])}]\n    set excl 0\n    for {set i 1} {$i < $n} {incr i} {\n        set excl_new [expr {max($excl, $incl)}]\n        set incl [expr {$excl + max([lindex $grid 0 $i], [lindex $grid 1 $i])}]\n        set excl $excl_new\n    }\n    return [expr {max($excl, $incl)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sum_rectangular_grid { {1 4 5} {2 0 0} } 3] == 7}\nassert {[max_sum_rectangular_grid { {1 2 3 4 5} {6 7 8 9 10} } 5] == 24}\nassert {[max_sum_rectangular_grid { {7 9 11 15 19} {21 25 28 31 32} } 5] == 81}",
        "declaration": "proc max_sum_rectangular_grid {grid n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sum_rectangular_grid { {1 4 5} {2 0 0} } 3] == 7}",
        "prompt_text": "Given a rectangular grid of dimension 2 x n, write a function to find out the maximum sum such that no two chosen numbers are adjacent.",
        "prompt_explain": "Given a rectangular grid of dimension 2 x n, write a function to find out the maximum sum such that no two chosen numbers are adjacent.\n>>> max_sum_rectangular_grid { {1 4 5} {2 0 0} } 3\n7",
        "func_title": "proc max_sum_rectangular_grid {grid n}"
    },
    {
        "prompt": "# Given a sorted list of integers and a number, find the index of the last occurrence of the number in the list.\n# >>> find_last_occurrence {2 5 5 5 6 6 8 9 9 9} 5\n# 3\nproc find_last_occurrence {A x} {",
        "canonical_solution": "    set left 0\n    set right [expr {[llength $A] - 1}]\n    set result -1\n    while {$left <= $right} {\n        set mid [expr {($left + $right) / 2}]\n        if {$x == [lindex $A $mid]} {\n            set result $mid\n            set left [expr {$mid + 1}]\n        } elseif {$x < [lindex $A $mid]} {\n            set right [expr {$mid - 1}]\n        } else {\n            set left [expr {$mid + 1}]\n        }\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_last_occurrence {2 5 5 5 6 6 8 9 9 9} 5] == 3}\nassert {[find_last_occurrence {2 3 5 8 6 6 8 9 9 9} 9] == 9}\nassert {[find_last_occurrence {2 2 1 5 6 6 6 9 9 9} 6] == 6}",
        "declaration": "proc find_last_occurrence {A x} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_last_occurrence {2 5 5 5 6 6 8 9 9 9} 5] == 3}",
        "prompt_text": "Given a sorted list of integers and a number, find the index of the last occurrence of the number in the list.",
        "prompt_explain": "Given a sorted list of integers and a number, find the index of the last occurrence of the number in the list.\n>>> find_last_occurrence {2 5 5 5 6 6 8 9 9 9} 5\n3",
        "func_title": "proc find_last_occurrence {A x}"
    },
    {
        "prompt": "# Given the sum of the sides of a cuboid, find the maximum volume that can be achieved.\n# >>> max_volume 8\n# 18\nproc max_volume {s} {",
        "canonical_solution": "    set maxvalue 0\n    for {set i 1} {$i < $s} {incr i} {\n        for {set j 1} {$j < $s} {incr j} {\n            set k [expr {$s - $i - $j}]\n            if {$k > 0} {\n                set maxvalue [expr {max($maxvalue, $i * $j * $k)}]\n            }\n        }\n    }\n    return $maxvalue\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_volume 8] == 18}\nassert {[max_volume 4] == 2}\nassert {[max_volume 1] == 0}",
        "declaration": "proc max_volume {s} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_volume 8] == 18}",
        "prompt_text": "Given the sum of the sides of a cuboid, find the maximum volume that can be achieved.",
        "prompt_explain": "Given the sum of the sides of a cuboid, find the maximum volume that can be achieved.\n>>> max_volume 8\n18",
        "func_title": "proc max_volume {s}"
    },
    {
        "prompt": "# Write a function to calculate the difference between the squared sum of first n natural numbers and the sum of squared first n natural numbers.\n# >>> sum_difference 12\n# 5434\nproc sum_difference {n} {",
        "canonical_solution": "    set sumofsquares 0\n    set squareofsum 0\n    for {set num 1} {$num <= $n} {incr num} {\n        set sumofsquares [expr {$sumofsquares + $num * $num}]\n        set squareofsum [expr {$squareofsum + $num}]\n    }\n    set squareofsum [expr {$squareofsum ** 2}]\n    return [expr {$squareofsum - $sumofsquares}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_difference 12] == 5434}\nassert {[sum_difference 20] == 41230}\nassert {[sum_difference 54] == 2151270}",
        "declaration": "proc sum_difference {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_difference 12] == 5434}",
        "prompt_text": "Write a function to calculate the difference between the squared sum of first n natural numbers and the sum of squared first n natural numbers.",
        "prompt_explain": "Write a function to calculate the difference between the squared sum of first n natural numbers and the sum of squared first n natural numbers.\n>>> sum_difference 12\n5434",
        "func_title": "proc sum_difference {n}"
    },
    {
        "prompt": "# Given a number, find its Demlo number. A Demlo number is a number that is a concatenation of numbers from 1 to n and then back to 1.\n# >>> find_demlo 111111\n# 12345654321\nproc find_demlo {s} {",
        "canonical_solution": "    set l [string length $s]\n    set res \"\"\n    for {set i 1} {$i <= $l} {incr i} {\n        append res $i\n    }\n    for {set i [expr {$l - 1}]} {$i >= 1} {incr i -1} {\n        append res $i\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_demlo \"111111\"] eq \"12345654321\"}\nassert {[find_demlo \"1111\"] eq \"1234321\"}\nassert {[find_demlo \"13333122222\"] eq \"123456789101110987654321\"}",
        "declaration": "proc find_demlo {s} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_demlo \"111111\"] eq \"12345654321\"}",
        "prompt_text": "Given a number, find its Demlo number. A Demlo number is a number that is a concatenation of numbers from 1 to n and then back to 1.",
        "prompt_explain": "Given a number, find its Demlo number. A Demlo number is a number that is a concatenation of numbers from 1 to n and then back to 1.\n>>> find_demlo 111111\n12345654321",
        "func_title": "proc find_demlo {s}"
    },
    {
        "prompt": "# Write a Tcl function to find the minimum number of squares whose sum is equal to a given number.\n# >>> get_Min_Squares 6\n# 3\nproc get_Min_Squares {n} {",
        "canonical_solution": "    if {$n <= 3} {\n        return $n\n    }\n    set res $n\n    for {set x 1} {$x <= $n} {incr x} {\n        set temp [expr {$x * $x}]\n        if {$temp > $n} {\n            break\n        } else {\n            set res [expr {min($res, 1 + [get_Min_Squares [expr {$n - $temp}]])}]\n        }\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Min_Squares 6] == 3}\nassert {[get_Min_Squares 2] == 2}\nassert {[get_Min_Squares 4] == 1}",
        "declaration": "proc get_Min_Squares {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Min_Squares 6] == 3}",
        "prompt_text": "Write a Tcl function to find the minimum number of squares whose sum is equal to a given number.",
        "prompt_explain": "Write a Tcl function to find the minimum number of squares whose sum is equal to a given number.\n>>> get_Min_Squares 6\n3",
        "func_title": "proc get_Min_Squares {n}"
    },
    {
        "prompt": "# Write a function to check if the triangle is isosceles or not.\n# >>> check_isosceles 6 8 12\n# False\n# >>> check_isosceles 6 6 12\n# True\n# >>> check_isosceles 6 16 20\n# False\nproc check_isosceles {x y z} {",
        "canonical_solution": "    if {$x == $y || $y == $z || $z == $x} {\n        return True\n    } else {\n        return False\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_isosceles 6 8 12] eq False}\nassert {[check_isosceles 6 6 12] eq True}\nassert {[check_isosceles 6 16 20] eq False}",
        "declaration": "proc check_isosceles {x y z} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_isosceles 6 8 12] eq False}",
        "prompt_text": "Write a function to check if the triangle is isosceles or not.",
        "prompt_explain": "Write a function to check if the triangle is isosceles or not.\n>>> check_isosceles 6 8 12\nFalse\n>>> check_isosceles 6 6 12\nTrue\n>>> check_isosceles 6 16 20\nFalse",
        "func_title": "proc check_isosceles {x y z}"
    },
    {
        "prompt": "# Write a function to find the sum of arithmetic progression.\n# >>> ap_sum 1 5 2\n# 25\nproc ap_sum {a n d} {",
        "canonical_solution": "    set total [expr {($n * (2 * $a + ($n - 1) * $d)) / 2}]\n    return $total\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[ap_sum 1 5 2] == 25}\nassert {[ap_sum 2 6 4] == 72}\nassert {[ap_sum 1 4 5] == 34}",
        "declaration": "proc ap_sum {a n d} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[ap_sum 1 5 2] == 25}",
        "prompt_text": "Write a function to find the sum of arithmetic progression.",
        "prompt_explain": "Write a function to find the sum of arithmetic progression.\n>>> ap_sum 1 5 2\n25",
        "func_title": "proc ap_sum {a n d}"
    },
    {
        "prompt": "# Write a function to check whether the given month name contains 28 days or not.\n# >>> check_monthnum \"February\"\n# 1\n# >>> check_monthnum \"January\"\n# 0\nproc check_monthnum {monthname1} {",
        "canonical_solution": "    if {$monthname1 eq \"February\"} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_monthnum \"February\"] == 1}\nassert {[check_monthnum \"January\"] == 0}\nassert {[check_monthnum \"March\"] == 0}",
        "declaration": "proc check_monthnum {monthname1} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_monthnum \"February\"] == 1}",
        "prompt_text": "Write a function to check whether the given month name contains 28 days or not.",
        "prompt_explain": "Write a function to check whether the given month name contains 28 days or not.\n>>> check_monthnum \"February\"\n1\n>>> check_monthnum \"January\"\n0",
        "func_title": "proc check_monthnum {monthname1}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the given string is a binary string or not.\n# >>> check_binary \"01010101010\"\n# Yes\n# >>> check_binary \"name0\"\n# No\nproc check_binary {string} {",
        "canonical_solution": "    set p [split $string \"\"]\n    set s {0 1}\n    if {[lsort -unique $p] eq [lsort -unique $s]} {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_binary \"01010101010\"] eq \"Yes\"}\nassert {[check_binary \"name0\"] eq \"No\"}\nassert {[check_binary \"101\"] eq \"Yes\"}",
        "declaration": "proc check_binary {string} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_binary \"01010101010\"] eq \"Yes\"}",
        "prompt_text": "Write a Tcl function to check whether the given string is a binary string or not.",
        "prompt_explain": "Write a Tcl function to check whether the given string is a binary string or not.\n>>> check_binary \"01010101010\"\nYes\n>>> check_binary \"name0\"\nNo",
        "func_title": "proc check_binary {string}"
    },
    {
        "prompt": "# Write a Tcl function to check whether all the characters in a given string are unique.\n# >>> unique_Characters 'aba'\n# 0\n# >>> unique_Characters 'abc'\n# 1\nproc unique_Characters {str} {",
        "canonical_solution": "    set length [string length $str]\n    for {set i 0} {$i < $length} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $length} {incr j} {\n            if {[string index $str $i] eq [string index $str $j]} {\n                return 0\n            }\n        }\n    }\n    return 1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[unique_Characters 'aba'] == 0}\nassert {[unique_Characters 'abc'] == 1}\nassert {[unique_Characters 'abab'] == 0}",
        "declaration": "proc unique_Characters {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[unique_Characters 'aba'] == 0}",
        "prompt_text": "Write a Tcl function to check whether all the characters in a given string are unique.",
        "prompt_explain": "Write a Tcl function to check whether all the characters in a given string are unique.\n>>> unique_Characters 'aba'\n0\n>>> unique_Characters 'abc'\n1",
        "func_title": "proc unique_Characters {str}"
    },
    {
        "prompt": "# Write a function to find the nth term of an arithmetic progression.\n# >>> tn_ap 1 5 2\n# 9\nproc tn_ap {a n d} {",
        "canonical_solution": "    set tn [expr {$a + ($n - 1) * $d}]\n    return $tn\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[tn_ap 1 5 2] == 9}\nassert {[tn_ap 2 6 4] == 22}\nassert {[tn_ap 1 4 5] == 16}",
        "declaration": "proc tn_ap {a n d} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[tn_ap 1 5 2] == 9}",
        "prompt_text": "Write a function to find the nth term of an arithmetic progression.",
        "prompt_explain": "Write a function to find the nth term of an arithmetic progression.\n>>> tn_ap 1 5 2\n9",
        "func_title": "proc tn_ap {a n d}"
    },
    {
        "prompt": "# Given a list of tuple records, find the maximum element across all tuples.\n# >>> find_max {{2 4} {6 7} {5 1} {6 10} {8 7}}\n# 10\nproc find_max {test_list} {",
        "canonical_solution": "    set max_val [lindex [lindex $test_list 0] 0]\n    foreach tuple $test_list {\n        foreach element $tuple {\n            if {$element > $max_val} {\n                set max_val $element\n            }\n        }\n    }\n    return $max_val\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {{2 4} {6 7} {5 1} {6 10} {8 7}}] == 10}\nassert {[find_max {{3 5} {7 8} {6 2} {7 11} {9 8}}] == 11}\nassert {[find_max {{4 6} {8 9} {7 3} {8 12} {10 9}}] == 12}",
        "declaration": "proc find_max {test_list} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {{2 4} {6 7} {5 1} {6 10} {8 7}}] == 10}",
        "prompt_text": "Given a list of tuple records, find the maximum element across all tuples.",
        "prompt_explain": "Given a list of tuple records, find the maximum element across all tuples.\n>>> find_max {{2 4} {6 7} {5 1} {6 10} {8 7}}\n10",
        "func_title": "proc find_max {test_list}"
    },
    {
        "prompt": "# Write a Tcl function to check whether one root of the quadratic equation is twice of the other or not.\n# >>> Check_Solution 1 3 2\n# Yes\n# >>> Check_Solution 1 2 3\n# No\nproc Check_Solution {a b c} {",
        "canonical_solution": "    if {[expr {2 * $b * $b}] == [expr {9 * $a * $c}]} {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Check_Solution 1 3 2] eq \"Yes\"}\nassert {[Check_Solution 1 2 3] eq \"No\"}\nassert {[Check_Solution 1 -5 6] eq \"No\"}",
        "declaration": "proc Check_Solution {a b c} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Check_Solution 1 3 2] eq \"Yes\"}",
        "prompt_text": "Write a Tcl function to check whether one root of the quadratic equation is twice of the other or not.",
        "prompt_explain": "Write a Tcl function to check whether one root of the quadratic equation is twice of the other or not.\n>>> Check_Solution 1 3 2\nYes\n>>> Check_Solution 1 2 3\nNo",
        "func_title": "proc Check_Solution {a b c}"
    },
    {
        "prompt": "# Given a list of integers, return the item with maximum occurrences in the list.\n# >>> max_occurrences {1 2 3 1 2 3 12 4 2}\n# 2\nproc max_occurrences {nums} {",
        "canonical_solution": "    set max_val 0\n    set result [lindex $nums 0]\n    foreach i $nums {\n        set occu [llength [lsearch -all $nums $i]]\n        if {$occu > $max_val} {\n            set max_val $occu\n            set result $i\n        }\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_occurrences {1 2 3 1 2 3 12 4 2}] == 2}\nassert {[max_occurrences {1 2 6 7 0 1 0 1 0}] == 1}\nassert {[max_occurrences {1 2 3 1 2 4 1}] == 1}",
        "declaration": "proc max_occurrences {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_occurrences {1 2 3 1 2 3 12 4 2}] == 2}",
        "prompt_text": "Given a list of integers, return the item with maximum occurrences in the list.",
        "prompt_explain": "Given a list of integers, return the item with maximum occurrences in the list.\n>>> max_occurrences {1 2 3 1 2 3 12 4 2}\n2",
        "func_title": "proc max_occurrences {nums}"
    },
    {
        "prompt": "# Write a Tcl function to count the number of digits of a given number.\n# >>> count_Digit 12345\n# 5\nproc count_Digit {n} {",
        "canonical_solution": "    set count 0\n    while {$n != 0} {\n        set n [expr {$n / 10}]\n        incr count\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Digit 12345] == 5}\nassert {[count_Digit 11223305] == 8}\nassert {[count_Digit 4123459] == 7}",
        "declaration": "proc count_Digit {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Digit 12345] == 5}",
        "prompt_text": "Write a Tcl function to count the number of digits of a given number.",
        "prompt_explain": "Write a Tcl function to count the number of digits of a given number.\n>>> count_Digit 12345\n5",
        "func_title": "proc count_Digit {n}"
    },
    {
        "prompt": "# Write a function to find the lateral surface area of a cuboid\n# >>> lateralsurface_cuboid 8 5 6\n# 156\nproc lateralsurface_cuboid {l w h} {",
        "canonical_solution": "    set LSA [expr {2 * $h * ($l + $w)}]\n    return $LSA\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[lateralsurface_cuboid 8 5 6] == 156}\nassert {[lateralsurface_cuboid 7 9 10] == 320}\nassert {[lateralsurface_cuboid 10 20 30] == 1800}",
        "declaration": "proc lateralsurface_cuboid {l w h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[lateralsurface_cuboid 8 5 6] == 156}",
        "prompt_text": "Write a function to find the lateral surface area of a cuboid",
        "prompt_explain": "Write a function to find the lateral surface area of a cuboid\n>>> lateralsurface_cuboid 8 5 6\n156",
        "func_title": "proc lateralsurface_cuboid {l w h}"
    },
    {
        "prompt": "# Given a sorted list of integers, find the smallest missing element.\n# >>> smallest_missing {0 1 2 3 4 5 6} 0 6\n# 7\nproc smallest_missing {A left_element right_element} {",
        "canonical_solution": "    if {$left_element > $right_element} {\n        return $left_element\n    }\n    set mid [expr {$left_element + ($right_element - $left_element) / 2}]\n    if {[lindex $A $mid] == $mid} {\n        return [smallest_missing $A [expr {$mid + 1}] $right_element]\n    } else {\n        return [smallest_missing $A $left_element [expr {$mid - 1}]]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smallest_missing {0 1 2 3 4 5 6} 0 6] == 7}\nassert {[smallest_missing {0 1 2 6 9 11 15} 0 6] == 3}\nassert {[smallest_missing {1 2 3 4 6 9 11 15} 0 7] == 0}",
        "declaration": "proc smallest_missing {A left_element right_element} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smallest_missing {0 1 2 3 4 5 6} 0 6] == 7}",
        "prompt_text": "Given a sorted list of integers, find the smallest missing element.",
        "prompt_explain": "Given a sorted list of integers, find the smallest missing element.\n>>> smallest_missing {0 1 2 3 4 5 6} 0 6\n7",
        "func_title": "proc smallest_missing {A left_element right_element}"
    },
    {
        "prompt": "# Write a function to find the volume of a cuboid.\n# >>> volume_cuboid 1 2 3\n# 6\nproc volume_cuboid {l w h} {",
        "canonical_solution": "    set volume [expr {$l * $w * $h}]\n    return $volume\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_cuboid 1 2 3] == 6}\nassert {[volume_cuboid 5 7 9] == 315}\nassert {[volume_cuboid 10 15 21] == 3150}",
        "declaration": "proc volume_cuboid {l w h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_cuboid 1 2 3] == 6}",
        "prompt_text": "Write a function to find the volume of a cuboid.",
        "prompt_explain": "Write a function to find the volume of a cuboid.\n>>> volume_cuboid 1 2 3\n6",
        "func_title": "proc volume_cuboid {l w h}"
    },
    {
        "prompt": "# Write a function to round the given number to the nearest multiple of a specific number.\n# >>> round_num 4722 10\n# 4720\nproc round_num {n m} {",
        "canonical_solution": "    set a [expr {($n / $m) * $m}]\n    set b [expr {$a + $m}]\n    if {[expr {$n - $a}] > [expr {$b - $n}]} {\n        return $b\n    } else {\n        return $a\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[round_num 4722 10] == 4720}\nassert {[round_num 1111 5] == 1110}\nassert {[round_num 219 2] == 218}",
        "declaration": "proc round_num {n m} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[round_num 4722 10] == 4720}",
        "prompt_text": "Write a function to round the given number to the nearest multiple of a specific number.",
        "prompt_explain": "Write a function to round the given number to the nearest multiple of a specific number.\n>>> round_num 4722 10\n4720",
        "func_title": "proc round_num {n m}"
    },
    {
        "prompt": "# Write a function to find the surface area of a cuboid.\n# >>> surfacearea_cuboid 1 2 3\n# 22\nproc surfacearea_cuboid {l w h} {",
        "canonical_solution": "    set SA [expr {2 * ($l * $w + $l * $h + $w * $h)}]\n    return $SA\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surfacearea_cuboid 1 2 3] == 22}\nassert {[surfacearea_cuboid 5 7 9] == 286}\nassert {[surfacearea_cuboid 10 15 21] == 1350}",
        "declaration": "proc surfacearea_cuboid {l w h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surfacearea_cuboid 1 2 3] == 22}",
        "prompt_text": "Write a function to find the surface area of a cuboid.",
        "prompt_explain": "Write a function to find the surface area of a cuboid.\n>>> surfacearea_cuboid 1 2 3\n22",
        "func_title": "proc surfacearea_cuboid {l w h}"
    },
    {
        "prompt": "# Write a Tcl function to toggle all odd bits of a given number.\n# >>> even_bit_toggle_number 10\n# 15\nproc even_bit_toggle_number {n} {",
        "canonical_solution": "    set res 0\n    set count 0\n    set temp $n\n    while {$temp > 0} {\n        if {$count % 2 == 0} {\n            set res [expr {$res | (1 << $count)}]\n        }\n        incr count\n        set temp [expr {$temp >> 1}]\n    }\n    return [expr {$n ^ $res}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_bit_toggle_number 10] == 15}\nassert {[even_bit_toggle_number 20] == 1}\nassert {[even_bit_toggle_number 30] == 11}",
        "declaration": "proc even_bit_toggle_number {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_bit_toggle_number 10] == 15}",
        "prompt_text": "Write a Tcl function to toggle all odd bits of a given number.",
        "prompt_explain": "Write a Tcl function to toggle all odd bits of a given number.\n>>> even_bit_toggle_number 10\n15",
        "func_title": "proc even_bit_toggle_number {n}"
    },
    {
        "prompt": "# Write a Tcl function to find the highest power of 2 that is less than or equal to n.\n# >>> highest_Power_of_2 10\n# 8\nproc highest_Power_of_2 {n} {",
        "canonical_solution": "    set res 0\n    for {set i $n} {$i > 0} {incr i -1} {\n        if {[expr {$i & ($i - 1)}] == 0} {\n            set res $i\n            break\n        }\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[highest_Power_of_2 10] == 8}\nassert {[highest_Power_of_2 19] == 16}\nassert {[highest_Power_of_2 32] == 32}",
        "declaration": "proc highest_Power_of_2 {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[highest_Power_of_2 10] == 8}",
        "prompt_text": "Write a Tcl function to find the highest power of 2 that is less than or equal to n.",
        "prompt_explain": "Write a Tcl function to find the highest power of 2 that is less than or equal to n.\n>>> highest_Power_of_2 10\n8",
        "func_title": "proc highest_Power_of_2 {n}"
    },
    {
        "prompt": "# Given a number n, find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n# >>> get_max_sum 60\n# 106\nproc get_max_sum {n} {",
        "canonical_solution": "    set res [list 0 1]\n    for {set i 2} {$i <= $n} {incr i} {\n        set sum [expr {[lindex $res [expr {$i / 2}]] + [lindex $res [expr {$i / 3}]] + [lindex $res [expr {$i / 4}]] + [lindex $res [expr {$i / 5}]]}]\n        lappend res [expr {max($sum, $i)}]\n    }\n    return [lindex $res $n]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_max_sum 60] == 106}\nassert {[get_max_sum 10] == 12}\nassert {[get_max_sum 2] == 2}",
        "declaration": "proc get_max_sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_max_sum 60] == 106}",
        "prompt_text": "Given a number n, find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).",
        "prompt_explain": "Given a number n, find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n>>> get_max_sum 60\n106",
        "func_title": "proc get_max_sum {n}"
    },
    {
        "prompt": "# Given a list of numbers, compute the sum of digits of each number in the list.\n# >>> sum_of_digits {10 2 56}\n# 14\nproc sum_of_digits {nums} {",
        "canonical_solution": "    set total 0\n    foreach n $nums {\n        foreach el [split $n {}] {\n            if {[string is digit $el]} {\n                incr total $el\n            }\n        }\n    }\n    return $total\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_of_digits {10 2 56}] == 14}\nassert {[sum_of_digits {10 20 4 5 b 70 a}] == 19}\nassert {[sum_of_digits {10 20 -4 5 -70}] == 19}",
        "declaration": "proc sum_of_digits {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_of_digits {10 2 56}] == 14}",
        "prompt_text": "Given a list of numbers, compute the sum of digits of each number in the list.",
        "prompt_explain": "Given a list of numbers, compute the sum of digits of each number in the list.\n>>> sum_of_digits {10 2 56}\n14",
        "func_title": "proc sum_of_digits {nums}"
    },
    {
        "prompt": "# Write a function to compute the value of ncr%p.\n# >>> ncr_modp 10 2 13\n# 6\nproc ncr_modp {n r p} {",
        "canonical_solution": "    set C [lrepeat [expr {$r + 1}] 0]\n    lset C 0 1\n    for {set i 1} {$i <= $n} {incr i} {\n        for {set j [expr {min($i, $r)}]} {$j > 0} {incr j -1} {\n            lset C $j [expr {([lindex $C $j] + [lindex $C [expr {$j - 1}]]) % $p}]\n        }\n    }\n    return [lindex $C $r]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[ncr_modp 10 2 13] == 6}\nassert {[ncr_modp 15 12 43] == 25}\nassert {[ncr_modp 17 9 18] == 10}",
        "declaration": "proc ncr_modp {n r p} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[ncr_modp 10 2 13] == 6}",
        "prompt_text": "Write a function to compute the value of ncr%p.",
        "prompt_explain": "Write a function to compute the value of ncr%p.\n>>> ncr_modp 10 2 13\n6",
        "func_title": "proc ncr_modp {n r p}"
    },
    {
        "prompt": "# Write a Tcl function to find the minimum of two numbers.\n# >>> minimum 1 2\n# 1\nproc minimum {a b} {",
        "canonical_solution": "    if {$a <= $b} {\n        return $a\n    } else {\n        return $b\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[minimum 1 2] == 1}\nassert {[minimum -5 -4] == -5}\nassert {[minimum 0 0] == 0}",
        "declaration": "proc minimum {a b} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[minimum 1 2] == 1}",
        "prompt_text": "Write a Tcl function to find the minimum of two numbers.",
        "prompt_explain": "Write a Tcl function to find the minimum of two numbers.\n>>> minimum 1 2\n1",
        "func_title": "proc minimum {a b}"
    },
    {
        "prompt": "# Given a tuple and an element, check whether the element exists within the tuple.\n# >>> check_tuplex {w 3 r e s o u r c e} r\n# 1\nproc check_tuplex {tuplex element} {",
        "canonical_solution": "    if {$element in $tuplex} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_tuplex {w 3 r e s o u r c e} r] == 1}\nassert {[check_tuplex {w 3 r e s o u r c e} 5] == 0}\nassert {[check_tuplex {w 3 r e s o u r c e} 3] == 1}",
        "declaration": "proc check_tuplex {tuplex element} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_tuplex {w 3 r e s o u r c e} r] == 1}",
        "prompt_text": "Given a tuple and an element, check whether the element exists within the tuple.",
        "prompt_explain": "Given a tuple and an element, check whether the element exists within the tuple.\n>>> check_tuplex {w 3 r e s o u r c e} r\n1",
        "func_title": "proc check_tuplex {tuplex element}"
    },
    {
        "prompt": "# Given a heterogeneous list, return the minimum integer value.\n# >>> min_val {Python 3 2 4 5 version}\n# 2\nproc min_val {listval} {",
        "canonical_solution": "    set min_val {}\n    foreach i $listval {\n        if {[string is integer -strict $i]} {\n            if {$min_val eq {} || $i < $min_val} {\n                set min_val $i\n            }\n        }\n    }\n    return $min_val\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_val {Python 3 2 4 5 version}] == 2}\nassert {[min_val {Python 15 20 25}] == 15}\nassert {[min_val {Python 30 20 40 50 version}] == 20}",
        "declaration": "proc min_val {listval} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_val {Python 3 2 4 5 version}] == 2}",
        "prompt_text": "Given a heterogeneous list, return the minimum integer value.",
        "prompt_explain": "Given a heterogeneous list, return the minimum integer value.\n>>> min_val {Python 3 2 4 5 version}\n2",
        "func_title": "proc min_val {listval}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the value exists in a sequence or not.\n# >>> overlapping {1 2 3 4 5} {6 7 8 9}\n# 0\n# >>> overlapping {1 2 3} {4 5 6}\n# 0\n# >>> overlapping {1 4 5} {1 4 5}\n# 1\nproc overlapping {list1 list2} {",
        "canonical_solution": "    foreach i $list1 {\n        foreach j $list2 {\n            if {$i == $j} {\n                return 1\n            }\n        }\n    }\n    return 0\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[overlapping {1 2 3 4 5} {6 7 8 9}] == 0}\nassert {[overlapping {1 2 3} {4 5 6}] == 0}\nassert {[overlapping {1 4 5} {1 4 5}] == 1}",
        "declaration": "proc overlapping {list1 list2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[overlapping {1 2 3 4 5} {6 7 8 9}] == 0}",
        "prompt_text": "Write a Tcl function to check whether the value exists in a sequence or not.",
        "prompt_explain": "Write a Tcl function to check whether the value exists in a sequence or not.\n>>> overlapping {1 2 3 4 5} {6 7 8 9}\n0\n>>> overlapping {1 2 3} {4 5 6}\n0\n>>> overlapping {1 4 5} {1 4 5}\n1",
        "func_title": "proc overlapping {list1 list2}"
    },
    {
        "prompt": "# Given a number, find the maximum sum we can make by dividing the number into three parts recursively and summing them up together.\n# >>> breakSum 12\n# 13\nproc breakSum {n} {",
        "canonical_solution": "    set dp [list]\n    for {set i 0} {$i <= $n} {incr i} {\n        lappend dp 0\n    }\n    lset dp 0 0\n    lset dp 1 1\n    for {set i 2} {$i <= $n} {incr i} {\n        set half [expr {$i / 2}]\n        set third [expr {$i / 3}]\n        set fourth [expr {$i / 4}]\n        set sum [expr {[lindex $dp $half] + [lindex $dp $third] + [lindex $dp $fourth]}]\n        lset dp $i [expr {$sum > $i ? $sum : $i}]\n    }\n    return [lindex $dp $n]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[breakSum 12] == 13}\nassert {[breakSum 24] == 27}\nassert {[breakSum 23] == 23}",
        "declaration": "proc breakSum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[breakSum 12] == 13}",
        "prompt_text": "Given a number, find the maximum sum we can make by dividing the number into three parts recursively and summing them up together.",
        "prompt_explain": "Given a number, find the maximum sum we can make by dividing the number into three parts recursively and summing them up together.\n>>> breakSum 12\n13",
        "func_title": "proc breakSum {n}"
    },
    {
        "prompt": "# Write a Tcl function to find the cube sum of first n even natural numbers.\n# >>> cube_Sum 2\n# 72\n# >>> cube_Sum 3\n# 288\n# >>> cube_Sum 4\n# 800\nproc cube_Sum {n} {",
        "canonical_solution": "    set sum 0\n    for {set i 1} {$i <= $n} {incr i} {\n        set even [expr {2 * $i}]\n        set cube [expr {$even * $even * $even}]\n        set sum [expr {$sum + $cube}]\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[cube_Sum 2] == 72}\nassert {[cube_Sum 3] == 288}\nassert {[cube_Sum 4] == 800}",
        "declaration": "proc cube_Sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[cube_Sum 2] == 72}",
        "prompt_text": "Write a Tcl function to find the cube sum of first n even natural numbers.",
        "prompt_explain": "Write a Tcl function to find the cube sum of first n even natural numbers.\n>>> cube_Sum 2\n72\n>>> cube_Sum 3\n288\n>>> cube_Sum 4\n800",
        "func_title": "proc cube_Sum {n}"
    },
    {
        "prompt": "# Write a function to find the directrix of a parabola given its coefficients a, b, and c in the equation y = ax^2 + bx + c.\n# >>> parabola_directrix 5 3 2\n# -198\nproc parabola_directrix {a b c} {",
        "canonical_solution": "    set directrix [expr {int($c - (($b * $b) + 1) * 4 * $a)}]\n    return $directrix\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[parabola_directrix 5 3 2] == -198}\nassert {[parabola_directrix 9 8 4] == -2336}\nassert {[parabola_directrix 2 4 6] == -130}",
        "declaration": "proc parabola_directrix {a b c} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[parabola_directrix 5 3 2] == -198}",
        "prompt_text": "Write a function to find the directrix of a parabola given its coefficients a, b, and c in the equation y = ax^2 + bx + c.",
        "prompt_explain": "Write a function to find the directrix of a parabola given its coefficients a, b, and c in the equation y = ax^2 + bx + c.\n>>> parabola_directrix 5 3 2\n-198",
        "func_title": "proc parabola_directrix {a b c}"
    },
    {
        "prompt": "# Write a function that takes two lists and returns true if they have at least one common element.\n# >>> common_element {1 2 3 4 5} {5 6 7 8 9}\n# true\nproc common_element {list1 list2} {",
        "canonical_solution": "    foreach x $list1 {\n        foreach y $list2 {\n            if {$x == $y} {\n                return true\n            }\n        }\n    }\n    return false\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[common_element {1 2 3 4 5} {5 6 7 8 9}] == true}\nassert {[common_element {1 2 3 4 5} {6 7 8 9}] == false}\nassert {[common_element {a b c} {d b e}] == true}",
        "declaration": "proc common_element {list1 list2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[common_element {1 2 3 4 5} {5 6 7 8 9}] == true}",
        "prompt_text": "Write a function that takes two lists and returns true if they have at least one common element.",
        "prompt_explain": "Write a function that takes two lists and returns true if they have at least one common element.\n>>> common_element {1 2 3 4 5} {5 6 7 8 9}\ntrue",
        "func_title": "proc common_element {list1 list2}"
    },
    {
        "prompt": "# Given the lengths of the two bases and the height of a trapezium, return the median.\n# >>> median_trapezium 15 25 35\n# 20\nproc median_trapezium {base1 base2 height} {",
        "canonical_solution": "    set median [expr {0.5 * ($base1 + $base2)}]\n    return $median\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[median_trapezium 15 25 35] == 20}\nassert {[median_trapezium 10 20 30] == 15}\nassert {[median_trapezium 6 9 4] == 7.5}",
        "declaration": "proc median_trapezium {base1 base2 height} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[median_trapezium 15 25 35] == 20}",
        "prompt_text": "Given the lengths of the two bases and the height of a trapezium, return the median.",
        "prompt_explain": "Given the lengths of the two bases and the height of a trapezium, return the median.\n>>> median_trapezium 15 25 35\n20",
        "func_title": "proc median_trapezium {base1 base2 height}"
    },
    {
        "prompt": "# Given a number, return its last digit.\n# >>> last_Digit 123\n# 3\nproc last_Digit {n} {",
        "canonical_solution": "    return [expr {$n % 10}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[last_Digit 123] == 3}\nassert {[last_Digit 25] == 5}\nassert {[last_Digit 30] == 0}",
        "declaration": "proc last_Digit {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[last_Digit 123] == 3}",
        "prompt_text": "Given a number, return its last digit.",
        "prompt_explain": "Given a number, return its last digit.\n>>> last_Digit 123\n3",
        "func_title": "proc last_Digit {n}"
    },
    {
        "prompt": "# Given a list of integers, convert it into a single integer.\n# >>> multiple_to_single {11 33 50}\n# 113350\nproc multiple_to_single {L} {",
        "canonical_solution": "    set result \"\"\n    foreach num $L {\n        append result $num\n    }\n    return [expr {$result}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[multiple_to_single {11 33 50}] == 113350}\nassert {[multiple_to_single {-1 2 3 4 5 6}] == -123456}\nassert {[multiple_to_single {10 15 20 25}] == 10152025}",
        "declaration": "proc multiple_to_single {L} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[multiple_to_single {11 33 50}] == 113350}",
        "prompt_text": "Given a list of integers, convert it into a single integer.",
        "prompt_explain": "Given a list of integers, convert it into a single integer.\n>>> multiple_to_single {11 33 50}\n113350",
        "func_title": "proc multiple_to_single {L}"
    },
    {
        "prompt": "# Write a function to find the surface area of a cube.\n# >>> surfacearea_cube 5\n# 150\nproc surfacearea_cube {l} {",
        "canonical_solution": "    set surfacearea [expr {6 * $l * $l}]\n    return $surfacearea\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surfacearea_cube 5] == 150}\nassert {[surfacearea_cube 3] == 54}\nassert {[surfacearea_cube 10] == 600}",
        "declaration": "proc surfacearea_cube {l} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surfacearea_cube 5] == 150}",
        "prompt_text": "Write a function to find the surface area of a cube.",
        "prompt_explain": "Write a function to find the surface area of a cube.\n>>> surfacearea_cube 5\n150",
        "func_title": "proc surfacearea_cube {l}"
    },
    {
        "prompt": "# Given a tuple and a list, count the occurrence of all elements of the list in the tuple.\n# >>> count_Occurrence {'a' 'a' 'c' 'b' 'd'} {'a' 'b'}\n# 3\nproc count_Occurrence {tup lst} {",
        "canonical_solution": "    set count 0\n    foreach item $tup {\n        if {$item in $lst} {\n            incr count\n        }\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Occurrence {'a' 'a' 'c' 'b' 'd'} {'a' 'b'}] == 3}\nassert {[count_Occurrence {1 2 3 1 4 6 7 1 4} {1 4 7}] == 6}\nassert {[count_Occurrence {1 2 3 4 5 6} {1 2}] == 2}",
        "declaration": "proc count_Occurrence {tup lst} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Occurrence {'a' 'a' 'c' 'b' 'd'} {'a' 'b'}] == 3}",
        "prompt_text": "Given a tuple and a list, count the occurrence of all elements of the list in the tuple.",
        "prompt_explain": "Given a tuple and a list, count the occurrence of all elements of the list in the tuple.\n>>> count_Occurrence {'a' 'a' 'c' 'b' 'd'} {'a' 'b'}\n3",
        "func_title": "proc count_Occurrence {tup lst}"
    },
    {
        "prompt": "# Given three points (x1,y1), (x2,y2), (x3,y3), check whether they form a valid triangle.\n# >>> check_Triangle 1 5 2 5 4 6\n# Yes\n# >>> check_Triangle 1 1 1 4 1 5\n# No\nproc check_Triangle {x1 y1 x2 y2 x3 y3} {",
        "canonical_solution": "    set a [expr {$x1*($y2-$y3) + $x2*($y3-$y1) + $x3*($y1-$y2)}]\n    if {$a == 0} {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_Triangle 1 5 2 5 4 6] eq \"Yes\"}\nassert {[check_Triangle 1 1 1 4 1 5] eq \"No\"}\nassert {[check_Triangle 1 1 1 1 1 1] eq \"No\"}",
        "declaration": "proc check_Triangle {x1 y1 x2 y2 x3 y3} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_Triangle 1 5 2 5 4 6] eq \"Yes\"}",
        "prompt_text": "Given three points (x1,y1), (x2,y2), (x3,y3), check whether they form a valid triangle.",
        "prompt_explain": "Given three points (x1,y1), (x2,y2), (x3,y3), check whether they form a valid triangle.\n>>> check_Triangle 1 5 2 5 4 6\nYes\n>>> check_Triangle 1 1 1 4 1 5\nNo",
        "func_title": "proc check_Triangle {x1 y1 x2 y2 x3 y3}"
    },
    {
        "prompt": "# Write a function to check whether the given month number contains 31 days or not.\n# >>> check_monthnumb_number 5\n# 1\n# >>> check_monthnumb_number 2\n# 0\nproc check_monthnumb_number {monthnum2} {",
        "canonical_solution": "    if {$monthnum2 == 1 || $monthnum2 == 3 || $monthnum2 == 5 || $monthnum2 == 7 || $monthnum2 == 8 || $monthnum2 == 10 || $monthnum2 == 12} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_monthnumb_number 5] == 1}\nassert {[check_monthnumb_number 2] == 0}\nassert {[check_monthnumb_number 6] == 0}",
        "declaration": "proc check_monthnumb_number {monthnum2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_monthnumb_number 5] == 1}",
        "prompt_text": "Write a function to check whether the given month number contains 31 days or not.",
        "prompt_explain": "Write a function to check whether the given month number contains 31 days or not.\n>>> check_monthnumb_number 5\n1\n>>> check_monthnumb_number 2\n0",
        "func_title": "proc check_monthnumb_number {monthnum2}"
    },
    {
        "prompt": "# Write a function to find the area of a rectangle.\n# >>> rectangle_area 10 20\n# 200\nproc rectangle_area {l b} {",
        "canonical_solution": "    set area [expr {$l * $b}]\n    return $area\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[rectangle_area 10 20] == 200}\nassert {[rectangle_area 10 5] == 50}\nassert {[rectangle_area 4 2] == 8}",
        "declaration": "proc rectangle_area {l b} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[rectangle_area 10 20] == 200}",
        "prompt_text": "Write a function to find the area of a rectangle.",
        "prompt_explain": "Write a function to find the area of a rectangle.\n>>> rectangle_area 10 20\n200",
        "func_title": "proc rectangle_area {l b}"
    },
    {
        "prompt": "# Given a list of integers, find the maximum product of a contiguous subarray within the list.\n# >>> max_subarray_product {1 -2 -3 0 7 -8 -2}\n# 112\nproc max_subarray_product {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set max_ending_here 1\n    set min_ending_here 1\n    set max_so_far 0\n    set flag 0\n    for {set i 0} {$i < $n} {incr i} {\n        set current [lindex $arr $i]\n        if {$current > 0} {\n            set max_ending_here [expr {$max_ending_here * $current}]\n            set min_ending_here [expr {min($min_ending_here * $current, 1)}]\n            set flag 1\n        } elseif {$current == 0} {\n            set max_ending_here 1\n            set min_ending_here 1\n        } else {\n            set temp $max_ending_here\n            set max_ending_here [expr {max($min_ending_here * $current, 1)}]\n            set min_ending_here [expr {$temp * $current}]\n        }\n        if {$max_so_far < $max_ending_here} {\n            set max_so_far $max_ending_here\n        }\n    }\n    if {$flag == 0 && $max_so_far == 0} {\n        return 0\n    }\n    return $max_so_far\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_subarray_product {1 -2 -3 0 7 -8 -2}] == 112}\nassert {[max_subarray_product {6 -3 -10 0 2}] == 180}\nassert {[max_subarray_product {-2 -40 0 -2 -3}] == 80}",
        "declaration": "proc max_subarray_product {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_subarray_product {1 -2 -3 0 7 -8 -2}] == 112}",
        "prompt_text": "Given a list of integers, find the maximum product of a contiguous subarray within the list.",
        "prompt_explain": "Given a list of integers, find the maximum product of a contiguous subarray within the list.\n>>> max_subarray_product {1 -2 -3 0 7 -8 -2}\n112",
        "func_title": "proc max_subarray_product {arr}"
    },
    {
        "prompt": "# Given a list of integers, find the peak element in the list. A peak element is an element that is greater than or equal to its neighbors.\n# >>> find_peak {1 3 20 4 1 0}\n# 2\nproc find_peak {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    proc find_peak_util {arr low high n} {\n        set mid [expr {$low + ($high - $low) / 2}]\n        set mid [expr {int($mid)}]\n        if {($mid == 0 || [lindex $arr [expr {$mid - 1}]] <= [lindex $arr $mid]) &&\n            ($mid == $n - 1 || [lindex $arr [expr {$mid + 1}]] <= [lindex $arr $mid])} {\n            return $mid\n        } elseif {$mid > 0 && [lindex $arr [expr {$mid - 1}]] > [lindex $arr $mid]} {\n            return [find_peak_util $arr $low [expr {$mid - 1}] $n]\n        } else {\n            return [find_peak_util $arr [expr {$mid + 1}] $high $n]\n        }\n    }\n    return [find_peak_util $arr 0 [expr {$n - 1}] $n]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_peak {1 3 20 4 1 0}] == 2}\nassert {[find_peak {2 3 4 5 6}] == 4}\nassert {[find_peak {8 9 11 12 14 15}] == 5}",
        "declaration": "proc find_peak {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_peak {1 3 20 4 1 0}] == 2}",
        "prompt_text": "Given a list of integers, find the peak element in the list. A peak element is an element that is greater than or equal to its neighbors.",
        "prompt_explain": "Given a list of integers, find the peak element in the list. A peak element is an element that is greater than or equal to its neighbors.\n>>> find_peak {1 3 20 4 1 0}\n2",
        "func_title": "proc find_peak {arr}"
    },
    {
        "prompt": "# Given a list of integers, find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\n# >>> max_product {3 100 4 5 150 6}\n# 45000\nproc max_product {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set mpis [list]\n    for {set i 0} {$i < $n} {incr i} {\n        lappend mpis [lindex $arr $i]\n    }\n    for {set i 1} {$i < $n} {incr i} {\n        for {set j 0} {$j < $i} {incr j} {\n            if {[lindex $arr $i] > [lindex $arr $j] && [lindex $mpis $i] < ([lindex $mpis $j] * [lindex $arr $i])} {\n                lset mpis $i [expr {[lindex $mpis $j] * [lindex $arr $i]}]\n            }\n        }\n    }\n    return [tcl::mathfunc::max {*}$mpis]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_product {3 100 4 5 150 6}] == 45000}\nassert {[max_product {4 42 55 68 80}] == 50265600}\nassert {[max_product {10 22 9 33 21 50 41 60}] == 21780000}",
        "declaration": "proc max_product {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_product {3 100 4 5 150 6}] == 45000}",
        "prompt_text": "Given a list of integers, find the maximum product formed by multiplying numbers of an increasing subsequence of that array.",
        "prompt_explain": "Given a list of integers, find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\n>>> max_product {3 100 4 5 150 6}\n45000",
        "func_title": "proc max_product {arr}"
    },
    {
        "prompt": "# Given a list of stock prices and a maximum number of transactions k, find the maximum profit that can be earned from at most k transactions.\n# >>> max_profit {1 5 2 3 7 6 4 5} 3\n# 10\nproc max_profit {price k} {",
        "canonical_solution": "    set n [llength $price]\n    set final_profit [list]\n    for {set i 0} {$i <= $k} {incr i} {\n        lappend final_profit [list]\n        for {set j 0} {$j < $n} {incr j} {\n            if {$i == 0 || $j == 0} {\n                lset final_profit $i $j 0\n            } else {\n                set max_so_far 0\n                for {set x 0} {$x < $j} {incr x} {\n                    set curr_price [expr {[lindex $price $j] - [lindex $price $x] + [lindex $final_profit [expr {$i - 1}] $x]}]\n                    if {$max_so_far < $curr_price} {\n                        set max_so_far $curr_price\n                    }\n                }\n                lset final_profit $i $j [expr {max([lindex $final_profit $i [expr {$j - 1}]], $max_so_far)}]\n            }\n        }\n    }\n    return [lindex $final_profit $k [expr {$n - 1}]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_profit {1 5 2 3 7 6 4 5} 3] == 10}\nassert {[max_profit {2 4 7 5 4 3 5} 2] == 7}\nassert {[max_profit {10 6 8 4 2} 2] == 2}",
        "declaration": "proc max_profit {price k} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_profit {1 5 2 3 7 6 4 5} 3] == 10}",
        "prompt_text": "Given a list of stock prices and a maximum number of transactions k, find the maximum profit that can be earned from at most k transactions.",
        "prompt_explain": "Given a list of stock prices and a maximum number of transactions k, find the maximum profit that can be earned from at most k transactions.\n>>> max_profit {1 5 2 3 7 6 4 5} 3\n10",
        "func_title": "proc max_profit {price k}"
    },
    {
        "prompt": "# Given a list of integers and a number n, return the remainder of the multiplication of all elements in the list divided by n.\n# >>> find_remainder {100 10 5 25 35 14} 11\n# 9\nproc find_remainder {arr n} {",
        "canonical_solution": "    set mul 1\n    foreach num $arr {\n        set mul [expr {($mul * ($num % $n)) % $n}]\n    }\n    return [expr {$mul % $n}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_remainder {100 10 5 25 35 14} 11] == 9}\nassert {[find_remainder {1 1 1} 1] == 0}\nassert {[find_remainder {1 2 1} 2] == 0}",
        "declaration": "proc find_remainder {arr n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_remainder {100 10 5 25 35 14} 11] == 9}",
        "prompt_text": "Given a list of integers and a number n, return the remainder of the multiplication of all elements in the list divided by n.",
        "prompt_explain": "Given a list of integers and a number n, return the remainder of the multiplication of all elements in the list divided by n.\n>>> find_remainder {100 10 5 25 35 14} 11\n9",
        "func_title": "proc find_remainder {arr n}"
    },
    {
        "prompt": "# Given a list of integers, check whether the list contains consecutive numbers or not.\n# >>> check_Consecutive {1 2 3 4 5}\n# 1\n# >>> check_Consecutive {1 2 3 5 6}\n# 0\nproc check_Consecutive {l} {",
        "canonical_solution": "    set sorted [lsort -integer $l]\n    set min [lindex $sorted 0]\n    set max [lindex $sorted end]\n    if {[llength $sorted] != [expr {$max - $min + 1}]} {\n        return 0\n    }\n    for {set i 1} {$i < [llength $sorted]} {incr i} {\n        if {[lindex $sorted $i] != [expr {[lindex $sorted [expr {$i - 1}]] + 1}]} {\n            return 0\n        }\n    }\n    return 1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_Consecutive {1 2 3 4 5}] == 1}\nassert {[check_Consecutive {1 2 3 5 6}] == 0}\nassert {[check_Consecutive {1 2 1}] == 0}",
        "declaration": "proc check_Consecutive {l} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_Consecutive {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, check whether the list contains consecutive numbers or not.",
        "prompt_explain": "Given a list of integers, check whether the list contains consecutive numbers or not.\n>>> check_Consecutive {1 2 3 4 5}\n1\n>>> check_Consecutive {1 2 3 5 6}\n0",
        "func_title": "proc check_Consecutive {l}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of the largest and smallest value in the list.\n# >>> big_sum {1 2 3}\n# 4\nproc big_sum {nums} {",
        "canonical_solution": "    set max_num [lindex $nums 0]\n    set min_num [lindex $nums 0]\n    foreach num $nums {\n        if {$num > $max_num} {\n            set max_num $num\n        }\n        if {$num < $min_num} {\n            set min_num $num\n        }\n    }\n    return [expr {$max_num + $min_num}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[big_sum {1 2 3}] == 4}\nassert {[big_sum {-1 2 3 4}] == 3}\nassert {[big_sum {2 3 6}] == 8}",
        "declaration": "proc big_sum {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[big_sum {1 2 3}] == 4}",
        "prompt_text": "Given a list of integers, return the sum of the largest and smallest value in the list.",
        "prompt_explain": "Given a list of integers, return the sum of the largest and smallest value in the list.\n>>> big_sum {1 2 3}\n4",
        "func_title": "proc big_sum {nums}"
    },
    {
        "prompt": "# Write a Tcl function to find the first digit of a given number.\n# >>> first_Digit 123\n# 1\nproc first_Digit {n} {",
        "canonical_solution": "    while {$n >= 10} {\n        set n [expr {$n / 10}]\n    }\n    return [expr {int($n)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[first_Digit 123] == 1}\nassert {[first_Digit 456] == 4}\nassert {[first_Digit 12] == 1}",
        "declaration": "proc first_Digit {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[first_Digit 123] == 1}",
        "prompt_text": "Write a Tcl function to find the first digit of a given number.",
        "prompt_explain": "Write a Tcl function to find the first digit of a given number.\n>>> first_Digit 123\n1",
        "func_title": "proc first_Digit {n}"
    },
    {
        "prompt": "# Given a string, find sequences of one upper case letter followed by lower case letters by using regex.\n# >>> match \"Geeks\"\n# Yes\n# >>> match \"geeksforGeeks\"\n# Yes\n# >>> match \"geeks\"\n# No\nproc match {text} {",
        "canonical_solution": "    if {[regexp {^[A-Z][a-z]+$} $text]} {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[match \"Geeks\"] eq \"Yes\"}\nassert {[match \"geeksforGeeks\"] eq \"Yes\"}\nassert {[match \"geeks\"] eq \"No\"}",
        "declaration": "proc match {text} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[match \"Geeks\"] eq \"Yes\"}",
        "prompt_text": "Given a string, find sequences of one upper case letter followed by lower case letters by using regex.",
        "prompt_explain": "Given a string, find sequences of one upper case letter followed by lower case letters by using regex.\n>>> match \"Geeks\"\nYes\n>>> match \"geeksforGeeks\"\nYes\n>>> match \"geeks\"\nNo",
        "func_title": "proc match {text}"
    },
    {
        "prompt": "# Write a Tcl function to find the first natural number whose factorial is divisible by x.\n# >>> first_Factorial_Divisible_Number 10\n# 5\nproc first_Factorial_Divisible_Number {x} {",
        "canonical_solution": "    set i 1\n    set fact 1\n    while {1} {\n        set fact [expr {$fact * $i}]\n        if {[expr {$fact % $x}] == 0} {\n            break\n        }\n        incr i\n    }\n    return $i\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[first_Factorial_Divisible_Number 10] == 5}\nassert {[first_Factorial_Divisible_Number 15] == 5}\nassert {[first_Factorial_Divisible_Number 5] == 4}",
        "declaration": "proc first_Factorial_Divisible_Number {x} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[first_Factorial_Divisible_Number 10] == 5}",
        "prompt_text": "Write a Tcl function to find the first natural number whose factorial is divisible by x.",
        "prompt_explain": "Write a Tcl function to find the first natural number whose factorial is divisible by x.\n>>> first_Factorial_Divisible_Number 10\n5",
        "func_title": "proc first_Factorial_Divisible_Number {x}"
    },
    {
        "prompt": "# Given two lists of tuples, return a new list with tuples from the first list that are not in the second list.\n# >>> remove_matching_tuple {{Hello dude} {How are} {you ?}} {{Hello dude} {How are}}\n# {{you ?}}\nproc remove_matching_tuple {test_list1 test_list2} {",
        "canonical_solution": "    set res {}\n    foreach sub $test_list1 {\n        if {$sub ni $test_list2} {\n            lappend res $sub\n        }\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[remove_matching_tuple {{Hello dude} {How are} {you ?}} {{Hello dude} {How are}}] eq {{you ?}}}\nassert {[remove_matching_tuple {{Part of} {the journey} {is end}} {{Journey the} {is end}}] eq {{Part of} {the journey} {is end}}}\nassert {[remove_matching_tuple {{Its been} {a long} {day without}} {{a long} {my friend}}] eq {{Its been} {day without}}}",
        "declaration": "proc remove_matching_tuple {test_list1 test_list2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[remove_matching_tuple {{Hello dude} {How are} {you ?}} {{Hello dude} {How are}}] eq {{you ?}}}",
        "prompt_text": "Given two lists of tuples, return a new list with tuples from the first list that are not in the second list.",
        "prompt_explain": "Given two lists of tuples, return a new list with tuples from the first list that are not in the second list.\n>>> remove_matching_tuple {{Hello dude} {How are} {you ?}} {{Hello dude} {How are}}\n{{you ?}}",
        "func_title": "proc remove_matching_tuple {test_list1 test_list2}"
    },
    {
        "prompt": "# Given a list of integers, find the largest palindromic number in the list.\n# >>> largest_palindrome {1 232 54545 999991}\n# 54545\nproc largest_palindrome {numbers} {",
        "canonical_solution": "    proc is_palindrome {n} {\n        set str [string trimleft $n 0]\n        return [expr {$str eq [string reverse $str]}]\n    }\n    set max_palindrome -1\n    foreach number $numbers {\n        if {[is_palindrome $number] && $number > $max_palindrome} {\n            set max_palindrome $number\n        }\n    }\n    return $max_palindrome\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[largest_palindrome {1 232 54545 999991}] == 54545}\nassert {[largest_palindrome {1 2 3 4 5 50}] == 5}\nassert {[largest_palindrome {1 3 7 9 45}] == 9}",
        "declaration": "proc largest_palindrome {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[largest_palindrome {1 232 54545 999991}] == 54545}",
        "prompt_text": "Given a list of integers, find the largest palindromic number in the list.",
        "prompt_explain": "Given a list of integers, find the largest palindromic number in the list.\n>>> largest_palindrome {1 232 54545 999991}\n54545",
        "func_title": "proc largest_palindrome {numbers}"
    },
    {
        "prompt": "# Write a function to find the area of a pentagon.\n# >>> area_pentagon 5\n# 43.01193501472417\nproc area_pentagon {a} {",
        "canonical_solution": "    set area [expr {(sqrt(5 * (5 + 2 * sqrt(5))) * pow($a, 2)) / 4.0}]\n    return $area\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[area_pentagon 5] == 43.01193501472417}\nassert {[area_pentagon 10] == 172.0477400588967}\nassert {[area_pentagon 15] == 387.10741513251753}",
        "declaration": "proc area_pentagon {a} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[area_pentagon 5] == 43.01193501472417}",
        "prompt_text": "Write a function to find the area of a pentagon.",
        "prompt_explain": "Write a function to find the area of a pentagon.\n>>> area_pentagon 5\n43.01193501472417",
        "func_title": "proc area_pentagon {a}"
    },
    {
        "prompt": "# Write a function to find the surface area of a cone.\n# >>> surfacearea_cone 5 12\n# 282.7433388230814\nproc surfacearea_cone {r h} {",
        "canonical_solution": "    set l [expr {sqrt($r * $r + $h * $h)}]\n    set SA [expr {3.141592653589793 * $r * ($r + $l)}]\n    return $SA\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surfacearea_cone 5 12] == 282.7433388230814}\nassert {[surfacearea_cone 10 15] == 880.5179353159282}\nassert {[surfacearea_cone 19 17] == 2655.923961165254}",
        "declaration": "proc surfacearea_cone {r h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surfacearea_cone 5 12] == 282.7433388230814}",
        "prompt_text": "Write a function to find the surface area of a cone.",
        "prompt_explain": "Write a function to find the surface area of a cone.\n>>> surfacearea_cone 5 12\n282.7433388230814",
        "func_title": "proc surfacearea_cone {r h}"
    },
    {
        "prompt": "# Write a Tcl function to find the greatest common divisor (gcd) of two positive integers.\n# >>> gcd 12 17\n# 1\nproc gcd {x y} {",
        "canonical_solution": "    if {$y == 0} {\n        return $x\n    } else {\n        return [gcd $y [expr {$x % $y}]]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[gcd 12 17] == 1}\nassert {[gcd 4 6] == 2}\nassert {[gcd 2 9] == 1}",
        "declaration": "proc gcd {x y} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[gcd 12 17] == 1}",
        "prompt_text": "Write a Tcl function to find the greatest common divisor (gcd) of two positive integers.",
        "prompt_explain": "Write a Tcl function to find the greatest common divisor (gcd) of two positive integers.\n>>> gcd 12 17\n1",
        "func_title": "proc gcd {x y}"
    },
    {
        "prompt": "# Write a function to find the diameter of a circle.\n# >>> diameter_circle 10\n# 20\nproc diameter_circle {r} {",
        "canonical_solution": "    set diameter [expr {2 * $r}]\n    return $diameter\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[diameter_circle 10] == 20}\nassert {[diameter_circle 40] == 80}\nassert {[diameter_circle 15] == 30}",
        "declaration": "proc diameter_circle {r} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[diameter_circle 10] == 20}",
        "prompt_text": "Write a function to find the diameter of a circle.",
        "prompt_explain": "Write a function to find the diameter of a circle.\n>>> diameter_circle 10\n20",
        "func_title": "proc diameter_circle {r}"
    },
    {
        "prompt": "# Given two numbers, find the number of common divisors between them.\n# >>> num_comm_div 2 4\n# 2\nproc num_comm_div {x y} {",
        "canonical_solution": "    proc ngcd {x y} {\n        set i 1\n        while {$i <= $x && $i <= $y} {\n            if {$x % $i == 0 && $y % $i == 0} {\n                set gcd $i\n            }\n            incr i\n        }\n        return $gcd\n    }\n    set n [ngcd $x $y]\n    set result 0\n    set z [expr {int(sqrt($n))}]\n    set i 1\n    while {$i <= $z} {\n        if {$n % $i == 0} {\n            incr result 2\n            if {$i == $n / $i} {\n                incr result -1\n            }\n        }\n        incr i\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[num_comm_div 2 4] == 2}\nassert {[num_comm_div 2 8] == 2}\nassert {[num_comm_div 12 24] == 6}",
        "declaration": "proc num_comm_div {x y} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[num_comm_div 2 4] == 2}",
        "prompt_text": "Given two numbers, find the number of common divisors between them.",
        "prompt_explain": "Given two numbers, find the number of common divisors between them.\n>>> num_comm_div 2 4\n2",
        "func_title": "proc num_comm_div {x y}"
    },
    {
        "prompt": "# Write a Tcl function to find the remainder of two numbers.\n# >>> find 3 3\n# 0\nproc find {n m} {",
        "canonical_solution": "    set r [expr {$n % $m}]\n    return $r\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find 3 3] == 0}\nassert {[find 10 3] == 1}\nassert {[find 16 5] == 1}",
        "declaration": "proc find {n m} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find 3 3] == 0}",
        "prompt_text": "Write a Tcl function to find the remainder of two numbers.",
        "prompt_explain": "Write a Tcl function to find the remainder of two numbers.\n>>> find 3 3\n0",
        "func_title": "proc find {n m}"
    },
    {
        "prompt": "# Write a Tcl function to find the cube sum of first n natural numbers.\n# >>> sum_Of_Series 5\n# 225\nproc sum_Of_Series {n} {",
        "canonical_solution": "    set sum 0\n    for {set i 1} {$i <= $n} {incr i} {\n        set sum [expr {$sum + $i * $i * $i}]\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_Of_Series 5] == 225}\nassert {[sum_Of_Series 2] == 9}\nassert {[sum_Of_Series 3] == 36}",
        "declaration": "proc sum_Of_Series {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_Of_Series 5] == 225}",
        "prompt_text": "Write a Tcl function to find the cube sum of first n natural numbers.",
        "prompt_explain": "Write a Tcl function to find the cube sum of first n natural numbers.\n>>> sum_Of_Series 5\n225",
        "func_title": "proc sum_Of_Series {n}"
    },
    {
        "prompt": "# Write a function to check if the common elements between two given lists are in the same order or not.\n# >>> same_order {red green black orange} {red pink green white black}\n# 1\nproc same_order {l1 l2} {",
        "canonical_solution": "    set common_elements [lsort -unique [concat $l1 $l2]]\n    set l1_common [lsearch -all -inline $l1 $common_elements]\n    set l2_common [lsearch -all -inline $l2 $common_elements]\n    return [expr {$l1_common == $l2_common}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[same_order {red green black orange} {red pink green white black}] == 1}\nassert {[same_order {red pink green white black} {white orange pink black}] == 0}\nassert {[same_order {red green black orange} {red pink green white black}] == 1}",
        "declaration": "proc same_order {l1 l2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[same_order {red green black orange} {red pink green white black}] == 1}",
        "prompt_text": "Write a function to check if the common elements between two given lists are in the same order or not.",
        "prompt_explain": "Write a function to check if the common elements between two given lists are in the same order or not.\n>>> same_order {red green black orange} {red pink green white black}\n1",
        "func_title": "proc same_order {l1 l2}"
    },
    {
        "prompt": "# Write a Tcl function to find the average of odd numbers till a given odd number.\n# >>> average_Odd 9\n# 5\nproc average_Odd {n} {",
        "canonical_solution": "    if {$n % 2 == 0} {\n        return \"Invalid Input\"\n    }\n    set sm 0\n    set count 0\n    while {$n >= 1} {\n        incr count\n        incr sm $n\n        incr n -2\n    }\n    return [expr {$sm / $count}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average_Odd 9] == 5}\nassert {[average_Odd 5] == 3}\nassert {[average_Odd 11] == 6}",
        "declaration": "proc average_Odd {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average_Odd 9] == 5}",
        "prompt_text": "Write a Tcl function to find the average of odd numbers till a given odd number.",
        "prompt_explain": "Write a Tcl function to find the average of odd numbers till a given odd number.\n>>> average_Odd 9\n5",
        "func_title": "proc average_Odd {n}"
    },
    {
        "prompt": "# Write a Tcl function to find the minimum sum of factors of a given number.\n# >>> find_Min_Sum 12\n# 7\nproc find_Min_Sum {num} {",
        "canonical_solution": "    set sum 0\n    set i 2\n    while {$i * $i <= $num} {\n        while {$num % $i == 0} {\n            set sum [expr {$sum + $i}]\n            set num [expr {$num / $i}]\n        }\n        set i [expr {$i + 1}]\n    }\n    set sum [expr {$sum + $num}]\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Min_Sum 12] == 7}\nassert {[find_Min_Sum 105] == 15}\nassert {[find_Min_Sum 2] == 2}",
        "declaration": "proc find_Min_Sum {num} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Min_Sum 12] == 7}",
        "prompt_text": "Write a Tcl function to find the minimum sum of factors of a given number.",
        "prompt_explain": "Write a Tcl function to find the minimum sum of factors of a given number.\n>>> find_Min_Sum 12\n7",
        "func_title": "proc find_Min_Sum {num}"
    },
    {
        "prompt": "# Given a list of integers and a number m, check if there is a subset with sum divisible by m.\n# >>> modular_sum {3 1 7 5} 4 6\n# True\nproc modular_sum {arr n m} {",
        "canonical_solution": "    if {$n > $m} {\n        return True\n    }\n    set DP [list]\n    for {set i 0} {$i < $m} {incr i} {\n        lappend DP False\n    }\n    for {set i 0} {$i < $n} {incr i} {\n        if {[lindex $DP 0]} {\n            return True\n        }\n        set temp [list]\n        for {set j 0} {$j < $m} {incr j} {\n            lappend temp False\n        }\n        for {set j 0} {$j < $m} {incr j} {\n            if {[lindex $DP $j]} {\n                if {![lindex $DP [expr {($j + [lindex $arr $i]) % $m}]]} {\n                    lset temp [expr {($j + [lindex $arr $i]) % $m}] True\n                }\n            }\n        }\n        for {set j 0} {$j < $m} {incr j} {\n            if {[lindex $temp $j]} {\n                lset DP $j True\n            }\n        }\n        lset DP [expr {[lindex $arr $i] % $m}] True\n    }\n    return [lindex $DP 0]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[modular_sum {3 1 7 5} 4 6] == True}\nassert {[modular_sum {1 7} 2 5] == False}\nassert {[modular_sum {1 6} 2 5] == False}",
        "declaration": "proc modular_sum {arr n m} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[modular_sum {3 1 7 5} 4 6] == True}",
        "prompt_text": "Given a list of integers and a number m, check if there is a subset with sum divisible by m.",
        "prompt_explain": "Given a list of integers and a number m, check if there is a subset with sum divisible by m.\n>>> modular_sum {3 1 7 5} 4 6\nTrue",
        "func_title": "proc modular_sum {arr n m}"
    },
    {
        "prompt": "# Given a list of integers, return the largest positive number from the list.\n# >>> largest_pos {1 2 3 4 -1}\n# 4\nproc largest_pos {list1} {",
        "canonical_solution": "    set max [lindex $list1 0]\n    foreach x $list1 {\n        if {$x > $max} {\n            set max $x\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[largest_pos {1 2 3 4 -1}] == 4}\nassert {[largest_pos {0 1 2 -5 -1 6}] == 6}\nassert {[largest_pos {0 0 1 0}] == 1}",
        "declaration": "proc largest_pos {list1} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[largest_pos {1 2 3 4 -1}] == 4}",
        "prompt_text": "Given a list of integers, return the largest positive number from the list.",
        "prompt_explain": "Given a list of integers, return the largest positive number from the list.\n>>> largest_pos {1 2 3 4 -1}\n4",
        "func_title": "proc largest_pos {list1}"
    },
    {
        "prompt": "# Write a function to calculate the volume of a tetrahedron.\n# >>> volume_tetrahedron 10\n# 117.85\nproc volume_tetrahedron {num} {",
        "canonical_solution": "    set volume [expr {pow($num, 3) / (6 * sqrt(2))}]\n    return [format \"%.2f\" $volume]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_tetrahedron 10] == 117.85}\nassert {[volume_tetrahedron 15] == 397.75}\nassert {[volume_tetrahedron 20] == 942.81}",
        "declaration": "proc volume_tetrahedron {num} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_tetrahedron 10] == 117.85}",
        "prompt_text": "Write a function to calculate the volume of a tetrahedron.",
        "prompt_explain": "Write a function to calculate the volume of a tetrahedron.\n>>> volume_tetrahedron 10\n117.85",
        "func_title": "proc volume_tetrahedron {num}"
    },
    {
        "prompt": "# Write a function to check if the triangle is scalene or not.\n# A scalene triangle is a triangle that has three unequal sides.\n# >>> check_scalene 6 8 12\n# 1\n# >>> check_scalene 6 6 12\n# 0\nproc check_scalene {x y z} {",
        "canonical_solution": "    if {$x != $y && $y != $z && $z != $x} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_scalene 6 8 12] == 1}\nassert {[check_scalene 6 6 12] == 0}\nassert {[check_scalene 6 15 20] == 1}",
        "declaration": "proc check_scalene {x y z} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_scalene 6 8 12] == 1}",
        "prompt_text": "Write a function to check if the triangle is scalene or not. A scalene triangle is a triangle that has three unequal sides.",
        "prompt_explain": "Write a function to check if the triangle is scalene or not. A scalene triangle is a triangle that has three unequal sides.\n>>> check_scalene 6 8 12\n1\n>>> check_scalene 6 6 12\n0",
        "func_title": "proc check_scalene {x y z}"
    },
    {
        "prompt": "# Given an array of integers, find the sum of the maximum increasing subsequence.\n# >>> max_sum_increasing_subsequence {1 101 2 3 100 4 5}\n# 106\nproc max_sum_increasing_subsequence {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set max 0\n    set msis [lrepeat $n 0]\n    for {set i 0} {$i < $n} {incr i} {\n        lset msis $i [lindex $arr $i]\n    }\n    for {set i 1} {$i < $n} {incr i} {\n        for {set j 0} {$j < $i} {incr j} {\n            if {[lindex $arr $i] > [lindex $arr $j] && [lindex $msis $i] < [expr {[lindex $msis $j] + [lindex $arr $i]}]} {\n                lset msis $i [expr {[lindex $msis $j] + [lindex $arr $i]}]\n            }\n        }\n    }\n    for {set i 0} {$i < $n} {incr i} {\n        if {$max < [lindex $msis $i]} {\n            set max [lindex $msis $i]\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sum_increasing_subsequence {1 101 2 3 100 4 5}] == 106}\nassert {[max_sum_increasing_subsequence {3 4 5 10}] == 22}\nassert {[max_sum_increasing_subsequence {10 5 4 3}] == 10}",
        "declaration": "proc max_sum_increasing_subsequence {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sum_increasing_subsequence {1 101 2 3 100 4 5}] == 106}",
        "prompt_text": "Given an array of integers, find the sum of the maximum increasing subsequence.",
        "prompt_explain": "Given an array of integers, find the sum of the maximum increasing subsequence.\n>>> max_sum_increasing_subsequence {1 101 2 3 100 4 5}\n106",
        "func_title": "proc max_sum_increasing_subsequence {arr}"
    },
    {
        "prompt": "# Given two lines represented by their coefficients (a1, b1, c1) and (a2, b2, c2), check if they are parallel.\n# >>> parallel_lines {2 3 4} {2 3 8}\n# 1\nproc parallel_lines {line1 line2} {",
        "canonical_solution": "    set a1 [lindex $line1 0]\n    set b1 [lindex $line1 1]\n    set a2 [lindex $line2 0]\n    set b2 [lindex $line2 1]\n    if {$a1 * $b2 == $a2 * $b1} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[parallel_lines {2 3 4} {2 3 8}] == 1}\nassert {[parallel_lines {2 3 4} {4 -3 8}] == 0}\nassert {[parallel_lines {3 3} {5 5}] == 1}",
        "declaration": "proc parallel_lines {line1 line2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[parallel_lines {2 3 4} {2 3 8}] == 1}",
        "prompt_text": "Given two lines represented by their coefficients (a1, b1, c1) and (a2, b2, c2), check if they are parallel.",
        "prompt_explain": "Given two lines represented by their coefficients (a1, b1, c1) and (a2, b2, c2), check if they are parallel.\n>>> parallel_lines {2 3 4} {2 3 8}\n1",
        "func_title": "proc parallel_lines {line1 line2}"
    },
    {
        "prompt": "# Given a list of integers and a target sum, find all pairs in the list whose sum is equal to the target sum.\n# >>> get_pairs_count {1 5 7 -1 5} 6\n# 3\nproc get_pairs_count {arr sum} {",
        "canonical_solution": "    set count 0\n    set n [llength $arr]\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $n} {incr j} {\n            if {[expr {[lindex $arr $i] + [lindex $arr $j]}] == $sum} {\n                incr count\n            }\n        }\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_pairs_count {1 5 7 -1 5} 6] == 3}\nassert {[get_pairs_count {1 5 7 -1} 6] == 2}\nassert {[get_pairs_count {1 1 1 1} 2] == 6}",
        "declaration": "proc get_pairs_count {arr sum} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_pairs_count {1 5 7 -1 5} 6] == 3}",
        "prompt_text": "Given a list of integers and a target sum, find all pairs in the list whose sum is equal to the target sum.",
        "prompt_explain": "Given a list of integers and a target sum, find all pairs in the list whose sum is equal to the target sum.\n>>> get_pairs_count {1 5 7 -1 5} 6\n3",
        "func_title": "proc get_pairs_count {arr sum}"
    },
    {
        "prompt": "# Write a function to find the nth Jacobsthal-Lucas number.\n# >>> jacobsthal_lucas 5\n# 31\nproc jacobsthal_lucas {n} {",
        "canonical_solution": "    if {$n == 0} { return 2 }\n    if {$n == 1} { return 1 }\n    set dp [list 2 1]\n    for {set i 2} {$i <= $n} {incr i} {\n        lappend dp [expr {[lindex $dp [expr {$i - 1}]] + 2 * [lindex $dp [expr {$i - 2}]]}]\n    }\n    return [lindex $dp $n]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[jacobsthal_lucas 5] == 31}\nassert {[jacobsthal_lucas 2] == 5}\nassert {[jacobsthal_lucas 4] == 17}",
        "declaration": "proc jacobsthal_lucas {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[jacobsthal_lucas 5] == 31}",
        "prompt_text": "Write a function to find the nth Jacobsthal-Lucas number.",
        "prompt_explain": "Write a function to find the nth Jacobsthal-Lucas number.\n>>> jacobsthal_lucas 5\n31",
        "func_title": "proc jacobsthal_lucas {n}"
    },
    {
        "prompt": "# Given a list of integers, return the ratio of negative numbers in the list.\n# >>> negative_count {0 1 2 -1 -5 6 0 -3 -2 3 4 6 8}\n# 0.31\nproc negative_count {nums} {",
        "canonical_solution": "    set n [llength $nums]\n    set n1 0\n    foreach x $nums {\n        if {$x < 0} {\n            incr n1\n        }\n    }\n    return [expr {round(double($n1)/$n*100)/100.0}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[negative_count {0 1 2 -1 -5 6 0 -3 -2 3 4 6 8}] == 0.31}\nassert {[negative_count {2 1 2 -1 -5 6 4 -3 -2 3 4 6 8}] == 0.31}\nassert {[negative_count {2 4 -6 -9 11 -12 14 -5 17}] == 0.44}",
        "declaration": "proc negative_count {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[negative_count {0 1 2 -1 -5 6 0 -3 -2 3 4 6 8}] == 0.31}",
        "prompt_text": "Given a list of integers, return the ratio of negative numbers in the list.",
        "prompt_explain": "Given a list of integers, return the ratio of negative numbers in the list.\n>>> negative_count {0 1 2 -1 -5 6 0 -3 -2 3 4 6 8}\n0.31",
        "func_title": "proc negative_count {nums}"
    },
    {
        "prompt": "# Given a list of coin denominations and a value, return the minimum number of coins needed to make that value.\n# >>> min_coins {9 6 5 1} 11\n# 2\nproc min_coins {coins V} {",
        "canonical_solution": "    set m [llength $coins]\n    if {$V == 0} {\n        return 0\n    }\n    set res 2147483647\n    for {set i 0} {$i < $m} {incr i} {\n        if {[lindex $coins $i] <= $V} {\n            set sub_res [min_coins $coins [expr {$V - [lindex $coins $i]}]]\n            if {$sub_res != 2147483647 && [expr {$sub_res + 1}] < $res} {\n                set res [expr {$sub_res + 1}]\n            }\n        }\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_coins {9 6 5 1} 11] == 2}\nassert {[min_coins {4 5 6 7 8 9} 9] == 1}\nassert {[min_coins {1 2 3} 4] == 2}",
        "declaration": "proc min_coins {coins V} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_coins {9 6 5 1} 11] == 2}",
        "prompt_text": "Given a list of coin denominations and a value, return the minimum number of coins needed to make that value.",
        "prompt_explain": "Given a list of coin denominations and a value, return the minimum number of coins needed to make that value.\n>>> min_coins {9 6 5 1} 11\n2",
        "func_title": "proc min_coins {coins V}",
        "test_setup_code": "",
        "test_list": [
            "assert {[min_coins {9 6 5 1} 11] == 2}",
            "assert {[min_coins {4 5 6 7 8 9} 9] == 1}",
            "assert {[min_coins {1 2 3} 4] == 2}"
        ],
        "challenge_test_list": []
    },
    {
        "prompt": "# Write a function to check if the two given strings are permutations of each other.\n# >>> check_permutation \"abc\" \"cba\"\n# 1\n# >>> check_permutation \"test\" \"ttew\"\n# 0\nproc check_permutation {str1 str2} {",
        "canonical_solution": "    set n1 [string length $str1]\n    set n2 [string length $str2]\n    if {$n1 != $n2} {\n        return 0\n    }\n    set a [lsort [split $str1 \"\"]]\n    set str1 [join $a \"\"]\n    set b [lsort [split $str2 \"\"]]\n    set str2 [join $b \"\"]\n    for {set i 0} {$i < $n1} {incr i} {\n        if {[string index $str1 $i] != [string index $str2 $i]} {\n            return 0\n        }\n    }\n    return 1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_permutation \"abc\" \"cba\"] == 1}\nassert {[check_permutation \"test\" \"ttew\"] == 0}\nassert {[check_permutation \"xxyz\" \"yxzx\"] == 1}",
        "declaration": "proc check_permutation {str1 str2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_permutation \"abc\" \"cba\"] == 1}",
        "prompt_text": "Write a function to check if the two given strings are permutations of each other.",
        "prompt_explain": "Write a function to check if the two given strings are permutations of each other.\n>>> check_permutation \"abc\" \"cba\"\n1\n>>> check_permutation \"test\" \"ttew\"\n0",
        "func_title": "proc check_permutation {str1 str2}"
    },
    {
        "prompt": "# Given a list of integers, write a Tcl function to find the difference between the highest and least frequencies in the list.\n# >>> find_Diff {1 1 2 2 7 8 4 5 1 4}\n# 2\nproc find_Diff {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set arr [lsort -integer $arr]\n    set count 0\n    set max_count 0\n    set min_count $n\n    for {set i 0} {$i < [expr {$n - 1}]} {incr i} {\n        if {[lindex $arr $i] == [lindex $arr [expr {$i + 1}]]} {\n            incr count\n            continue\n        } else {\n            set max_count [expr {max($max_count, $count)}]\n            set min_count [expr {min($min_count, $count)}]\n            set count 0\n        }\n    }\n    return [expr {$max_count - $min_count}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Diff {1 1 2 2 7 8 4 5 1 4}] == 2}\nassert {[find_Diff {1 7 9 2 3 3 1 3 3}] == 3}\nassert {[find_Diff {1 2 1 2}] == 0}",
        "declaration": "proc find_Diff {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Diff {1 1 2 2 7 8 4 5 1 4}] == 2}",
        "prompt_text": "Given a list of integers, write a Tcl function to find the difference between the highest and least frequencies in the list.",
        "prompt_explain": "Given a list of integers, write a Tcl function to find the difference between the highest and least frequencies in the list.\n>>> find_Diff {1 1 2 2 7 8 4 5 1 4}\n2",
        "func_title": "proc find_Diff {arr}"
    },
    {
        "prompt": "# Given a list of integers, find the length of the longest increasing subsequence.\n# >>> longest_increasing_subsequence {10 22 9 33 21 50 41 60}\n# 5\nproc longest_increasing_subsequence {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set lis [lrepeat $n 1]\n    for {set i 1} {$i < $n} {incr i} {\n        for {set j 0} {$j < $i} {incr j} {\n            if {[lindex $arr $i] > [lindex $arr $j] && [lindex $lis $i] < [expr {[lindex $lis $j] + 1}]} {\n                lset lis $i [expr {[lindex $lis $j] + 1}]\n            }\n        }\n    }\n    set maximum 0\n    for {set i 0} {$i < $n} {incr i} {\n        if {[lindex $lis $i] > $maximum} {\n            set maximum [lindex $lis $i]\n        }\n    }\n    return $maximum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[longest_increasing_subsequence {10 22 9 33 21 50 41 60}] == 5}\nassert {[longest_increasing_subsequence {3 10 2 1 20}] == 3}\nassert {[longest_increasing_subsequence {50 3 10 7 40 80}] == 4}",
        "declaration": "proc longest_increasing_subsequence {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[longest_increasing_subsequence {10 22 9 33 21 50 41 60}] == 5}",
        "prompt_text": "Given a list of integers, find the length of the longest increasing subsequence.",
        "prompt_explain": "Given a list of integers, find the length of the longest increasing subsequence.\n>>> longest_increasing_subsequence {10 22 9 33 21 50 41 60}\n5",
        "func_title": "proc longest_increasing_subsequence {arr}"
    },
    {
        "prompt": "# Write a Tcl function to find the sum of fifth power of first n odd natural numbers.\n# >>> odd_Num_Sum 1\n# 1\n# >>> odd_Num_Sum 2\n# 244\n# >>> odd_Num_Sum 3\n# 3369\nproc odd_Num_Sum {n} {",
        "canonical_solution": "    set j 0\n    set sm 0\n    for {set i 1} {$i <= $n} {incr i} {\n        set j [expr {2*$i-1}]\n        set sm [expr {$sm + $j**5}]\n    }\n    return $sm\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[odd_Num_Sum 1] == 1}\nassert {[odd_Num_Sum 2] == 244}\nassert {[odd_Num_Sum 3] == 3369}",
        "declaration": "proc odd_Num_Sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[odd_Num_Sum 1] == 1}",
        "prompt_text": "Write a Tcl function to find the sum of fifth power of first n odd natural numbers.",
        "prompt_explain": "Write a Tcl function to find the sum of fifth power of first n odd natural numbers.\n>>> odd_Num_Sum 1\n1\n>>> odd_Num_Sum 2\n244\n>>> odd_Num_Sum 3\n3369",
        "func_title": "proc odd_Num_Sum {n}"
    },
    {
        "prompt": "# Write a Tcl function to find the difference between sum of cubes of first n natural numbers and the sum of first n natural numbers.\n# >>> difference 3\n# 30\nproc difference {n} {",
        "canonical_solution": "    set S [expr {($n * ($n + 1)) / 2}]\n    set res [expr {$S * ($S - 1)}]\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[difference 3] == 30}\nassert {[difference 5] == 210}\nassert {[difference 2] == 6}",
        "declaration": "proc difference {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[difference 3] == 30}",
        "prompt_text": "Write a Tcl function to find the difference between sum of cubes of first n natural numbers and the sum of first n natural numbers.",
        "prompt_explain": "Write a Tcl function to find the difference between sum of cubes of first n natural numbers and the sum of first n natural numbers.\n>>> difference 3\n30",
        "func_title": "proc difference {n}"
    },
    {
        "prompt": "# Given a list of integers, return the count of pairs whose XOR is an odd number.\n# >>> find_Odd_Pair {5 4 7 2 1}\n# 6\nproc find_Odd_Pair {A N} {",
        "canonical_solution": "    set oddPair 0\n    for {set i 0} {$i < $N} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $N} {incr j} {\n            if {([lindex $A $i] ^ [lindex $A $j]) % 2 != 0} {\n                incr oddPair\n            }\n        }\n    }\n    return $oddPair\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Odd_Pair {5 4 7 2 1} 5] == 6}\nassert {[find_Odd_Pair {7 2 8 1 0 5 11} 7] == 12}\nassert {[find_Odd_Pair {1 2 3} 3] == 2}",
        "declaration": "proc find_Odd_Pair {A N} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Odd_Pair {5 4 7 2 1} 5] == 6}",
        "prompt_text": "Given a list of integers, return the count of pairs whose XOR is an odd number.",
        "prompt_explain": "Given a list of integers, return the count of pairs whose XOR is an odd number.\n>>> find_Odd_Pair {5 4 7 2 1}\n6",
        "func_title": "proc find_Odd_Pair {A N}"
    },
    {
        "prompt": "# Write a Tcl function to find the digit distance between two integers.\n# >>> digit_distance_nums 1 2\n# 1\nproc digit_distance_nums {n1 n2} {",
        "canonical_solution": "    set diff [expr {abs($n1 - $n2)}]\n    set sum 0\n    foreach digit [split $diff {}] {\n        incr sum $digit\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[digit_distance_nums 1 2] == 1}\nassert {[digit_distance_nums 23 56] == 6}\nassert {[digit_distance_nums 123 256] == 7}",
        "declaration": "proc digit_distance_nums {n1 n2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[digit_distance_nums 1 2] == 1}",
        "prompt_text": "Write a Tcl function to find the digit distance between two integers.",
        "prompt_explain": "Write a Tcl function to find the digit distance between two integers.\n>>> digit_distance_nums 1 2\n1",
        "func_title": "proc digit_distance_nums {n1 n2}"
    },
    {
        "prompt": "# Given a list of integers, find the largest sum of contiguous subarray in the given array.\n# >>> max_sub_array_sum {-2 -3 4 -1 -2 1 5 -3}\n# 7\nproc max_sub_array_sum {a} {",
        "canonical_solution": "    set max_so_far 0\n    set max_ending_here 0\n    set size [llength $a]\n    for {set i 0} {$i < $size} {incr i} {\n        set max_ending_here [expr {$max_ending_here + [lindex $a $i]}]\n        if {$max_ending_here < 0} {\n            set max_ending_here 0\n        } elseif {$max_so_far < $max_ending_here} {\n            set max_so_far $max_ending_here\n        }\n    }\n    return $max_so_far\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sub_array_sum {-2 -3 4 -1 -2 1 5 -3}] == 7}\nassert {[max_sub_array_sum {-3 -4 5 -2 -3 2 6 -4}] == 8}\nassert {[max_sub_array_sum {-4 -5 6 -3 -4 3 7 -5}] == 10}",
        "declaration": "proc max_sub_array_sum {a} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sub_array_sum {-2 -3 4 -1 -2 1 5 -3}] == 7}",
        "prompt_text": "Given a list of integers, find the largest sum of contiguous subarray in the given array.",
        "prompt_explain": "Given a list of integers, find the largest sum of contiguous subarray in the given array.\n>>> max_sub_array_sum {-2 -3 4 -1 -2 1 5 -3}\n7",
        "func_title": "proc max_sub_array_sum {a}"
    },
    {
        "prompt": "# Given a list of lists, find the maximum length of sublist.\n# >>> Find_Max_Length {{1} {1 4} {5 6 7 8}}\n# 4\nproc Find_Max_Length {lst} {",
        "canonical_solution": "    set maxLength 0\n    foreach x $lst {\n        set currentLength [llength $x]\n        if {$currentLength > $maxLength} {\n            set maxLength $currentLength\n        }\n    }\n    return $maxLength\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Find_Max_Length {{1} {1 4} {5 6 7 8}}] == 4}\nassert {[Find_Max_Length {{0 1} {2 2} {3 2 1}}] == 3}\nassert {[Find_Max_Length {{7} {22 23} {13 14 15} {10 20 30 40 50}}] == 5}",
        "declaration": "proc Find_Max_Length {lst} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Find_Max_Length {{1} {1 4} {5 6 7 8}}] == 4}",
        "prompt_text": "Given a list of lists, find the maximum length of sublist.",
        "prompt_explain": "Given a list of lists, find the maximum length of sublist.\n>>> Find_Max_Length {{1} {1 4} {5 6 7 8}}\n4",
        "func_title": "proc Find_Max_Length {lst}"
    },
    {
        "prompt": "# Given a list of integers, count the number of unequal element pairs.\n# >>> count_Pairs {1 2 1}\n# 2\nproc count_Pairs {arr} {",
        "canonical_solution": "    set cnt 0\n    set n [llength $arr]\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $n} {incr j} {\n            if {[lindex $arr $i] != [lindex $arr $j]} {\n                incr cnt\n            }\n        }\n    }\n    return $cnt\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Pairs {1 2 1}] == 2}\nassert {[count_Pairs {1 1 1 1}] == 0}\nassert {[count_Pairs {1 2 3 4 5}] == 10}",
        "declaration": "proc count_Pairs {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Pairs {1 2 1}] == 2}",
        "prompt_text": "Given a list of integers, count the number of unequal element pairs.",
        "prompt_explain": "Given a list of integers, count the number of unequal element pairs.\n>>> count_Pairs {1 2 1}\n2",
        "func_title": "proc count_Pairs {arr}"
    },
    {
        "prompt": "# Write a function to get the sum of a non-negative integer.\n# >>> sum_digits 345\n# 12\nproc sum_digits {n} {",
        "canonical_solution": "    if {$n == 0} {\n        return 0\n    } else {\n        return [expr {$n % 10 + [sum_digits [expr {int($n / 10)}]]}]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_digits 345] == 12}\nassert {[sum_digits 12] == 3}\nassert {[sum_digits 97] == 16}",
        "declaration": "proc sum_digits {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_digits 345] == 12}",
        "prompt_text": "Write a function to get the sum of a non-negative integer.",
        "prompt_explain": "Write a function to get the sum of a non-negative integer.\n>>> sum_digits 345\n12",
        "func_title": "proc sum_digits {n}"
    },
    {
        "prompt": "# Given a list of integers, calculate the product of the unique numbers in the list.\n# >>> unique_product {10 20 30 40 20 50 60 40}\n# 720000000\nproc unique_product {list_data} {",
        "canonical_solution": "    set temp [lsort -unique $list_data]\n    set p 1\n    foreach i $temp {\n        set p [expr {$p * $i}]\n    }\n    return $p\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[unique_product {10 20 30 40 20 50 60 40}] == 720000000}\nassert {[unique_product {1 2 3 1}] == 6}\nassert {[unique_product {7 8 9 0 1 1}] == 0}",
        "declaration": "proc unique_product {list_data} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[unique_product {10 20 30 40 20 50 60 40}] == 720000000}",
        "prompt_text": "Given a list of integers, calculate the product of the unique numbers in the list.",
        "prompt_explain": "Given a list of integers, calculate the product of the unique numbers in the list.\n>>> unique_product {10 20 30 40 20 50 60 40}\n720000000",
        "func_title": "proc unique_product {list_data}"
    },
    {
        "prompt": "# Write a function to find the surface area of a cylinder.\n# >>> surfacearea_cylinder 10 5\n# 942.45\nproc surfacearea_cylinder {r h} {",
        "canonical_solution": "    set pi 3.1415\n    set surfacearea [expr {2 * $pi * $r * $r + 2 * $pi * $r * $h}]\n    return $surfacearea\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surfacearea_cylinder 10 5] == 942.45}\nassert {[surfacearea_cylinder 4 5] == 226.18800000000002}\nassert {[surfacearea_cylinder 4 10] == 351.848}",
        "declaration": "proc surfacearea_cylinder {r h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surfacearea_cylinder 10 5] == 942.45}",
        "prompt_text": "Write a function to find the surface area of a cylinder.",
        "prompt_explain": "Write a function to find the surface area of a cylinder.\n>>> surfacearea_cylinder 10 5\n942.45",
        "func_title": "proc surfacearea_cylinder {r h}"
    },
    {
        "prompt": "# Given two lists of integers, check whether the second list is a subarray of the first or not.\n# >>> is_Sub_Array {1 4 3 5} {1 2}\n# 0\n# >>> is_Sub_Array {1 2 1} {1 2 1}\n# 1\nproc is_Sub_Array {A B} {",
        "canonical_solution": "    set n [llength $A]\n    set m [llength $B]\n    set i 0\n    set j 0\n    while {$i < $n && $j < $m} {\n        if {[lindex $A $i] == [lindex $B $j]} {\n            incr i\n            incr j\n            if {$j == $m} {\n                return 1\n            }\n        } else {\n            set i [expr {$i - $j + 1}]\n            set j 0\n        }\n    }\n    return 0\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Sub_Array {1 4 3 5} {1 2}] == 0}\nassert {[is_Sub_Array {1 2 1} {1 2 1}] == 1}\nassert {[is_Sub_Array {1 0 2 2} {2 2 0}] == 0}",
        "declaration": "proc is_Sub_Array {A B} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Sub_Array {1 4 3 5} {1 2}] == 0}",
        "prompt_text": "Given two lists of integers, check whether the second list is a subarray of the first or not.",
        "prompt_explain": "Given two lists of integers, check whether the second list is a subarray of the first or not.\n>>> is_Sub_Array {1 4 3 5} {1 2}\n0\n>>> is_Sub_Array {1 2 1} {1 2 1}\n1",
        "func_title": "proc is_Sub_Array {A B}"
    },
    {
        "prompt": "# Write a Tcl function to find the surface area of the square pyramid.\n# >>> surface_Area 3 4\n# 33\nproc surface_Area {b s} {",
        "canonical_solution": "    return [expr {2 * $b * $s + pow($b, 2)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surface_Area 3 4] == 33}\nassert {[surface_Area 4 5] == 56}\nassert {[surface_Area 1 2] == 5}",
        "declaration": "proc surface_Area {b s} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surface_Area 3 4] == 33}",
        "prompt_text": "Write a Tcl function to find the surface area of the square pyramid.",
        "prompt_explain": "Write a Tcl function to find the surface area of the square pyramid.\n>>> surface_Area 3 4\n33",
        "func_title": "proc surface_Area {b s}"
    },
    {
        "prompt": "# Write a function to check if a dictionary is empty or not.\n# >>> my_dict {}\n# 1\n# >>> my_dict {key value}\n# 0\nproc my_dict {dict1} {",
        "canonical_solution": "    if {[dict size $dict1] == 0} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[my_dict {}] == 1}\nassert {[my_dict {key value}] == 0}\nassert {[my_dict {a 1 b 2}] == 0}",
        "declaration": "proc my_dict {dict1} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[my_dict {}] == 1}",
        "prompt_text": "Write a function to check if a dictionary is empty or not.",
        "prompt_explain": "Write a function to check if a dictionary is empty or not.\n>>> my_dict {}\n1\n>>> my_dict {key value}\n0",
        "func_title": "proc my_dict {dict1}"
    },
    {
        "prompt": "# Write a function for nth catalan number.\n# >>> catalan_number 10\n# 16796\nproc catalan_number {num} {",
        "canonical_solution": "    if {$num <= 1} {\n        return 1\n    }\n    set res_num 0\n    for {set i 0} {$i < $num} {incr i} {\n        set res_num [expr {$res_num + [catalan_number $i] * [catalan_number [expr {$num - $i - 1}]]}]\n    }\n    return $res_num\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[catalan_number 10] == 16796}\nassert {[catalan_number 9] == 4862}\nassert {[catalan_number 7] == 429}",
        "declaration": "proc catalan_number {num} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[catalan_number 10] == 16796}",
        "prompt_text": "Write a function for nth catalan number.",
        "prompt_explain": "Write a function for nth catalan number.\n>>> catalan_number 10\n16796",
        "func_title": "proc catalan_number {num}"
    },
    {
        "prompt": "# Given a list of integers, find the difference between the largest and smallest value in the list.\n# >>> big_diff {1 2 3 4}\n# 3\nproc big_diff {nums} {",
        "canonical_solution": "    set max_num [lindex $nums 0]\n    set min_num [lindex $nums 0]\n    foreach num $nums {\n        if {$num > $max_num} {\n            set max_num $num\n        }\n        if {$num < $min_num} {\n            set min_num $num\n        }\n    }\n    return [expr {$max_num - $min_num}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[big_diff {1 2 3 4}] == 3}\nassert {[big_diff {4 5 12}] == 8}\nassert {[big_diff {9 2 3}] == 7}",
        "declaration": "proc big_diff {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[big_diff {1 2 3 4}] == 3}",
        "prompt_text": "Given a list of integers, find the difference between the largest and smallest value in the list.",
        "prompt_explain": "Given a list of integers, find the difference between the largest and smallest value in the list.\n>>> big_diff {1 2 3 4}\n3",
        "func_title": "proc big_diff {nums}"
    },
    {
        "prompt": "# Write a Tcl function to find the sum of the product of binomial coefficients.\n# >>> sum_Of_product 3\n# 15\nproc sum_Of_product {n} {",
        "canonical_solution": "    proc binomial_Coeff {n k} {\n        set C [lrepeat [expr {$k + 1}] 0]\n        lset C 0 1\n        for {set i 1} {$i <= $n} {incr i} {\n            for {set j [expr {min($i, $k)}]} {$j > 0} {incr j -1} {\n                lset C $j [expr {[lindex $C $j] + [lindex $C [expr {$j - 1}]]}]\n            }\n        }\n        return [lindex $C $k]\n    }\n    return [binomial_Coeff [expr {2 * $n}] [expr {$n - 1}]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_Of_product 3] == 15}\nassert {[sum_Of_product 4] == 56}\nassert {[sum_Of_product 1] == 1}",
        "declaration": "proc sum_Of_product {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_Of_product 3] == 15}",
        "prompt_text": "Write a Tcl function to find the sum of the product of binomial coefficients.",
        "prompt_explain": "Write a Tcl function to find the sum of the product of binomial coefficients.\n>>> sum_Of_product 3\n15",
        "func_title": "proc sum_Of_product {n}"
    },
    {
        "prompt": "# Given a list of integers, find the difference between the first even and the first odd number in the list.\n# >>> diff_even_odd {1 3 5 7 4 1 6 8}\n# 3\nproc diff_even_odd {list1} {",
        "canonical_solution": "    set first_even -1\n    set first_odd -1\n    foreach el $list1 {\n        if {$el % 2 == 0 && $first_even == -1} {\n            set first_even $el\n        }\n        if {$el % 2 != 0 && $first_odd == -1} {\n            set first_odd $el\n        }\n        if {$first_even != -1 && $first_odd != -1} {\n            break\n        }\n    }\n    return [expr {$first_even - $first_odd}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[diff_even_odd {1 3 5 7 4 1 6 8}] == 3}\nassert {[diff_even_odd {1 2 3 4 5 6 7 8 9 10}] == 1}\nassert {[diff_even_odd {1 5 7 9 10}] == 9}",
        "declaration": "proc diff_even_odd {list1} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[diff_even_odd {1 3 5 7 4 1 6 8}] == 3}",
        "prompt_text": "Given a list of integers, find the difference between the first even and the first odd number in the list.",
        "prompt_explain": "Given a list of integers, find the difference between the first even and the first odd number in the list.\n>>> diff_even_odd {1 3 5 7 4 1 6 8}\n3",
        "func_title": "proc diff_even_odd {list1}"
    },
    {
        "prompt": "# Given two binary strings, return the minimum number of swaps required to convert one binary string to another. If conversion is not possible, return 'Not Possible'.\n# >>> min_Swaps \"1101\" \"1110\"\n# 1\nproc min_Swaps {str1 str2} {",
        "canonical_solution": "    set count 0\n    for {set i 0} {$i < [string length $str1]} {incr i} {\n        if {[string index $str1 $i] != [string index $str2 $i]} {\n            incr count\n        }\n    }\n    if {$count % 2 == 0} {\n        return [expr {$count / 2}]\n    } else {\n        return \"Not Possible\"\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_Swaps \"1101\" \"1110\"] == 1}\nassert {[min_Swaps \"111\" \"000\"] eq \"Not Possible\"}\nassert {[min_Swaps \"111\" \"110\"] eq \"Not Possible\"}",
        "declaration": "proc min_Swaps {str1 str2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_Swaps \"1101\" \"1110\"] == 1}",
        "prompt_text": "Given two binary strings, return the minimum number of swaps required to convert one binary string to another. If conversion is not possible, return 'Not Possible'.",
        "prompt_explain": "Given two binary strings, return the minimum number of swaps required to convert one binary string to another. If conversion is not possible, return 'Not Possible'.\n>>> min_Swaps \"1101\" \"1110\"\n1",
        "func_title": "proc min_Swaps {str1 str2}"
    },
    {
        "prompt": "# Given a tuple, return its size.\n# >>> tuple_size {A 1 B 2 C 3}\n# <size of the tuple>\nproc tuple_size {tuple_list} {",
        "canonical_solution": "    return [string length $tuple_list]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[tuple_size {A 1 B 2 C 3}] == [string length {A 1 B 2 C 3}]}\nassert {[tuple_size {1 Raju 2 Nikhil 3 Deepanshu}] == [string length {1 Raju 2 Nikhil 3 Deepanshu}]}\nassert {[tuple_size {{1 Lion} {2 Tiger} {3 Fox} {4 Wolf}}] == [string length {{1 Lion} {2 Tiger} {3 Fox} {4 Wolf}}]}",
        "declaration": "proc tuple_size {tuple_list} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[tuple_size {A 1 B 2 C 3}] == [string length {A 1 B 2 C 3}]}",
        "prompt_text": "Given a tuple, return its size.",
        "prompt_explain": "Given a tuple, return its size.\n>>> tuple_size {A 1 B 2 C 3}\n<size of the tuple>",
        "func_title": "proc tuple_size {tuple_list}"
    },
    {
        "prompt": "# Given two sorted arrays, find the kth element from the combined array.\n# >>> find_kth {2 3 6 7 9} {1 4 8 10} 5 4 5\n# 6\nproc find_kth {arr1 arr2 m n k} {",
        "canonical_solution": "    set sorted1 [list]\n    set i 0\n    set j 0\n    set d 0\n    while {$i < $m && $j < $n} {\n        if {[lindex $arr1 $i] < [lindex $arr2 $j]} {\n            lappend sorted1 [lindex $arr1 $i]\n            incr i\n        } else {\n            lappend sorted1 [lindex $arr2 $j]\n            incr j\n        }\n        incr d\n    }\n    while {$i < $m} {\n        lappend sorted1 [lindex $arr1 $i]\n        incr i\n        incr d\n    }\n    while {$j < $n} {\n        lappend sorted1 [lindex $arr2 $j]\n        incr j\n        incr d\n    }\n    return [lindex $sorted1 [expr {$k - 1}]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_kth {2 3 6 7 9} {1 4 8 10} 5 4 5] == 6}\nassert {[find_kth {100 112 256 349 770} {72 86 113 119 265 445 892} 5 7 7] == 256}\nassert {[find_kth {3 4 7 8 10} {2 5 9 11} 5 4 6] == 8}",
        "declaration": "proc find_kth {arr1 arr2 m n k} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_kth {2 3 6 7 9} {1 4 8 10} 5 4 5] == 6}",
        "prompt_text": "Given two sorted arrays, find the kth element from the combined array.",
        "prompt_explain": "Given two sorted arrays, find the kth element from the combined array.\n>>> find_kth {2 3 6 7 9} {1 4 8 10} 5 4 5\n6",
        "func_title": "proc find_kth {arr1 arr2 m n k}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the given number is even or not using bitwise operator.\n# >>> is_Even 1\n# False\n# >>> is_Even 2\n# True\nproc is_Even {n} {",
        "canonical_solution": "    if {($n ^ 1) == ($n + 1)} {\n        return True\n    } else {\n        return False\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Even 1] == False}\nassert {[is_Even 2] == True}\nassert {[is_Even 3] == False}",
        "declaration": "proc is_Even {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Even 1] == False}",
        "prompt_text": "Write a Tcl function to check whether the given number is even or not using bitwise operator.",
        "prompt_explain": "Write a Tcl function to check whether the given number is even or not using bitwise operator.\n>>> is_Even 1\nFalse\n>>> is_Even 2\nTrue",
        "func_title": "proc is_Even {n}"
    },
    {
        "prompt": "# Write a function to check if the given integer is a prime number.\n# >>> prime_num 13\n# 1\n# >>> prime_num 7\n# 1\n# >>> prime_num -1010\n# 0\nproc prime_num {num} {",
        "canonical_solution": "    if {$num >= 1} {\n        for {set i 2} {$i <= [expr {$num / 2}]} {incr i} {\n            if {[expr {$num % $i}] == 0} {\n                return 0\n            }\n        }\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[prime_num 13] == 1}\nassert {[prime_num 7] == 1}\nassert {[prime_num -1010] == 0}",
        "declaration": "proc prime_num {num} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[prime_num 13] == 1}",
        "prompt_text": "Write a function to check if the given integer is a prime number.",
        "prompt_explain": "Write a function to check if the given integer is a prime number.\n>>> prime_num 13\n1\n>>> prime_num 7\n1\n>>> prime_num -1010\n0",
        "func_title": "proc prime_num {num}"
    },
    {
        "prompt": "# Write a function to convert degrees to radians.\n# >>> radian_degree 90\n# 1.5707963267948966\nproc radian_degree {degree} {",
        "canonical_solution": "    set pi [expr {acos(-1)}]\n    set radian [expr {$degree * ($pi / 180)}]\n    return $radian\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[radian_degree 90] == 1.5707963267948966}\nassert {[radian_degree 60] == 1.0471975511965976}\nassert {[radian_degree 120] == 2.0943951023931953}",
        "declaration": "proc radian_degree {degree} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[radian_degree 90] == 1.5707963267948966}",
        "prompt_text": "Write a function to convert degrees to radians.",
        "prompt_explain": "Write a function to convert degrees to radians.\n>>> radian_degree 90\n1.5707963267948966",
        "func_title": "proc radian_degree {degree}"
    },
    {
        "prompt": "# Write a Tcl function to find the nth Bell number.\n# >>> bell_Number 2\n# 2\nproc bell_Number {n} {",
        "canonical_solution": "    set bell [lrepeat [expr {$n + 1}] [lrepeat [expr {$n + 1}] 0]]\n    lset bell 0 0 1\n    for {set i 1} {$i <= $n} {incr i} {\n        lset bell $i 0 [lindex $bell [expr {$i - 1}] [expr {$i - 1}]]\n        for {set j 1} {$j <= $i} {incr j} {\n            lset bell $i $j [expr {[lindex $bell [expr {$i - 1}] [expr {$j - 1}]] + [lindex $bell $i [expr {$j - 1}]]}]\n        }\n    }\n    return [lindex $bell $n 0]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[bell_Number 2] == 2}\nassert {[bell_Number 3] == 5}\nassert {[bell_Number 4] == 15}",
        "declaration": "proc bell_Number {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[bell_Number 2] == 2}",
        "prompt_text": "Write a Tcl function to find the nth Bell number.",
        "prompt_explain": "Write a Tcl function to find the nth Bell number.\n>>> bell_Number 2\n2",
        "func_title": "proc bell_Number {n}"
    },
    {
        "prompt": "# Given a list of tuples, find the maximum of nth column from the given tuple list.\n# >>> max_of_nth {{5 6 7} {1 3 5} {8 9 19}} 2\n# 19\nproc max_of_nth {test_list N} {",
        "canonical_solution": "    set res [lindex [lindex $test_list 0] $N]\n    foreach sub $test_list {\n        if {[lindex $sub $N] > $res} {\n            set res [lindex $sub $N]\n        }\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_of_nth {{5 6 7} {1 3 5} {8 9 19}} 2] == 19}\nassert {[max_of_nth {{6 7 8} {2 4 6} {9 10 20}} 1] == 10}\nassert {[max_of_nth {{7 8 9} {3 5 7} {10 11 21}} 1] == 11}",
        "declaration": "proc max_of_nth {test_list N} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_of_nth {{5 6 7} {1 3 5} {8 9 19}} 2] == 19}",
        "prompt_text": "Given a list of tuples, find the maximum of nth column from the given tuple list.",
        "prompt_explain": "Given a list of tuples, find the maximum of nth column from the given tuple list.\n>>> max_of_nth {{5 6 7} {1 3 5} {8 9 19}} 2\n19",
        "func_title": "proc max_of_nth {test_list N}"
    },
    {
        "prompt": "# Given a list of integers, find the smallest missing number from the given array.\n# >>> find_First_Missing {0 1 2 3} 0 3\n# 4\nproc find_First_Missing {array start end} {",
        "canonical_solution": "    if {$start > $end} {\n        return [expr {$end + 1}]\n    }\n    if {$start != [lindex $array $start]} {\n        return $start\n    }\n    set mid [expr {($start + $end) / 2}]\n    if {[lindex $array $mid] == $mid} {\n        return [find_First_Missing $array [expr {$mid + 1}] $end]\n    }\n    return [find_First_Missing $array $start $mid]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_First_Missing {0 1 2 3} 0 3] == 4}\nassert {[find_First_Missing {0 1 2 6 9} 0 4] == 3}\nassert {[find_First_Missing {2 3 5 8 9} 0 4] == 0}",
        "declaration": "proc find_First_Missing {array start end} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_First_Missing {0 1 2 3} 0 3] == 4}",
        "prompt_text": "Given a list of integers, find the smallest missing number from the given array.",
        "prompt_explain": "Given a list of integers, find the smallest missing number from the given array.\n>>> find_First_Missing {0 1 2 3} 0 3\n4",
        "func_title": "proc find_First_Missing {array start end}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of XOR of all pairs of numbers in the given array.\n# >>> pair_OR_Sum {5 9 7 6}\n# 47\nproc pair_OR_Sum {arr} {",
        "canonical_solution": "    set ans 0\n    set n [llength $arr]\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $n} {incr j} {\n            set ans [expr {$ans + ([lindex $arr $i] ^ [lindex $arr $j])}]\n        }\n    }\n    return $ans\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[pair_OR_Sum {5 9 7 6}] == 47}\nassert {[pair_OR_Sum {7 3 5}] == 12}\nassert {[pair_OR_Sum {7 3}] == 4}",
        "declaration": "proc pair_OR_Sum {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[pair_OR_Sum {5 9 7 6}] == 47}",
        "prompt_text": "Given a list of integers, return the sum of XOR of all pairs of numbers in the given array.",
        "prompt_explain": "Given a list of integers, return the sum of XOR of all pairs of numbers in the given array.\n>>> pair_OR_Sum {5 9 7 6}\n47",
        "func_title": "proc pair_OR_Sum {arr}"
    },
    {
        "prompt": "# Write a Tcl function to find the sum of fourth power of first n even natural numbers.\n# >>> even_Power_Sum 2\n# 272\nproc even_Power_Sum {n} {",
        "canonical_solution": "    set sum 0\n    for {set i 1} {$i <= $n} {incr i} {\n        set j [expr {2 * $i}]\n        set sum [expr {$sum + $j ** 4}]\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_Power_Sum 2] == 272}\nassert {[even_Power_Sum 3] == 1568}\nassert {[even_Power_Sum 4] == 5664}",
        "declaration": "proc even_Power_Sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_Power_Sum 2] == 272}",
        "prompt_text": "Write a Tcl function to find the sum of fourth power of first n even natural numbers.",
        "prompt_explain": "Write a Tcl function to find the sum of fourth power of first n even natural numbers.\n>>> even_Power_Sum 2\n272",
        "func_title": "proc even_Power_Sum {n}"
    },
    {
        "prompt": "# Write a Tcl function to check if roots of a quadratic equation are reciprocal of each other or not.\n# >>> Check_Solution 2 0 2\n# Yes\n# >>> Check_Solution 2 -5 2\n# Yes\n# >>> Check_Solution 1 2 3\n# No\nproc Check_Solution {a b c} {",
        "canonical_solution": "    if {$a == $c} {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Check_Solution 2 0 2] eq \"Yes\"}\nassert {[Check_Solution 2 -5 2] eq \"Yes\"}\nassert {[Check_Solution 1 2 3] eq \"No\"}",
        "declaration": "proc Check_Solution {a b c} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Check_Solution 2 0 2] eq \"Yes\"}",
        "prompt_text": "Write a Tcl function to check if roots of a quadratic equation are reciprocal of each other or not.",
        "prompt_explain": "Write a Tcl function to check if roots of a quadratic equation are reciprocal of each other or not.\n>>> Check_Solution 2 0 2\nYes\n>>> Check_Solution 2 -5 2\nYes\n>>> Check_Solution 1 2 3\nNo",
        "func_title": "proc Check_Solution {a b c}"
    },
    {
        "prompt": "# Write a function to check whether the given amount has no profit and no loss\n# >>> noprofit_noloss 1500 1200\n# False\n# >>> noprofit_noloss 100 100\n# True\n# >>> noprofit_noloss 2000 5000\n# False\nproc noprofit_noloss {actual_cost sale_amount} {",
        "canonical_solution": "    if {$sale_amount == $actual_cost} {\n        return True\n    } else {\n        return False\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[noprofit_noloss 1500 1200] == False}\nassert {[noprofit_noloss 100 100] == True}\nassert {[noprofit_noloss 2000 5000] == False}",
        "declaration": "proc noprofit_noloss {actual_cost sale_amount} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[noprofit_noloss 1500 1200] == False}",
        "prompt_text": "Write a function to check whether the given amount has no profit and no loss",
        "prompt_explain": "Write a function to check whether the given amount has no profit and no loss\n>>> noprofit_noloss 1500 1200\nFalse\n>>> noprofit_noloss 100 100\nTrue\n>>> noprofit_noloss 2000 5000\nFalse",
        "func_title": "proc noprofit_noloss {actual_cost sale_amount}"
    },
    {
        "prompt": "# Write a function to calculate wind chill index.\n# >>> wind_chill 120 35\n# 40\nproc wind_chill {v t} {",
        "canonical_solution": "    set windchill [expr {13.12 + 0.6215 * $t - 11.37 * pow($v, 0.16) + 0.3965 * $t * pow($v, 0.16)}]\n    return [expr {int(round($windchill))}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[wind_chill 120 35] == 40}\nassert {[wind_chill 40 70] == 86}\nassert {[wind_chill 10 100] == 116}",
        "declaration": "proc wind_chill {v t} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[wind_chill 120 35] == 40}",
        "prompt_text": "Write a function to calculate wind chill index.",
        "prompt_explain": "Write a function to calculate wind chill index.\n>>> wind_chill 120 35\n40",
        "func_title": "proc wind_chill {v t}"
    },
    {
        "prompt": "# Write a function to find the nth nonagonal number.\n# >>> is_nonagonal 10\n# 325\nproc is_nonagonal {n} {",
        "canonical_solution": "    return [expr {int($n * (7 * $n - 5) / 2)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_nonagonal 10] == 325}\nassert {[is_nonagonal 15] == 750}\nassert {[is_nonagonal 18] == 1089}",
        "declaration": "proc is_nonagonal {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_nonagonal 10] == 325}",
        "prompt_text": "Write a function to find the nth nonagonal number.",
        "prompt_explain": "Write a function to find the nth nonagonal number.\n>>> is_nonagonal 10\n325",
        "func_title": "proc is_nonagonal {n}"
    },
    {
        "prompt": "# Given a cube of size n, return the number of smaller cubes of size k that can fit inside it.\n# >>> No_of_cubes 2 1\n# 8\nproc No_of_cubes {N K} {",
        "canonical_solution": "    set No [expr {($N - $K + 1) ** 3}]\n    return $No\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[No_of_cubes 2 1] == 8}\nassert {[No_of_cubes 5 2] == 64}\nassert {[No_of_cubes 1 1] == 1}",
        "declaration": "proc No_of_cubes {N K} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[No_of_cubes 2 1] == 8}",
        "prompt_text": "Given a cube of size n, return the number of smaller cubes of size k that can fit inside it.",
        "prompt_explain": "Given a cube of size n, return the number of smaller cubes of size k that can fit inside it.\n>>> No_of_cubes 2 1\n8",
        "func_title": "proc No_of_cubes {N K}"
    },
    {
        "prompt": "# Given two lists of integers, check whether they are equal or not. The lists are considered equal if they contain the same elements in the same order.\n# >>> are_Equal {1 2 3} {3 2 1}\n# False\nproc are_Equal {arr1 arr2} {",
        "canonical_solution": "    if {[llength $arr1] != [llength $arr2]} {\n        return False\n    }\n    set arr1 [lsort $arr1]\n    set arr2 [lsort $arr2]\n    for {set i 0} {$i < [llength $arr1]} {incr i} {\n        if {[lindex $arr1 $i] != [lindex $arr2 $i]} {\n            return False\n        }\n    }\n    return True\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[are_Equal {1 2 3} {3 2 1}] == True}\nassert {[are_Equal {1 1 1} {2 2 2}] == False}\nassert {[are_Equal {8 9} {4 5 6}] == False}",
        "declaration": "proc are_Equal {arr1 arr2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[are_Equal {1 2 3} {3 2 1}] == True}",
        "prompt_text": "Given two lists of integers, check whether they are equal or not. The lists are considered equal if they contain the same elements in the same order.",
        "prompt_explain": "Given two lists of integers, check whether they are equal or not. The lists are considered equal if they contain the same elements in the same order.\n>>> are_Equal {1 2 3} {3 2 1}\nFalse",
        "func_title": "proc are_Equal {arr1 arr2}"
    },
    {
        "prompt": "# Write a function to find the perimeter of a rectangle.\n# >>> rectangle_perimeter 10 20\n# 60\nproc rectangle_perimeter {l b} {",
        "canonical_solution": "    set perimeter [expr {2 * ($l + $b)}]\n    return $perimeter\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[rectangle_perimeter 10 20] == 60}\nassert {[rectangle_perimeter 10 5] == 30}\nassert {[rectangle_perimeter 4 2] == 12}",
        "declaration": "proc rectangle_perimeter {l b} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[rectangle_perimeter 10 20] == 60}",
        "prompt_text": "Write a function to find the perimeter of a rectangle.",
        "prompt_explain": "Write a function to find the perimeter of a rectangle.\n>>> rectangle_perimeter 10 20\n60",
        "func_title": "proc rectangle_perimeter {l b}"
    },
    {
        "prompt": "# Write a Tcl function to find the sum of fifth power of n natural numbers.\n# >>> fifth_Power_Sum 2\n# 33\nproc fifth_Power_Sum {n} {",
        "canonical_solution": "    set sm 0\n    for {set i 1} {$i <= $n} {incr i} {\n        set sm [expr {$sm + $i**5}]\n    }\n    return $sm\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[fifth_Power_Sum 2] == 33}\nassert {[fifth_Power_Sum 4] == 1300}\nassert {[fifth_Power_Sum 3] == 276}",
        "declaration": "proc fifth_Power_Sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[fifth_Power_Sum 2] == 33}",
        "prompt_text": "Write a Tcl function to find the sum of fifth power of n natural numbers.",
        "prompt_explain": "Write a Tcl function to find the sum of fifth power of n natural numbers.\n>>> fifth_Power_Sum 2\n33",
        "func_title": "proc fifth_Power_Sum {n}"
    },
    {
        "prompt": "# Write a Tcl function to find the first digit in factorial of a given number.\n# >>> first_Digit 5\n# 1\nproc first_Digit {n} {",
        "canonical_solution": "    set fact 1\n    for {set i 2} {$i <= $n} {incr i} {\n        set fact [expr {$fact * $i}]\n        while {[expr {$fact % 10}] == 0} {\n            set fact [expr {$fact / 10}]\n        }\n    }\n    while {$fact >= 10} {\n        set fact [expr {$fact / 10}]\n    }\n    return [expr {int($fact)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[first_Digit 5] == 1}\nassert {[first_Digit 10] == 3}\nassert {[first_Digit 7] == 5}",
        "declaration": "proc first_Digit {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[first_Digit 5] == 1}",
        "prompt_text": "Write a Tcl function to find the first digit in factorial of a given number.",
        "prompt_explain": "Write a Tcl function to find the first digit in factorial of a given number.\n>>> first_Digit 5\n1",
        "func_title": "proc first_Digit {n}"
    },
    {
        "prompt": "# Given a list of items, return the item with maximum occurrences in the list.\n# >>> max_occurrences {2 3 8 4 7 9 8 2 6 5 1 6 1 2 3 4 6 9 1 2}\n# 2\nproc max_occurrences {list1} {",
        "canonical_solution": "    set max_val 0\n    set result [lindex $list1 0]\n    foreach i $list1 {\n        set occu [llength [lsearch -all $list1 $i]]\n        if {$occu > $max_val} {\n            set max_val $occu\n            set result $i\n        }\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_occurrences {2 3 8 4 7 9 8 2 6 5 1 6 1 2 3 4 6 9 1 2}] == 2}\nassert {[max_occurrences {1 3 5 7 1 3 13 15 17 5 7 9 1 11}] == 1}\nassert {[max_occurrences {1 2 3 2 4 5 1 1 1}] == 1}",
        "declaration": "proc max_occurrences {list1} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_occurrences {2 3 8 4 7 9 8 2 6 5 1 6 1 2 3 4 6 9 1 2}] == 2}",
        "prompt_text": "Given a list of items, return the item with maximum occurrences in the list.",
        "prompt_explain": "Given a list of items, return the item with maximum occurrences in the list.\n>>> max_occurrences {2 3 8 4 7 9 8 2 6 5 1 6 1 2 3 4 6 9 1 2}\n2",
        "func_title": "proc max_occurrences {list1}"
    },
    {
        "prompt": "# Given a list of integers, find the maximum sum that can be formed which has no three consecutive elements present.\n# >>> max_sum_of_three_consecutive {100 1000 100 1000 1}\n# 2101\nproc max_sum_of_three_consecutive {arr n} {",
        "canonical_solution": "    set sum [list]\n    for {set k 0} {$k < $n} {incr k} {\n        lappend sum 0\n    }\n    if {$n >= 1} {\n        lset sum 0 [lindex $arr 0]\n    }\n    if {$n >= 2} {\n        lset sum 1 [expr {[lindex $arr 0] + [lindex $arr 1]}]\n    }\n    if {$n > 2} {\n        lset sum 2 [expr {max([lindex $sum 1], max([lindex $arr 1] + [lindex $arr 2], [lindex $arr 0] + [lindex $arr 2]))}]\n    }\n    for {set i 3} {$i < $n} {incr i} {\n        lset sum $i [expr {max(max([lindex $sum [expr {$i - 1}]], [lindex $sum [expr {$i - 2}]] + [lindex $arr $i]), [lindex $arr $i] + [lindex $arr [expr {$i - 1}]] + [lindex $sum [expr {$i - 3}]])}]\n    }\n    return [lindex $sum [expr {$n - 1}]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sum_of_three_consecutive {100 1000 100 1000 1} 5] == 2101}\nassert {[max_sum_of_three_consecutive {3000 2000 1000 3 10} 5] == 5013}\nassert {[max_sum_of_three_consecutive {1 2 3 4 5 6 7 8} 8] == 27}",
        "declaration": "proc max_sum_of_three_consecutive {arr n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sum_of_three_consecutive {100 1000 100 1000 1} 5] == 2101}",
        "prompt_text": "Given a list of integers, find the maximum sum that can be formed which has no three consecutive elements present.",
        "prompt_explain": "Given a list of integers, find the maximum sum that can be formed which has no three consecutive elements present.\n>>> max_sum_of_three_consecutive {100 1000 100 1000 1}\n2101",
        "func_title": "proc max_sum_of_three_consecutive {arr n}"
    },
    {
        "prompt": "# Given a list of integers, check whether the sequence has a decreasing trend or not.\n# >>> decreasing_trend {3 2 1}\n# 1\n# >>> decreasing_trend {1 2 3}\n# 0\nproc decreasing_trend {nums} {",
        "canonical_solution": "    set sorted_nums [lsort -integer $nums]\n    if {$sorted_nums eq $nums} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[decreasing_trend {-4 -3 -2 -1}] == 1}\nassert {[decreasing_trend {1 2 3}] == 1}\nassert {[decreasing_trend {3 2 1}] == 0}",
        "declaration": "proc decreasing_trend {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[decreasing_trend {3 2 1}] == 0}",
        "prompt_text": "Given a list of integers, check whether the sequence has a decreasing trend or not.",
        "prompt_explain": "Given a list of integers, check whether the sequence has a decreasing trend or not.\n>>> decreasing_trend {3 2 1}\n1\n>>> decreasing_trend {1 2 3}\n0",
        "func_title": "proc decreasing_trend {nums}"
    },
    {
        "prompt": "# Write a function to find maximum of three numbers.\n# >>> max_of_three 10 20 30\n# 30\nproc max_of_three {num1 num2 num3} {",
        "canonical_solution": "    if {$num1 >= $num2 && $num1 >= $num3} {\n        return $num1\n    } elseif {$num2 >= $num1 && $num2 >= $num3} {\n        return $num2\n    } else {\n        return $num3\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_of_three 10 20 30] == 30}\nassert {[max_of_three 55 47 39] == 55}\nassert {[max_of_three 10 49 30] == 49}",
        "declaration": "proc max_of_three {num1 num2 num3} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_of_three 10 20 30] == 30}",
        "prompt_text": "Write a function to find maximum of three numbers.",
        "prompt_explain": "Write a function to find maximum of three numbers.\n>>> max_of_three 10 20 30\n30",
        "func_title": "proc max_of_three {num1 num2 num3}"
    },
    {
        "prompt": "# Given a list of integers, convert it into a single integer.\n# >>> convert {1 2 3}\n# 123\nproc convert {list} {",
        "canonical_solution": "    set s \"\"\n    foreach i $list {\n        append s $i\n    }\n    return [expr {$s}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[convert {1 2 3}] == 123}\nassert {[convert {4 5 6}] == 456}\nassert {[convert {7 8 9}] == 789}",
        "declaration": "proc convert {list} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[convert {1 2 3}] == 123}",
        "prompt_text": "Given a list of integers, convert it into a single integer.",
        "prompt_explain": "Given a list of integers, convert it into a single integer.\n>>> convert {1 2 3}\n123",
        "func_title": "proc convert {list}"
    },
    {
        "prompt": "# Write a function to add two integers. however, if the sum is between the given range it will return 20.\n# >>> sum_nums 2 10 11 20\n# 20\n# >>> sum_nums 15 17 1 10\n# 32\n# >>> sum_nums 10 15 5 30\n# 20\nproc sum_nums {x y m n} {",
        "canonical_solution": "    set sum_nums [expr {$x + $y}]\n    if {$sum_nums >= $m && $sum_nums < $n} {\n        return 20\n    } else {\n        return $sum_nums\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_nums 2 10 11 20] == 20}\nassert {[sum_nums 15 17 1 10] == 32}\nassert {[sum_nums 10 15 5 30] == 20}",
        "declaration": "proc sum_nums {x y m n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_nums 2 10 11 20] == 20}",
        "prompt_text": "Write a function to add two integers. however, if the sum is between the given range it will return 20.",
        "prompt_explain": "Write a function to add two integers. however, if the sum is between the given range it will return 20.\n>>> sum_nums 2 10 11 20\n20\n>>> sum_nums 15 17 1 10\n32\n>>> sum_nums 10 15 5 30\n20",
        "func_title": "proc sum_nums {x y m n}"
    },
    {
        "prompt": "# Write a function to check if the triangle is valid or not.\n# >>> validity_triangle 60 50 90\n# 0\n# >>> validity_triangle 45 75 60\n# 1\nproc validity_triangle {a b c} {",
        "canonical_solution": "    set total [expr {$a + $b + $c}]\n    if {$total == 180} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[validity_triangle 60 50 90] == 0}\nassert {[validity_triangle 45 75 60] == 1}\nassert {[validity_triangle 30 50 100] == 1}",
        "declaration": "proc validity_triangle {a b c} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[validity_triangle 60 50 90] == 0}",
        "prompt_text": "Write a function to check if the triangle is valid or not.",
        "prompt_explain": "Write a function to check if the triangle is valid or not.\n>>> validity_triangle 60 50 90\n0\n>>> validity_triangle 45 75 60\n1",
        "func_title": "proc validity_triangle {a b c}"
    },
    {
        "prompt": "# Write a Tcl function to find the smallest prime divisor of a number.\n# >>> smallest_Divisor 10\n# 2\nproc smallest_Divisor {n} {",
        "canonical_solution": "    if {$n % 2 == 0} {\n        return 2\n    }\n    set i 3\n    while {$i * $i <= $n} {\n        if {$n % $i == 0} {\n            return $i\n        }\n        incr i 2\n    }\n    return $n\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smallest_Divisor 10] == 2}\nassert {[smallest_Divisor 25] == 5}\nassert {[smallest_Divisor 31] == 31}",
        "declaration": "proc smallest_Divisor {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smallest_Divisor 10] == 2}",
        "prompt_text": "Write a Tcl function to find the smallest prime divisor of a number.",
        "prompt_explain": "Write a Tcl function to find the smallest prime divisor of a number.\n>>> smallest_Divisor 10\n2",
        "func_title": "proc smallest_Divisor {n}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the given number can be represented by sum of two squares or not.\n# >>> sum_Square 25\n# 1\n# >>> sum_Square 24\n# 0\n# >>> sum_Square 17\n# 1\nproc sum_Square {n} {",
        "canonical_solution": "    set i 1\n    while {$i * $i <= $n} {\n        set j 1\n        while {$j * $j <= $n} {\n            if {$i * $i + $j * $j == $n} {\n                return 1\n            }\n            incr j\n        }\n        incr i\n    }\n    return 0\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_Square 25] == 1}\nassert {[sum_Square 24] == 0}\nassert {[sum_Square 17] == 1}",
        "declaration": "proc sum_Square {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_Square 25] == 1}",
        "prompt_text": "Write a Tcl function to check whether the given number can be represented by sum of two squares or not.",
        "prompt_explain": "Write a Tcl function to check whether the given number can be represented by sum of two squares or not.\n>>> sum_Square 25\n1\n>>> sum_Square 24\n0\n>>> sum_Square 17\n1",
        "func_title": "proc sum_Square {n}"
    },
    {
        "prompt": "# Write a function to find the greatest common divisor (gcd) of two integers by using recursion.\n# >>> recur_gcd 12 14\n# 2\nproc recur_gcd {a b} {",
        "canonical_solution": "    set low [expr {min($a, $b)}]\n    set high [expr {max($a, $b)}]\n    if {$low == 0} {\n        return $high\n    } elseif {$low == 1} {\n        return 1\n    } else {\n        return [recur_gcd $low [expr {$high % $low}]]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[recur_gcd 12 14] == 2}\nassert {[recur_gcd 13 17] == 1}\nassert {[recur_gcd 9 3] == 3}",
        "declaration": "proc recur_gcd {a b} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[recur_gcd 12 14] == 2}",
        "prompt_text": "Write a function to find the greatest common divisor (gcd) of two integers by using recursion.",
        "prompt_explain": "Write a function to find the greatest common divisor (gcd) of two integers by using recursion.\n>>> recur_gcd 12 14\n2",
        "func_title": "proc recur_gcd {a b}"
    },
    {
        "prompt": "# Given an array of integers where each element represents the max number of steps that can be made forward from that element, write a function to find the minimum number of jumps to reach the end of the array.\n# >>> min_jumps {1 3 6 1 0 9}\n# 3\nproc min_jumps {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set jumps [list]\n    for {set i 0} {$i < $n} {incr i} {\n        lappend jumps 0\n    }\n    if {$n == 0 || [lindex $arr 0] == 0} {\n        return Inf\n    }\n    lset jumps 0 0\n    for {set i 1} {$i < $n} {incr i} {\n        lset jumps $i Inf\n        for {set j 0} {$j < $i} {incr j} {\n            if {$i <= [expr {$j + [lindex $arr $j]}] && [lindex $jumps $j] != Inf} {\n                lset jumps $i [expr {min([lindex $jumps $i], [lindex $jumps $j] + 1)}]\n                break\n            }\n        }\n    }\n    return [lindex $jumps [expr {$n - 1}]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_jumps {1 3 6 1 0 9}] == 3}\nassert {[min_jumps {1 3 5 8 9 2 6 7 6 8 9}] == 3}\nassert {[min_jumps {1 1 1 1 1 1 1 1 1 1 1}] == 10}",
        "declaration": "proc min_jumps {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_jumps {1 3 6 1 0 9}] == 3}",
        "prompt_text": "Given an array of integers where each element represents the max number of steps that can be made forward from that element, write a function to find the minimum number of jumps to reach the end of the array.",
        "prompt_explain": "Given an array of integers where each element represents the max number of steps that can be made forward from that element, write a function to find the minimum number of jumps to reach the end of the array.\n>>> min_jumps {1 3 6 1 0 9}\n3",
        "func_title": "proc min_jumps {arr}"
    },
    {
        "prompt": "# Given two binary strings, find the minimum number of swaps required to convert one binary string to another.\n# >>> min_Swaps \"1101\" \"1110\"\n# 1\nproc min_Swaps {str1 str2} {",
        "canonical_solution": "    set count 0\n    for {set i 0} {$i < [string length $str1]} {incr i} {\n        if {[string index $str1 $i] != [string index $str2 $i]} {\n            incr count\n        }\n    }\n    if {$count % 2 == 0} {\n        return [expr {$count / 2}]\n    } else {\n        return \"Not Possible\"\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_Swaps \"1101\" \"1110\"] == 1}\nassert {[min_Swaps \"1111\" \"0100\"] eq \"Not Possible\"}\nassert {[min_Swaps \"1110000\" \"0001101\"] == 3}",
        "declaration": "proc min_Swaps {str1 str2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_Swaps \"1101\" \"1110\"] == 1}",
        "prompt_text": "Given two binary strings, find the minimum number of swaps required to convert one binary string to another.",
        "prompt_explain": "Given two binary strings, find the minimum number of swaps required to convert one binary string to another.\n>>> min_Swaps \"1101\" \"1110\"\n1",
        "func_title": "proc min_Swaps {str1 str2}"
    },
    {
        "prompt": "# Given a list of elements, count the number of elements which are within a specific range.\n# >>> count_range_in_list {10 20 30 40 40 40 70 80 99} 40 100\n# 6\nproc count_range_in_list {li min max} {",
        "canonical_solution": "    set ctr 0\n    foreach x $li {\n        if {$min <= $x && $x <= $max} {\n            incr ctr\n        }\n    }\n    return $ctr\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_range_in_list {10 20 30 40 40 40 70 80 99} 40 100] == 6}\nassert {[count_range_in_list {a b c d e f} a e] == 5}\nassert {[count_range_in_list {7 8 9 15 17 19 45} 15 20] == 3}",
        "declaration": "proc count_range_in_list {li min max} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_range_in_list {10 20 30 40 40 40 70 80 99} 40 100] == 6}",
        "prompt_text": "Given a list of elements, count the number of elements which are within a specific range.",
        "prompt_explain": "Given a list of elements, count the number of elements which are within a specific range.\n>>> count_range_in_list {10 20 30 40 40 40 70 80 99} 40 100\n6",
        "func_title": "proc count_range_in_list {li min max}"
    },
    {
        "prompt": "# Given a list of integers, find the equilibrium index of the given array.\n# The equilibrium index is the index where the sum of elements at lower indexes is equal to the sum of elements at higher indexes.\n# >>> equilibrium_index {1 2 3 4 1 2 3}\n# 3\nproc equilibrium_index {arr} {",
        "canonical_solution": "    set total_sum [expr [join $arr +]]\n    set left_sum 0\n    for {set i 0} {$i < [llength $arr]} {incr i} {\n        set total_sum [expr $total_sum - [lindex $arr $i]]\n        if {$left_sum == $total_sum} {\n            return $i\n        }\n        set left_sum [expr $left_sum + [lindex $arr $i]]\n    }\n    return -1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[equilibrium_index {1 2 3 4 1 2 3}] == 3}\nassert {[equilibrium_index {-7 1 5 2 -4 3 0}] == 3}\nassert {[equilibrium_index {1 2 3}] == -1}",
        "declaration": "proc equilibrium_index {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[equilibrium_index {1 2 3 4 1 2 3}] == 3}",
        "prompt_text": "Given a list of integers, find the equilibrium index of the given array. The equilibrium index is the index where the sum of elements at lower indexes is equal to the sum of elements at higher indexes.",
        "prompt_explain": "Given a list of integers, find the equilibrium index of the given array. The equilibrium index is the index where the sum of elements at lower indexes is equal to the sum of elements at higher indexes.\n>>> equilibrium_index {1 2 3 4 1 2 3}\n3",
        "func_title": "proc equilibrium_index {arr}"
    },
    {
        "prompt": "# Given a list of integers and an integer k, find the minimum number of elements that should be removed such that the difference between the maximum and minimum elements in the list is less than or equal to k.\n# >>> removals {1 3 4 9 10 11 12 17 20} 4\n# 5\nproc removals {arr k} {",
        "canonical_solution": "    set n [llength $arr]\n    set arr [lsort -integer $arr]\n    set ans [expr {$n - 1}]\n    for {set i 0} {$i < $n} {incr i} {\n        set j [find_ind [lindex $arr $i] $i $n $k $arr]\n        if {$j != -1} {\n            set ans [expr {min($ans, $n - ($j - $i + 1))}]\n        }\n    }\n    return $ans\n}\n\nproc find_ind {key i n k arr} {\n    set ind -1\n    set start [expr {$i + 1}]\n    set end [expr {$n - 1}]\n    while {$start < $end} {\n        set mid [expr {int($start + ($end - $start) / 2)}]\n        if {[lindex $arr $mid] - $key <= $k} {\n            set ind $mid\n            set start [expr {$mid + 1}]\n        } else {\n            set end $mid\n        }\n    }\n    return $ind\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[removals {1 3 4 9 10 11 12 17 20} 4] == 5}\nassert {[removals {1 5 6 2 8} 2] == 3}\nassert {[removals {1 2 3 4 5 6} 3] == 2}",
        "declaration": "proc removals {arr k} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[removals {1 3 4 9 10 11 12 17 20} 4] == 5}",
        "prompt_text": "Given a list of integers and an integer k, find the minimum number of elements that should be removed such that the difference between the maximum and minimum elements in the list is less than or equal to k.",
        "prompt_explain": "Given a list of integers and an integer k, find the minimum number of elements that should be removed such that the difference between the maximum and minimum elements in the list is less than or equal to k.\n>>> removals {1 3 4 9 10 11 12 17 20} 4\n5",
        "func_title": "proc removals {arr k}"
    },
    {
        "prompt": "# Write a function to check whether the given key is present in the dictionary or not.\n# >>> is_key_present {1 10 2 20 3 30 4 40 5 50 6 60} 5\n# 1\nproc is_key_present {dict key} {",
        "canonical_solution": "    if {[dict exists $dict $key]} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_key_present {1 10 2 20 3 30 4 40 5 50 6 60} 5] == 1}\nassert {[is_key_present {1 10 2 20 3 30 4 40 5 50 6 60} 6] == 1}\nassert {[is_key_present {1 10 2 20 3 30 4 40 5 50 6 60} 10] == 0}",
        "declaration": "proc is_key_present {dict key} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_key_present {1 10 2 20 3 30 4 40 5 50 6 60} 5] == 1}",
        "prompt_text": "Write a function to check whether the given key is present in the dictionary or not.",
        "prompt_explain": "Write a function to check whether the given key is present in the dictionary or not.\n>>> is_key_present {1 10 2 20 3 30 4 40 5 50 6 60} 5\n1",
        "func_title": "proc is_key_present {dict key}"
    },
    {
        "prompt": "# Write a function to calculate the harmonic sum of n-1.\n# >>> harmonic_sum 10\n# 2.9289682539682538\nproc harmonic_sum {n} {",
        "canonical_solution": "    if {$n < 2} {\n        return 1\n    } else {\n        return [expr {1.0 / $n + [harmonic_sum [expr {$n - 1}]]}]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[harmonic_sum 10] == 2.9289682539682538}\nassert {[harmonic_sum 4] == 2.083333333333333}\nassert {[harmonic_sum 7] == 2.5928571428571425}",
        "declaration": "proc harmonic_sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[harmonic_sum 10] == 2.9289682539682538}",
        "prompt_text": "Write a function to calculate the harmonic sum of n-1.",
        "prompt_explain": "Write a function to calculate the harmonic sum of n-1.\n>>> harmonic_sum 10\n2.9289682539682538",
        "func_title": "proc harmonic_sum {n}"
    },
    {
        "prompt": "# Write a Tcl function to count the total set bits from 1 to n.\n# >>> count_Set_Bits 16\n# 33\nproc count_Set_Bits {n} {",
        "canonical_solution": "    incr n\n    set powerOf2 2\n    set cnt [expr {$n / 2}]\n    while {$powerOf2 <= $n} {\n        set totalPairs [expr {$n / $powerOf2}]\n        set cnt [expr {$cnt + ($totalPairs / 2) * $powerOf2}]\n        if {$totalPairs & 1} {\n            set cnt [expr {$cnt + ($n % $powerOf2)}]\n        }\n        set powerOf2 [expr {$powerOf2 << 1}]\n    }\n    return $cnt\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Set_Bits 16] == 33}\nassert {[count_Set_Bits 2] == 2}\nassert {[count_Set_Bits 14] == 28}",
        "declaration": "proc count_Set_Bits {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Set_Bits 16] == 33}",
        "prompt_text": "Write a Tcl function to count the total set bits from 1 to n.",
        "prompt_explain": "Write a Tcl function to count the total set bits from 1 to n.\n>>> count_Set_Bits 16\n33",
        "func_title": "proc count_Set_Bits {n}"
    },
    {
        "prompt": "# Write a function to find the perimeter of a rhombus.\n# >>> rombus_perimeter 10\n# 40\nproc rombus_perimeter {a} {",
        "canonical_solution": "    set perimeter [expr {4 * $a}]\n    return $perimeter\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[rombus_perimeter 10] == 40}\nassert {[rombus_perimeter 5] == 20}\nassert {[rombus_perimeter 4] == 16}",
        "declaration": "proc rombus_perimeter {a} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[rombus_perimeter 10] == 40}",
        "prompt_text": "Write a function to find the perimeter of a rhombus.",
        "prompt_explain": "Write a function to find the perimeter of a rhombus.\n>>> rombus_perimeter 10\n40",
        "func_title": "proc rombus_perimeter {a}"
    },
    {
        "prompt": "# Given a list of numbers, calculate the standard deviation.\n# >>> sd_calc {4 2 5 8 6}\n# 2.23606797749979\nproc sd_calc {data} {",
        "canonical_solution": "    set n [llength $data]\n    if {$n <= 1} {\n        return 0.0\n    }\n    set mean [avg_calc $data]\n    set sd 0.0\n    foreach el $data {\n        set sd [expr {$sd + pow($el - $mean, 2)}]\n    }\n    set sd [expr {sqrt($sd / ($n - 1))}]\n    return $sd\n}\n\nproc avg_calc {ls} {\n    set n [llength $ls]\n    set mean 0.0\n    if {$n <= 1} {\n        return [lindex $ls 0]\n    }\n    foreach el $ls {\n        set mean [expr {$mean + $el}]\n    }\n    set mean [expr {$mean / $n}]\n    return $mean\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sd_calc {4 2 5 8 6}] == 2.23606797749979}\nassert {[sd_calc {1 2 3 4 5 6 7}] == 2.160246899469287}\nassert {[sd_calc {5 9 10 15 6 4}] == 4.070217029430577}",
        "declaration": "proc sd_calc {data} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sd_calc {4 2 5 8 6}] == 2.23606797749979}",
        "prompt_text": "Given a list of numbers, calculate the standard deviation.",
        "prompt_explain": "Given a list of numbers, calculate the standard deviation.\n>>> sd_calc {4 2 5 8 6}\n2.23606797749979",
        "func_title": "proc sd_calc {data}"
    },
    {
        "prompt": "# Given two lists of integers, return the count of positions where the elements are the same using the map function.\n# >>> count_same_pair {1 2 3 4 5 6 7 8} {2 2 3 1 2 6 7 9}\n# 4\nproc count_same_pair {nums1 nums2} {",
        "canonical_solution": "    set result 0\n    foreach a $nums1 b $nums2 {\n        if {$a == $b} {\n            incr result\n        }\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_same_pair {1 2 3 4 5 6 7 8} {2 2 3 1 2 6 7 9}] == 4}\nassert {[count_same_pair {0 1 2 -1 -5 6 0 -3 -2 3 4 6 8} {2 1 2 -1 -5 6 4 -3 -2 3 4 6 8}] == 11}\nassert {[count_same_pair {2 4 -6 -9 11 -12 14 -5 17} {2 1 2 -1 -5 6 4 -3 -2 3 4 6 8}] == 1}",
        "declaration": "proc count_same_pair {nums1 nums2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_same_pair {1 2 3 4 5 6 7 8} {2 2 3 1 2 6 7 9}] == 4}",
        "prompt_text": "Given two lists of integers, return the count of positions where the elements are the same using the map function.",
        "prompt_explain": "Given two lists of integers, return the count of positions where the elements are the same using the map function.\n>>> count_same_pair {1 2 3 4 5 6 7 8} {2 2 3 1 2 6 7 9}\n4",
        "func_title": "proc count_same_pair {nums1 nums2}"
    },
    {
        "prompt": "# Write a function to calculate the sum of all digits of the base to the specified power.\n# >>> power_base_sum 2 100\n# 115\nproc power_base_sum {base power} {",
        "canonical_solution": "    set result [expr {$base ** $power}]\n    set sum 0\n    foreach digit [split $result {}] {\n        incr sum $digit\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[power_base_sum 2 100] == 115}\nassert {[power_base_sum 8 10] == 37}\nassert {[power_base_sum 8 15] == 62}",
        "declaration": "proc power_base_sum {base power} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[power_base_sum 2 100] == 115}",
        "prompt_text": "Write a function to calculate the sum of all digits of the base to the specified power.",
        "prompt_explain": "Write a function to calculate the sum of all digits of the base to the specified power.\n>>> power_base_sum 2 100\n115",
        "func_title": "proc power_base_sum {base power}"
    },
    {
        "prompt": "# Write a function to find the lateral surface area of a cone.\n# >>> lateralsurface_cone 5 12\n# 204.20352248333654\nproc lateralsurface_cone {r h} {",
        "canonical_solution": "    set l [expr {sqrt($r * $r + $h * $h)}]\n    set LSA [expr {3.141592653589793 * $r * $l}]\n    return $LSA\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[lateralsurface_cone 5 12] == 204.20352248333654}\nassert {[lateralsurface_cone 10 15] == 566.3586699569488}\nassert {[lateralsurface_cone 19 17] == 1521.8090132193388}",
        "declaration": "proc lateralsurface_cone {r h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[lateralsurface_cone 5 12] == 204.20352248333654}",
        "prompt_text": "Write a function to find the lateral surface area of a cone.",
        "prompt_explain": "Write a function to find the lateral surface area of a cone.\n>>> lateralsurface_cone 5 12\n204.20352248333654",
        "func_title": "proc lateralsurface_cone {r h}"
    },
    {
        "prompt": "# Given a sorted list of integers and a number, return the index of the first occurrence of the number in the list. If the number is not found, return -1.\n# >>> find_first_occurrence {2 5 5 5 6 6 8 9 9 9} 5\n# 1\nproc find_first_occurrence {A x} {",
        "canonical_solution": "    set left 0\n    set right [expr {[llength $A] - 1}]\n    set result -1\n    while {$left <= $right} {\n        set mid [expr {($left + $right) / 2}]\n        if {$x == [lindex $A $mid]} {\n            set result $mid\n            set right [expr {$mid - 1}]\n        } elseif {$x < [lindex $A $mid]} {\n            set right [expr {$mid - 1}]\n        } else {\n            set left [expr {$mid + 1}]\n        }\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_first_occurrence {2 5 5 5 6 6 8 9 9 9} 5] == 1}\nassert {[find_first_occurrence {2 3 5 5 6 6 8 9 9 9} 5] == 2}\nassert {[find_first_occurrence {2 4 1 5 6 6 8 9 9 9} 6] == 4}",
        "declaration": "proc find_first_occurrence {A x} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_first_occurrence {2 5 5 5 6 6 8 9 9 9} 5] == 1}",
        "prompt_text": "Given a sorted list of integers and a number, return the index of the first occurrence of the number in the list. If the number is not found, return -1.",
        "prompt_explain": "Given a sorted list of integers and a number, return the index of the first occurrence of the number in the list. If the number is not found, return -1.\n>>> find_first_occurrence {2 5 5 5 6 6 8 9 9 9} 5\n1",
        "func_title": "proc find_first_occurrence {A x}"
    },
    {
        "prompt": "# Write a function to calculate the geometric sum of n-1.\n# >>> geometric_sum 7\n# 1.9921875\nproc geometric_sum {n} {",
        "canonical_solution": "    if {$n < 0} {\n        return 0\n    } else {\n        return [expr {1 / (pow(2, $n)) + [geometric_sum [expr {$n - 1}]]}]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[geometric_sum 7] == 1.9921875}\nassert {[geometric_sum 4] == 1.9375}\nassert {[geometric_sum 8] == 1.99609375}",
        "declaration": "proc geometric_sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[geometric_sum 7] == 1.9921875}",
        "prompt_text": "Write a function to calculate the geometric sum of n-1.",
        "prompt_explain": "Write a function to calculate the geometric sum of n-1.\n>>> geometric_sum 7\n1.9921875",
        "func_title": "proc geometric_sum {n}"
    },
    {
        "prompt": "# Write a Tcl function to find the index of the smallest triangular number with n digits.\n# Triangular numbers are numbers that can form an equilateral triangle.\n# The nth triangular number is given by the formula: Tn = n(n+1)/2.\n# >>> find_Index 2\n# 4\nproc find_Index {n} {",
        "canonical_solution": "    set x [expr {int(sqrt(2 * pow(10, ($n - 1))))}]\n    return $x\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Index 2] == 4}\nassert {[find_Index 3] == 14}\nassert {[find_Index 4] == 45}",
        "declaration": "proc find_Index {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Index 2] == 4}",
        "prompt_text": "Write a Tcl function to find the index of the smallest triangular number with n digits.",
        "prompt_explain": "Write a Tcl function to find the index of the smallest triangular number with n digits.\nTriangular numbers are numbers that can form an equilateral triangle.\nThe nth triangular number is given by the formula: Tn = n(n+1)/2.\n>>> find_Index 2\n4",
        "func_title": "proc find_Index {n}"
    },
    {
        "prompt": "# Write a function to calculate the area of a tetrahedron.\n# >>> area_tetrahedron 3\n# 15.588457268119894\nproc area_tetrahedron {side} {",
        "canonical_solution": "    set area [expr {sqrt(3) * ($side * $side)}]\n    return $area\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[area_tetrahedron 3] == 15.588457268119894}\nassert {[area_tetrahedron 20] == 692.8203230275509}\nassert {[area_tetrahedron 10] == 173.20508075688772}",
        "declaration": "proc area_tetrahedron {side} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[area_tetrahedron 3] == 15.588457268119894}",
        "prompt_text": "Write a function to calculate the area of a tetrahedron.",
        "prompt_explain": "Write a function to calculate the area of a tetrahedron.\n>>> area_tetrahedron 3\n15.588457268119894",
        "func_title": "proc area_tetrahedron {side}"
    },
    {
        "prompt": "# Given a list of integers, check if the list represents a min heap.\n# >>> check_min_heap {1 2 3 4 5 6} 0\n# 1\nproc check_min_heap {arr i} {",
        "canonical_solution": "    if {[expr {2 * $i + 2}] > [llength $arr]} {\n        return 1\n    }\n    set left_child [expr {[lindex $arr $i] <= [lindex $arr [expr {2 * $i + 1}]] && [check_min_heap $arr [expr {2 * $i + 1}]]}]\n    set right_child [expr {[expr {2 * $i + 2}] == [llength $arr] || ([lindex $arr $i] <= [lindex $arr [expr {2 * $i + 2}]] && [check_min_heap $arr [expr {2 * $i + 2}]])}]\n    return [expr {$left_child && $right_child}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_min_heap {1 2 3 4 5 6} 0] == 1}\nassert {[check_min_heap {2 3 4 5 10 15} 0] == 1}\nassert {[check_min_heap {2 10 4 5 3 15} 0] == 0}",
        "declaration": "proc check_min_heap {arr i} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_min_heap {1 2 3 4 5 6} 0] == 1}",
        "prompt_text": "Given a list of integers, check if the list represents a min heap.",
        "prompt_explain": "Given a list of integers, check if the list represents a min heap.\n>>> check_min_heap {1 2 3 4 5 6} 0\n1",
        "func_title": "proc check_min_heap {arr i}"
    },
    {
        "prompt": "# Write a function to find the nth jacobsthal number.\n# >>> jacobsthal_num 5\n# 11\nproc jacobsthal_num {n} {",
        "canonical_solution": "    if {$n == 0} {return 0}\n    if {$n == 1} {return 1}\n    set dp [list 0 1]\n    for {set i 2} {$i <= $n} {incr i} {\n        lappend dp [expr {[lindex $dp [expr {$i - 1}]] + 2 * [lindex $dp [expr {$i - 2}]]}]\n    }\n    return [lindex $dp $n]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[jacobsthal_num 5] == 11}\nassert {[jacobsthal_num 2] == 1}\nassert {[jacobsthal_num 4] == 5}",
        "declaration": "proc jacobsthal_num {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[jacobsthal_num 5] == 11}",
        "prompt_text": "Write a function to find the nth jacobsthal number.",
        "prompt_explain": "Write a function to find the nth jacobsthal number.\n>>> jacobsthal_num 5\n11",
        "func_title": "proc jacobsthal_num {n}"
    },
    {
        "prompt": "# Write a function to calculate arc length of an angle.\n# >>> arc_length 9 45\n# 3.5357142857142856\n# >>> arc_length 9 480\n# None\n# >>> arc_length 5 270\n# 11.785714285714285\nproc arc_length {d a} {",
        "canonical_solution": "    set pi [expr {22.0 / 7}]\n    if {$a >= 360} {\n        return \"None\"\n    }\n    set arclength [expr {($pi * $d) * ($a / 360.0)}]\n    return $arclength\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[arc_length 9 45] == 3.5357142857142856}\nassert {[arc_length 9 480] eq \"None\"}\nassert {[arc_length 5 270] == 11.785714285714285}",
        "declaration": "proc arc_length {d a} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[arc_length 9 45] == 3.5357142857142856}",
        "prompt_text": "Write a function to calculate arc length of an angle.",
        "prompt_explain": "Write a function to calculate arc length of an angle.\n>>> arc_length 9 45\n3.5357142857142856\n>>> arc_length 9 480\nNone\n>>> arc_length 5 270\n11.785714285714285",
        "func_title": "proc arc_length {d a}"
    },
    {
        "prompt": "# Write a function to check whether the given month number contains 30 days or not.\n# >>> check_monthnumber_number 6\n# 1\n# >>> check_monthnumber_number 2\n# 0\nproc check_monthnumber_number {monthnum3} {",
        "canonical_solution": "    if {$monthnum3 == 4 || $monthnum3 == 6 || $monthnum3 == 9 || $monthnum3 == 11} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_monthnumber_number 6] == 1}\nassert {[check_monthnumber_number 2] == 0}\nassert {[check_monthnumber_number 12] == 0}",
        "declaration": "proc check_monthnumber_number {monthnum3} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_monthnumber_number 6] == 1}",
        "prompt_text": "Write a function to check whether the given month number contains 30 days or not.",
        "prompt_explain": "Write a function to check whether the given month number contains 30 days or not.\n>>> check_monthnumber_number 6\n1\n>>> check_monthnumber_number 2\n0",
        "func_title": "proc check_monthnumber_number {monthnum3}"
    },
    {
        "prompt": "# Given a list of integers, return the count of pairs whose sum is equal to a given sum.\n# >>> get_Pairs_Count {1 1 1 1} 4 2\n# 6\nproc get_Pairs_Count {arr n sum} {",
        "canonical_solution": "    set count 0\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $n} {incr j} {\n            if {[expr {[lindex $arr $i] + [lindex $arr $j]}] == $sum} {\n                incr count\n            }\n        }\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Pairs_Count {1 1 1 1} 4 2] == 6}\nassert {[get_Pairs_Count {1 5 7 -1 5} 5 6] == 3}\nassert {[get_Pairs_Count {1 -2 3} 3 1] == 1}",
        "declaration": "proc get_Pairs_Count {arr n sum} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Pairs_Count {1 1 1 1} 4 2] == 6}",
        "prompt_text": "Given a list of integers, return the count of pairs whose sum is equal to a given sum.",
        "prompt_explain": "Given a list of integers, return the count of pairs whose sum is equal to a given sum.\n>>> get_Pairs_Count {1 1 1 1} 4 2\n6",
        "func_title": "proc get_Pairs_Count {arr n sum}"
    },
    {
        "prompt": "# Given a list of integers, find the sum of all odd length subarrays.\n# >>> Odd_Length_Sum {1 2 4}\n# 14\nproc Odd_Length_Sum {arr} {",
        "canonical_solution": "    set Sum 0\n    set l [llength $arr]\n    for {set i 0} {$i < $l} {incr i} {\n        set Sum [expr {$Sum + (((($i + 1) * ($l - $i) + 1) / 2) * [lindex $arr $i])}]\n    }\n    return $Sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Odd_Length_Sum {1 2 4}] == 14}\nassert {[Odd_Length_Sum {1 2 1 2}] == 15}\nassert {[Odd_Length_Sum {1 7}] == 8}",
        "declaration": "proc Odd_Length_Sum {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Odd_Length_Sum {1 2 4}] == 14}",
        "prompt_text": "Given a list of integers, find the sum of all odd length subarrays.",
        "prompt_explain": "Given a list of integers, find the sum of all odd length subarrays.\n>>> Odd_Length_Sum {1 2 4}\n14",
        "func_title": "proc Odd_Length_Sum {arr}"
    },
    {
        "prompt": "# Write a function to calculate the perimeter of a regular polygon.\n# >>> perimeter_polygon 4 20\n# 80\nproc perimeter_polygon {s l} {",
        "canonical_solution": "    set perimeter [expr {$s * $l}]\n    return $perimeter\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[perimeter_polygon 4 20] == 80}\nassert {[perimeter_polygon 10 15] == 150}\nassert {[perimeter_polygon 9 7] == 63}",
        "declaration": "proc perimeter_polygon {s l} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[perimeter_polygon 4 20] == 80}",
        "prompt_text": "Write a function to calculate the perimeter of a regular polygon.",
        "prompt_explain": "Write a function to calculate the perimeter of a regular polygon.\n>>> perimeter_polygon 4 20\n80",
        "func_title": "proc perimeter_polygon {s l}"
    },
    {
        "prompt": "# Given a list of integers, check whether every even index contains even numbers.\n# >>> even_position {3 2 1}\n# False\n# >>> even_position {1 2 3}\n# False\n# >>> even_position {2 1 4}\n# True\nproc even_position {nums} {",
        "canonical_solution": "    for {set i 0} {$i < [llength $nums]} {incr i} {\n        if {[expr {[lindex $nums $i] % 2}] != [expr {$i % 2}]} {\n            return 0\n        }\n    }\n    return 1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_position {3 2 1}] == 0}\nassert {[even_position {1 2 3}] == 0}\nassert {[even_position {2 1 4}] == 1}",
        "declaration": "proc even_position {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_position {3 2 1}] == 0}",
        "prompt_text": "Given a list of integers, check whether every even index contains even numbers.",
        "prompt_explain": "Given a list of integers, check whether every even index contains even numbers.\n>>> even_position {3 2 1}\nFalse\n>>> even_position {1 2 3}\nFalse\n>>> even_position {2 1 4}\nTrue",
        "func_title": "proc even_position {nums}"
    },
    {
        "prompt": "# Given a list of lists, return the count of lists in the given list.\n# >>> count_list {{1 3} {5 7} {9 11} {13 15 17}}\n# 4\nproc count_list {input_list} {",
        "canonical_solution": "    return [llength $input_list]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_list {{1 3} {5 7} {9 11} {13 15 17}}] == 4}\nassert {[count_list {{1 2} {2 3} {4 5}}] == 3}\nassert {[count_list {{1 0} {2 0}}] == 2}",
        "declaration": "proc count_list {input_list} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_list {{1 3} {5 7} {9 11} {13 15 17}}] == 4}",
        "prompt_text": "Given a list of lists, return the count of lists in the given list.",
        "prompt_explain": "Given a list of lists, return the count of lists in the given list.\n>>> count_list {{1 3} {5 7} {9 11} {13 15 17}}\n4",
        "func_title": "proc count_list {input_list}"
    },
    {
        "prompt": "# Given a sorted list of integers and an element, find the last position of the element in the list. Use binary search for efficiency.\n# >>> last {1 2 3} 1 3\n# 0\nproc last {arr x n} {",
        "canonical_solution": "    set low 0\n    set high [expr {$n - 1}]\n    set res -1\n    while {$low <= $high} {\n        set mid [expr {($low + $high) / 2}]\n        if {[lindex $arr $mid] > $x} {\n            set high [expr {$mid - 1}]\n        } elseif {[lindex $arr $mid] < $x} {\n            set low [expr {$mid + 1}]\n        } else {\n            set res $mid\n            set low [expr {$mid + 1}]\n        }\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[last {1 2 3} 1 3] == 0}\nassert {[last {1 1 1 2 3 4} 1 6] == 2}\nassert {[last {2 3 2 3 6 8 9} 3 7] == 3}",
        "declaration": "proc last {arr x n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[last {1 2 3} 1 3] == 0}",
        "prompt_text": "Given a sorted list of integers and an element, find the last position of the element in the list. Use binary search for efficiency.",
        "prompt_explain": "Given a sorted list of integers and an element, find the last position of the element in the list. Use binary search for efficiency.\n>>> last {1 2 3} 1 3\n0",
        "func_title": "proc last {arr x n}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements in the list.\n# >>> sum_list {1 2 3}\n# 6\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        set sum [expr {$sum + $num}]\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3}] == 6}\nassert {[sum_list {15 12 13 10}] == 50}\nassert {[sum_list {0 1 2}] == 3}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3}] == 6}",
        "prompt_text": "Given a list of integers, return the sum of all elements in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all elements in the list.\n>>> sum_list {1 2 3}\n6",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the number of rotations required to generate a sorted array.\n# >>> count_Rotation {3 2 1}\n# 1\nproc count_Rotation {arr n} {",
        "canonical_solution": "    for {set i 1} {$i < $n} {incr i} {\n        if {[lindex $arr $i] < [lindex $arr [expr {$i - 1}]]} {\n            return $i\n        }\n    }\n    return 0\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Rotation {3 2 1} 3] == 1}\nassert {[count_Rotation {4 5 1 2 3} 5] == 2}\nassert {[count_Rotation {7 8 9 1 2 3} 6] == 3}",
        "declaration": "proc count_Rotation {arr n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Rotation {3 2 1} 3] == 1}",
        "prompt_text": "Given a list of integers, return the number of rotations required to generate a sorted array.",
        "prompt_explain": "Given a list of integers, return the number of rotations required to generate a sorted array.\n>>> count_Rotation {3 2 1}\n1",
        "func_title": "proc count_Rotation {arr n}"
    },
    {
        "prompt": "# Given a list of integers, write a Tcl function to check whether the product of numbers is even or not.\n# >>> is_Product_Even {1 2 3}\n# 1\nproc is_Product_Even {arr} {",
        "canonical_solution": "    foreach num $arr {\n        if {($num % 2) == 0} {\n            return 1\n        }\n    }\n    return 0\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Product_Even {1 2 3}] == 1}\nassert {[is_Product_Even {1 2 1 4}] == 1}\nassert {[is_Product_Even {1 1}] == 0}",
        "declaration": "proc is_Product_Even {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Product_Even {1 2 3}] == 1}",
        "prompt_text": "Given a list of integers, write a Tcl function to check whether the product of numbers is even or not.",
        "prompt_explain": "Given a list of integers, write a Tcl function to check whether the product of numbers is even or not.\n>>> is_Product_Even {1 2 3}\n1",
        "func_title": "proc is_Product_Even {arr}"
    },
    {
        "prompt": "# Write a function to check if two lists of tuples are identical or not.\n# >>> check_identical {{10 4} {2 5}} {{10 4} {2 5}}\n# 1\nproc check_identical {test_list1 test_list2} {",
        "canonical_solution": "    return [expr {$test_list1 == $test_list2}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_identical {{10 4} {2 5}} {{10 4} {2 5}}] == 1}\nassert {[check_identical {{1 2} {3 7}} {{12 14} {12 45}}] == 0}\nassert {[check_identical {{2 14} {12 25}} {{2 14} {12 25}}] == 1}",
        "declaration": "proc check_identical {test_list1 test_list2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_identical {{10 4} {2 5}} {{10 4} {2 5}}] == 1}",
        "prompt_text": "Write a function to check if two lists of tuples are identical or not.",
        "prompt_explain": "Write a function to check if two lists of tuples are identical or not.\n>>> check_identical {{10 4} {2 5}} {{10 4} {2 5}}\n1",
        "func_title": "proc check_identical {test_list1 test_list2}"
    },
    {
        "prompt": "# Write a function to find the area of a rhombus.\n# >>> rombus_area 10 20\n# 100\nproc rombus_area {p q} {",
        "canonical_solution": "    set area [expr {($p * $q) / 2}]\n    return $area\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[rombus_area 10 20] == 100}\nassert {[rombus_area 10 5] == 25}\nassert {[rombus_area 4 2] == 4}",
        "declaration": "proc rombus_area {p q} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[rombus_area 10 20] == 100}",
        "prompt_text": "Write a function to find the area of a rhombus.",
        "prompt_explain": "Write a function to find the area of a rhombus.\n>>> rombus_area 10 20\n100",
        "func_title": "proc rombus_area {p q}"
    },
    {
        "prompt": "# Write a function to check whether the given month number contains 28 days or not.\n# >>> check_monthnum_number 2\n# True\n# >>> check_monthnum_number 1\n# False\nproc check_monthnum_number {monthnum1} {",
        "canonical_solution": "    if {$monthnum1 == 2} {\n        return True\n    } else {\n        return False\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_monthnum_number 2] == True}\nassert {[check_monthnum_number 1] == False}\nassert {[check_monthnum_number 3] == False}",
        "declaration": "proc check_monthnum_number {monthnum1} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_monthnum_number 2] == True}",
        "prompt_text": "Write a function to check whether the given month number contains 28 days or not.",
        "prompt_explain": "Write a function to check whether the given month number contains 28 days or not.\n>>> check_monthnum_number 2\nTrue\n>>> check_monthnum_number 1\nFalse",
        "func_title": "proc check_monthnum_number {monthnum1}"
    },
    {
        "prompt": "# Given a list of lists and a column index, return the sum of the elements in that column.\n# >>> sum_column {{1 2 3 2} {4 5 6 2} {7 8 9 5}} 0\n# 12\nproc sum_column {list1 C} {",
        "canonical_solution": "    set result 0\n    foreach row $list1 {\n        set result [expr {$result + [lindex $row $C]}]\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_column {{1 2 3 2} {4 5 6 2} {7 8 9 5}} 0] == 12}\nassert {[sum_column {{1 2 3 2} {4 5 6 2} {7 8 9 5}} 1] == 15}\nassert {[sum_column {{1 2 3 2} {4 5 6 2} {7 8 9 5}} 3] == 9}",
        "declaration": "proc sum_column {list1 C} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_column {{1 2 3 2} {4 5 6 2} {7 8 9 5}} 0] == 12}",
        "prompt_text": "Given a list of lists and a column index, return the sum of the elements in that column.",
        "prompt_explain": "Given a list of lists and a column index, return the sum of the elements in that column.\n>>> sum_column {{1 2 3 2} {4 5 6 2} {7 8 9 5}} 0\n12",
        "func_title": "proc sum_column {list1 C}"
    },
    {
        "prompt": "# Given a list of integers, count the number of equal element pairs from the given list.\n# >>> count_Pairs {1 1 1 1}\n# 6\nproc count_Pairs {arr} {",
        "canonical_solution": "    set cnt 0\n    set n [llength $arr]\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $n} {incr j} {\n            if {[lindex $arr $i] == [lindex $arr $j]} {\n                incr cnt\n            }\n        }\n    }\n    return $cnt\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Pairs {1 1 1 1}] == 6}\nassert {[count_Pairs {1 5 1}] == 1}\nassert {[count_Pairs {3 2 1 7 8 9}] == 0}",
        "declaration": "proc count_Pairs {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Pairs {1 1 1 1}] == 6}",
        "prompt_text": "Given a list of integers, count the number of equal element pairs from the given list.",
        "prompt_explain": "Given a list of integers, count the number of equal element pairs from the given list.\n>>> count_Pairs {1 1 1 1}\n6",
        "func_title": "proc count_Pairs {arr}"
    },
    {
        "prompt": "# Write a function to extract the maximum numeric value from a string by using regex.\n# >>> extract_max '100klh564abc365bg'\n# 564\nproc extract_max {input} {",
        "canonical_solution": "    set numbers [regexp -all -inline {\\d+} $input]\n    set max_num 0\n    foreach num $numbers {\n        if {$num > $max_num} {\n            set max_num $num\n        }\n    }\n    return $max_num\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[extract_max '100klh564abc365bg'] == 564}\nassert {[extract_max 'hello300how546mer231'] == 546}\nassert {[extract_max 'its233beenalong343journey234'] == 343}",
        "declaration": "proc extract_max {input} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[extract_max '100klh564abc365bg'] == 564}",
        "prompt_text": "Write a function to extract the maximum numeric value from a string by using regex.",
        "prompt_explain": "Write a function to extract the maximum numeric value from a string by using regex.\n>>> extract_max '100klh564abc365bg'\n564",
        "func_title": "proc extract_max {input}"
    },
    {
        "prompt": "# Write a Tcl function to find the slope of a line given two points (x1,y1) and (x2,y2).\n# >>> slope 4 2 2 5\n# -1.5\nproc slope {x1 y1 x2 y2} {",
        "canonical_solution": "    return [expr {double($y2 - $y1) / ($x2 - $x1)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[slope 4 2 2 5] == -1.5}\nassert {[slope 2 4 4 6] == 1}\nassert {[slope 1 2 4 2] == 0}",
        "declaration": "proc slope {x1 y1 x2 y2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[slope 4 2 2 5] == -1.5}",
        "prompt_text": "Write a Tcl function to find the slope of a line given two points (x1,y1) and (x2,y2).",
        "prompt_explain": "Write a Tcl function to find the slope of a line given two points (x1,y1) and (x2,y2).\n>>> slope 4 2 2 5\n-1.5",
        "func_title": "proc slope {x1 y1 x2 y2}"
    },
    {
        "prompt": "# Write a Tcl function to find the cube sum of first n odd natural numbers.\n# >>> cube_Sum 2\n# 28\nproc cube_Sum {n} {",
        "canonical_solution": "    set sum 0\n    for {set i 0} {$i < $n} {incr i} {\n        set odd [expr {2 * $i + 1}]\n        set sum [expr {$sum + $odd * $odd * $odd}]\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[cube_Sum 2] == 28}\nassert {[cube_Sum 3] == 153}\nassert {[cube_Sum 4] == 496}",
        "declaration": "proc cube_Sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[cube_Sum 2] == 28}",
        "prompt_text": "Write a Tcl function to find the cube sum of first n odd natural numbers.",
        "prompt_explain": "Write a Tcl function to find the cube sum of first n odd natural numbers.\n>>> cube_Sum 2\n28",
        "func_title": "proc cube_Sum {n}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the roots of a quadratic equation are numerically equal but opposite in sign or not.\n# >>> Check_Solution 2 0 -1\n# Yes\n# >>> Check_Solution 1 -5 6\n# No\nproc Check_Solution {a b c} {",
        "canonical_solution": "    if {$b == 0} {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Check_Solution 2 0 -1] eq \"Yes\"}\nassert {[Check_Solution 1 -5 6] eq \"No\"}\nassert {[Check_Solution 2 0 2] eq \"Yes\"}",
        "declaration": "proc Check_Solution {a b c} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Check_Solution 2 0 -1] eq \"Yes\"}",
        "prompt_text": "Write a Tcl function to check whether the roots of a quadratic equation are numerically equal but opposite in sign or not.",
        "prompt_explain": "Write a Tcl function to check whether the roots of a quadratic equation are numerically equal but opposite in sign or not.\n>>> Check_Solution 2 0 -1\nYes\n>>> Check_Solution 1 -5 6\nNo",
        "func_title": "proc Check_Solution {a b c}"
    },
    {
        "prompt": "# Given a list of integers, return the number of inversions in the list.\n# An inversion is a pair of indices (i, j) such that i < j and list[i] > list[j].\n# >>> get_inv_count {1 20 6 4 5}\n# 5\nproc get_inv_count {arr} {",
        "canonical_solution": "    set inv_count 0\n    set n [llength $arr]\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $n} {incr j} {\n            if {[lindex $arr $i] > [lindex $arr $j]} {\n                incr inv_count\n            }\n        }\n    }\n    return $inv_count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_inv_count {1 20 6 4 5}] == 5}\nassert {[get_inv_count {8 4 2 1}] == 6}\nassert {[get_inv_count {3 1 2}] == 2}",
        "declaration": "proc get_inv_count {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_inv_count {1 20 6 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the number of inversions in the list. An inversion is a pair of indices (i, j) such that i < j and list[i] > list[j].",
        "prompt_explain": "Given a list of integers, return the number of inversions in the list. An inversion is a pair of indices (i, j) such that i < j and list[i] > list[j].\n>>> get_inv_count {1 20 6 4 5}\n5",
        "func_title": "proc get_inv_count {arr}"
    },
    {
        "prompt": "# Given a number, return the number of digits in the factorial of that number.\n# >>> find_Digits 7\n# 4\nproc find_Digits {n} {",
        "canonical_solution": "    if {$n < 0} {\n        return 0\n    }\n    if {$n <= 1} {\n        return 1\n    }\n    set x [expr {($n * log10($n / exp(1))) + (log10(2 * 3.141592653589793 * $n) / 2.0)}]\n    return [expr {int($x) + 1}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Digits 7] == 4}\nassert {[find_Digits 5] == 3}\nassert {[find_Digits 4] == 2}",
        "declaration": "proc find_Digits {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Digits 7] == 4}",
        "prompt_text": "Given a number, return the number of digits in the factorial of that number.",
        "prompt_explain": "Given a number, return the number of digits in the factorial of that number.\n>>> find_Digits 7\n4",
        "func_title": "proc find_Digits {n}"
    },
    {
        "prompt": "# Given two lists of arrival and departure times of trains/buses, find the minimum number of platforms required for the station.\n# >>> find_platform {900 940 950 1100 1500 1800} {910 1200 1120 1130 1900 2000} 6\n# 3\nproc find_platform {arr dep n} {",
        "canonical_solution": "    set arr [lsort -integer $arr]\n    set dep [lsort -integer $dep]\n    set plat_needed 1\n    set result 1\n    set i 1\n    set j 0\n    while {$i < $n && $j < $n} {\n        if {[lindex $arr $i] <= [lindex $dep $j]} {\n            incr plat_needed\n            incr i\n        } else {\n            incr plat_needed -1\n            incr j\n        }\n        if {$plat_needed > $result} {\n            set result $plat_needed\n        }\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_platform {900 940 950 1100 1500 1800} {910 1200 1120 1130 1900 2000} 6] == 3}\nassert {[find_platform {100 200 300 400} {700 800 900 1000} 4] == 4}\nassert {[find_platform {5 6 7 8} {4 3 2 1} 4] == 1}",
        "declaration": "proc find_platform {arr dep n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_platform {900 940 950 1100 1500 1800} {910 1200 1120 1130 1900 2000} 6] == 3}",
        "prompt_text": "Given two lists of arrival and departure times of trains/buses, find the minimum number of platforms required for the station.",
        "prompt_explain": "Given two lists of arrival and departure times of trains/buses, find the minimum number of platforms required for the station.\n>>> find_platform {900 940 950 1100 1500 1800} {910 1200 1120 1130 1900 2000} 6\n3",
        "func_title": "proc find_platform {arr dep n}"
    },
    {
        "prompt": "# Write a function to find the area of a trapezium.\n# >>> area_trapezium 6 9 4\n# 30\nproc area_trapezium {base1 base2 height} {",
        "canonical_solution": "    set area [expr {0.5 * ($base1 + $base2) * $height}]\n    return $area\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[area_trapezium 6 9 4] == 30}\nassert {[area_trapezium 10 20 30] == 450}\nassert {[area_trapezium 15 25 35] == 700}",
        "declaration": "proc area_trapezium {base1 base2 height} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[area_trapezium 6 9 4] == 30}",
        "prompt_text": "Write a function to find the area of a trapezium.",
        "prompt_explain": "Write a function to find the area of a trapezium.\n>>> area_trapezium 6 9 4\n30",
        "func_title": "proc area_trapezium {base1 base2 height}"
    },
    {
        "prompt": "# Given a number, find the sum of all its prime divisors.\n# >>> Sum 60\n# 10\nproc Sum {N} {",
        "canonical_solution": "    set SumOfPrimeDivisors [lrepeat [expr {$N + 1}] 0]\n    for {set i 2} {$i <= $N} {incr i} {\n        if {[lindex $SumOfPrimeDivisors $i] == 0} {\n            for {set j $i} {$j <= $N} {incr j $i} {\n                lset SumOfPrimeDivisors $j [expr {[lindex $SumOfPrimeDivisors $j] + $i}]\n            }\n        }\n    }\n    return [lindex $SumOfPrimeDivisors $N]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Sum 60] == 10}\nassert {[Sum 39] == 16}\nassert {[Sum 40] == 7}",
        "declaration": "proc Sum {N} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Sum 60] == 10}",
        "prompt_text": "Given a number, find the sum of all its prime divisors.",
        "prompt_explain": "Given a number, find the sum of all its prime divisors.\n>>> Sum 60\n10",
        "func_title": "proc Sum {N}"
    },
    {
        "prompt": "# Given three angles, check if a triangle of positive area is possible with the given angles.\n# >>> is_triangleexists 50 60 70\n# 1\nproc is_triangleexists {a b c} {",
        "canonical_solution": "    if {$a != 0 && $b != 0 && $c != 0 && ($a + $b + $c) == 180} {\n        if {($a + $b) >= $c || ($b + $c) >= $a || ($a + $c) >= $b} {\n            return 1\n        } else {\n            return 0\n        }\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_triangleexists 50 60 70] == 1}\nassert {[is_triangleexists 90 45 45] == 1}\nassert {[is_triangleexists 150 30 70] == 0}",
        "declaration": "proc is_triangleexists {a b c} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_triangleexists 50 60 70] == 1}",
        "prompt_text": "Given three angles, check if a triangle of positive area is possible with the given angles.",
        "prompt_explain": "Given three angles, check if a triangle of positive area is possible with the given angles.\n>>> is_triangleexists 50 60 70\n1",
        "func_title": "proc is_triangleexists {a b c}"
    },
    {
        "prompt": "# Given two numbers N and Sum, find the sum of the inverse of the divisors of N, rounded to two decimal places.\n# >>> Sum_of_Inverse_Divisors 6 12\n# 2\nproc Sum_of_Inverse_Divisors {N Sum} {",
        "canonical_solution": "    set ans [expr {double($Sum) / double($N)}]\n    return [format \"%.2f\" $ans]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Sum_of_Inverse_Divisors 6 12] == 2}\nassert {[Sum_of_Inverse_Divisors 9 13] == 1.44}\nassert {[Sum_of_Inverse_Divisors 1 4] == 4}",
        "declaration": "proc Sum_of_Inverse_Divisors {N Sum} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Sum_of_Inverse_Divisors 6 12] == 2}",
        "prompt_text": "Given two numbers N and Sum, find the sum of the inverse of the divisors of N, rounded to two decimal places.",
        "prompt_explain": "Given two numbers N and Sum, find the sum of the inverse of the divisors of N, rounded to two decimal places.\n>>> Sum_of_Inverse_Divisors 6 12\n2",
        "func_title": "proc Sum_of_Inverse_Divisors {N Sum}"
    },
    {
        "prompt": "# Write a Tcl function to find the sum of odd factors of a number.\n# >>> sum_of_odd_Factors 30\n# 24\nproc sum_of_odd_Factors {n} {",
        "canonical_solution": "    set res 1\n    while {$n % 2 == 0} {\n        set n [expr {$n / 2}]\n    }\n    for {set i 3} {$i <= [expr {sqrt($n) + 1}]} {incr i 2} {\n        set count 0\n        set curr_sum 1\n        set curr_term 1\n        while {$n % $i == 0} {\n            incr count\n            set n [expr {$n / $i}]\n            set curr_term [expr {$curr_term * $i}]\n            set curr_sum [expr {$curr_sum + $curr_term}]\n        }\n        set res [expr {$res * $curr_sum}]\n    }\n    if {$n >= 2} {\n        set res [expr {$res * (1 + $n)}]\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_of_odd_Factors 30] == 24}\nassert {[sum_of_odd_Factors 18] == 13}\nassert {[sum_of_odd_Factors 2] == 1}",
        "declaration": "proc sum_of_odd_Factors {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_of_odd_Factors 30] == 24}",
        "prompt_text": "Write a Tcl function to find the sum of odd factors of a number.",
        "prompt_explain": "Write a Tcl function to find the sum of odd factors of a number.\n>>> sum_of_odd_Factors 30\n24",
        "func_title": "proc sum_of_odd_Factors {n}"
    },
    {
        "prompt": "# Write a Tcl function to check for even parity of a given number.\n# >>> check_Even_Parity 10\n# 1\n# >>> check_Even_Parity 11\n# 0\nproc check_Even_Parity {x} {",
        "canonical_solution": "    set parity 0\n    while {$x != 0} {\n        set x [expr {$x & ($x - 1)}]\n        incr parity\n    }\n    return [expr {$parity % 2 == 0 ? 1 : 0}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_Even_Parity 10] == 1}\nassert {[check_Even_Parity 11] == 0}\nassert {[check_Even_Parity 18] == 1}",
        "declaration": "proc check_Even_Parity {x} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_Even_Parity 10] == 1}",
        "prompt_text": "Write a Tcl function to check for even parity of a given number.",
        "prompt_explain": "Write a Tcl function to check for even parity of a given number.\n>>> check_Even_Parity 10\n1\n>>> check_Even_Parity 11\n0",
        "func_title": "proc check_Even_Parity {x}"
    },
    {
        "prompt": "# Given a text and an integer n, return a list of tuples containing the n most common words and their counts in the text.\n# >>> n_common_words \"python is a programming language\" 1\n# {python 1}\nproc n_common_words {text n} {",
        "canonical_solution": "    set words [regexp -all -inline {\\w+} $text]\n    set word_counts {}\n    foreach word $words {\n        dict incr word_counts $word\n    }\n    set sorted_counts [lsort -stride 2 -index 1 -integer -decreasing $word_counts]\n    set result {}\n    for {set i 0} {$i < $n && $i < [llength $sorted_counts]} {incr i} {\n        lappend result [lrange $sorted_counts [expr {$i * 2}] [expr {$i * 2 + 1}]]\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[n_common_words \"python is a programming language\" 1] eq {{python 1}}}\nassert {[n_common_words \"python is a programming language\" 1] eq {{python 1}}}\nassert {[n_common_words \"python is a programming language\" 5] eq {{python 1} {is 1} {a 1} {programming 1} {language 1}}}",
        "declaration": "proc n_common_words {text n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[n_common_words \"python is a programming language\" 1] eq {{python 1}}}",
        "prompt_text": "Given a text and an integer n, return a list of tuples containing the n most common words and their counts in the text.",
        "prompt_explain": "Given a text and an integer n, return a list of tuples containing the n most common words and their counts in the text.\n>>> n_common_words \"python is a programming language\" 1\n{python 1}",
        "func_title": "proc n_common_words {text n}"
    },
    {
        "prompt": "# Given a list of lists, remove sublists that are outside a given range.\n# >>> remove_list_range {{2} {0} {1 2 3} {0 1 2 3 6 7} {9 11} {13 14 15 17}} 13 17\n# {{13 14 15 17}}\nproc remove_list_range {list1 leftrange rightrange} {",
        "canonical_solution": "    set result {}\n    foreach sublist $list1 {\n        set min [lindex [lsort -integer $sublist] 0]\n        set max [lindex [lsort -integer $sublist] end]\n        if {$min >= $leftrange && $max <= $rightrange} {\n            lappend result $sublist\n        }\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[remove_list_range {{2} {0} {1 2 3} {0 1 2 3 6 7} {9 11} {13 14 15 17}} 13 17] eq {{13 14 15 17}}}\nassert {[remove_list_range {{2} {0} {1 2 3} {0 1 2 3 6 7} {9 11} {13 14 15 17}} 1 3] eq {{2} {1 2 3}}}\nassert {[remove_list_range {{2} {0} {1 2 3} {0 1 2 3 6 7} {9 11} {13 14 15 17}} 0 7] eq {{2} {0} {1 2 3} {0 1 2 3 6 7}}}",
        "declaration": "proc remove_list_range {list1 leftrange rightrange} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[remove_list_range {{2} {0} {1 2 3} {0 1 2 3 6 7} {9 11} {13 14 15 17}} 13 17] eq {{13 14 15 17}}}",
        "prompt_text": "Given a list of lists, remove sublists that are outside a given range.",
        "prompt_explain": "Given a list of lists, remove sublists that are outside a given range.\n>>> remove_list_range {{2} {0} {1 2 3} {0 1 2 3 6 7} {9 11} {13 14 15 17}} 13 17\n{{13 14 15 17}}",
        "func_title": "proc remove_list_range {list1 leftrange rightrange}"
    },
    {
        "prompt": "# Given a list of numbers, calculate the sum of the positive numbers using a lambda function.\n# >>> sum_positivenum {2 4 -6 -9 11 -12 14 -5 17}\n# 48\nproc sum_positivenum {nums} {",
        "canonical_solution": "    set positive_nums [lmap num $nums {if {$num > 0} {set num}}]\n    return [expr [join $positive_nums +]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_positivenum {2 4 -6 -9 11 -12 14 -5 17}] == 48}\nassert {[sum_positivenum {10 15 -14 13 -18 12 -20}] == 50}\nassert {[sum_positivenum {19 -65 57 39 152 -639 121 44 90 -190}] == 522}",
        "declaration": "proc sum_positivenum {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_positivenum {2 4 -6 -9 11 -12 14 -5 17}] == 48}",
        "prompt_text": "Given a list of numbers, calculate the sum of the positive numbers using a lambda function.",
        "prompt_explain": "Given a list of numbers, calculate the sum of the positive numbers using a lambda function.\n>>> sum_positivenum {2 4 -6 -9 11 -12 14 -5 17}\n48",
        "func_title": "proc sum_positivenum {nums}"
    },
    {
        "prompt": "# Write a function to solve the fibonacci sequence using recursion.\n# >>> fibonacci 7\n# 13\nproc fibonacci {n} {",
        "canonical_solution": "    if {$n == 1 || $n == 2} {\n        return 1\n    } else {\n        return [expr {[fibonacci [expr {$n - 1}]] + [fibonacci [expr {$n - 2}]]}]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[fibonacci 7] == 13}\nassert {[fibonacci 8] == 21}\nassert {[fibonacci 9] == 34}",
        "declaration": "proc fibonacci {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[fibonacci 7] == 13}",
        "prompt_text": "Write a function to solve the fibonacci sequence using recursion.",
        "prompt_explain": "Write a function to solve the fibonacci sequence using recursion.\n>>> fibonacci 7\n13",
        "func_title": "proc fibonacci {n}"
    },
    {
        "prompt": "# Write a Tcl function to check whether all the bits are within a given range or not.\n# >>> all_Bits_Set_In_The_Given_Range 10 2 1\n# 1\n# >>> all_Bits_Set_In_The_Given_Range 5 2 4\n# 0\n# >>> all_Bits_Set_In_The_Given_Range 22 2 3\n# 1\nproc all_Bits_Set_In_The_Given_Range {n l r} {",
        "canonical_solution": "    set num [expr {((1 << $r) - 1) ^ ((1 << ($l - 1)) - 1)}]\n    set new_num [expr {$n & $num}]\n    if {$num == $new_num} {\n        return 1\n    }\n    return 0\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[all_Bits_Set_In_The_Given_Range 10 2 1] == 1}\nassert {[all_Bits_Set_In_The_Given_Range 5 2 4] == 0}\nassert {[all_Bits_Set_In_The_Given_Range 22 2 3] == 1}",
        "declaration": "proc all_Bits_Set_In_The_Given_Range {n l r} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[all_Bits_Set_In_The_Given_Range 10 2 1] == 1}",
        "prompt_text": "Write a Tcl function to check whether all the bits are within a given range or not.",
        "prompt_explain": "Write a Tcl function to check whether all the bits are within a given range or not.\n>>> all_Bits_Set_In_The_Given_Range 10 2 1\n1\n>>> all_Bits_Set_In_The_Given_Range 5 2 4\n0\n>>> all_Bits_Set_In_The_Given_Range 22 2 3\n1",
        "func_title": "proc all_Bits_Set_In_The_Given_Range {n l r}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the two given strings are isomorphic to each other or not.\n# >>> is_Isomorphic \"paper\" \"title\"\n# 1\n# >>> is_Isomorphic \"ab\" \"ba\"\n# 1\n# >>> is_Isomorphic \"ab\" \"aa\"\n# 0\nproc is_Isomorphic {str1 str2} {",
        "canonical_solution": "    if {[string length $str1] != [string length $str2]} {\n        return 0\n    }\n    set dict_str1 {}\n    set dict_str2 {}\n    for {set i 0} {$i < [string length $str1]} {incr i} {\n        set char1 [string index $str1 $i]\n        set char2 [string index $str2 $i]\n        if {![dict exists $dict_str1 $char1]} {\n            dict set dict_str1 $char1 $i\n        }\n        if {![dict exists $dict_str2 $char2]} {\n            dict set dict_str2 $char2 $i\n        }\n        if {[dict get $dict_str1 $char1] != [dict get $dict_str2 $char2]} {\n            return 0\n        }\n    }\n    return 1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Isomorphic \"paper\" \"title\"] == 1}\nassert {[is_Isomorphic \"ab\" \"ba\"] == 1}\nassert {[is_Isomorphic \"ab\" \"aa\"] == 0}",
        "declaration": "proc is_Isomorphic {str1 str2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Isomorphic \"paper\" \"title\"] == 1}",
        "prompt_text": "Write a Tcl function to check whether the two given strings are isomorphic to each other or not.",
        "prompt_explain": "Write a Tcl function to check whether the two given strings are isomorphic to each other or not.\n>>> is_Isomorphic \"paper\" \"title\"\n1\n>>> is_Isomorphic \"ab\" \"ba\"\n1\n>>> is_Isomorphic \"ab\" \"aa\"\n0",
        "func_title": "proc is_Isomorphic {str1 str2}"
    },
    {
        "prompt": "# Given a list of numbers, return the sum of all the numbers in the list divided by the length of the list.\n# >>> sum_num {8 2 3 0 7}\n# 4.0\nproc sum_num {numbers} {",
        "canonical_solution": "    set total 0\n    foreach x $numbers {\n        set total [expr {$total + $x}]\n    }\n    return [expr {$total / [llength $numbers]}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_num {8 2 3 0 7}] == 4.0}\nassert {[sum_num {-10 -20 -30}] == -20.0}\nassert {[sum_num {19 15 18}] == 17.333333333333332}",
        "declaration": "proc sum_num {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_num {8 2 3 0 7}] == 4.0}",
        "prompt_text": "Given a list of numbers, return the sum of all the numbers in the list divided by the length of the list.",
        "prompt_explain": "Given a list of numbers, return the sum of all the numbers in the list divided by the length of the list.\n>>> sum_num {8 2 3 0 7}\n4.0",
        "func_title": "proc sum_num {numbers}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the given number is odd or not using bitwise operator.\n# >>> is_odd 5\n# 1\n# >>> is_odd 6\n# 0\nproc is_odd {n} {",
        "canonical_solution": "    if {($n & 1) == 1} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_odd 5] == 1}\nassert {[is_odd 6] == 0}\nassert {[is_odd 7] == 1}",
        "declaration": "proc is_odd {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_odd 5] == 1}",
        "prompt_text": "Write a Tcl function to check whether the given number is odd or not using bitwise operator.",
        "prompt_explain": "Write a Tcl function to check whether the given number is odd or not using bitwise operator.\n>>> is_odd 5\n1\n>>> is_odd 6\n0",
        "func_title": "proc is_odd {n}"
    },
    {
        "prompt": "# Given two sorted arrays, find the index of the extra element present in one of them.\n# >>> find_Extra {1 2 3 4} {1 2 3}\n# 3\nproc find_Extra {arr1 arr2 n} {",
        "canonical_solution": "    for {set i 0} {$i < $n} {incr i} {\n        if {[lindex $arr1 $i] != [lindex $arr2 $i]} {\n            return $i\n        }\n    }\n    return $n\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Extra {1 2 3 4} {1 2 3} 3] == 3}\nassert {[find_Extra {2 4 6 8 10} {2 4 6 8} 4] == 4}\nassert {[find_Extra {1 3 5 7 9 11} {1 3 5 7 9} 5] == 5}",
        "declaration": "proc find_Extra {arr1 arr2 n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Extra {1 2 3 4} {1 2 3} 3] == 3}",
        "prompt_text": "Given two sorted arrays, find the index of the extra element present in one of them.",
        "prompt_explain": "Given two sorted arrays, find the index of the extra element present in one of them.\n>>> find_Extra {1 2 3 4} {1 2 3}\n3",
        "func_title": "proc find_Extra {arr1 arr2 n}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the given two numbers have the same number of digits or not.\n# >>> same_Length 12 1\n# 0\n# >>> same_Length 2 2\n# 1\n# >>> same_Length 10 20\n# 1\nproc same_Length {A B} {",
        "canonical_solution": "    while {$A > 0 && $B > 0} {\n        set A [expr {$A / 10}]\n        set B [expr {$B / 10}]\n    }\n    if {$A == 0 && $B == 0} {\n        return 1\n    }\n    return 0\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[same_Length 12 1] == 0}\nassert {[same_Length 2 2] == 1}\nassert {[same_Length 10 20] == 1}",
        "declaration": "proc same_Length {A B} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[same_Length 12 1] == 0}",
        "prompt_text": "Write a Tcl function to check whether the given two numbers have the same number of digits or not.",
        "prompt_explain": "Write a Tcl function to check whether the given two numbers have the same number of digits or not.\n>>> same_Length 12 1\n0\n>>> same_Length 2 2\n1\n>>> same_Length 10 20\n1",
        "func_title": "proc same_Length {A B}"
    },
    {
        "prompt": "# Given a list of integers, find the maximum sum of subsequences with no adjacent elements.\n# >>> max_sum_subseq {1 2 9 4 5 0 4 11 6}\n# 26\nproc max_sum_subseq {A} {",
        "canonical_solution": "    set n [llength $A]\n    if {$n == 1} {\n        return [lindex $A 0]\n    }\n    set look_up [list]\n    for {set i 0} {$i < $n} {incr i} {\n        lappend look_up 0\n    }\n    lset look_up 0 [lindex $A 0]\n    lset look_up 1 [expr {max([lindex $A 0], [lindex $A 1])}]\n    for {set i 2} {$i < $n} {incr i} {\n        set temp [expr {max([lindex $look_up [expr {$i - 1}]], [lindex $look_up [expr {$i - 2}]] + [lindex $A $i])}]\n        lset look_up $i [expr {max($temp, [lindex $A $i])}]\n    }\n    return [lindex $look_up [expr {$n - 1}]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sum_subseq {1 2 9 4 5 0 4 11 6}] == 26}\nassert {[max_sum_subseq {1 2 9 5 6 0 5 12 7}] == 28}\nassert {[max_sum_subseq {1 3 10 5 6 0 6 14 21}] == 44}",
        "declaration": "proc max_sum_subseq {A} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sum_subseq {1 2 9 4 5 0 4 11 6}] == 26}",
        "prompt_text": "Given a list of integers, find the maximum sum of subsequences with no adjacent elements.",
        "prompt_explain": "Given a list of integers, find the maximum sum of subsequences with no adjacent elements.\n>>> max_sum_subseq {1 2 9 4 5 0 4 11 6}\n26",
        "func_title": "proc max_sum_subseq {A}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the word is present in a given sentence or not.\n# >>> is_Word_Present \"machine learning\" \"machine\"\n# 1\nproc is_Word_Present {sentence word} {",
        "canonical_solution": "    set words [split $sentence \" \"]\n    foreach w $words {\n        if {$w eq $word} {\n            return 1\n        }\n    }\n    return 0\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Word_Present \"machine learning\" \"machine\"] == 1}\nassert {[is_Word_Present \"easy\" \"fun\"] == 0}\nassert {[is_Word_Present \"python language\" \"code\"] == 0}",
        "declaration": "proc is_Word_Present {sentence word} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Word_Present \"machine learning\" \"machine\"] == 1}",
        "prompt_text": "Write a Tcl function to check whether the word is present in a given sentence or not.",
        "prompt_explain": "Write a Tcl function to check whether the word is present in a given sentence or not.\n>>> is_Word_Present \"machine learning\" \"machine\"\n1",
        "func_title": "proc is_Word_Present {sentence word}"
    },
    {
        "prompt": "# Write a function to find the smallest multiple of the first n numbers.\n# >>> smallest_multiple 13\n# 360360\nproc smallest_multiple {n} {",
        "canonical_solution": "    if {$n <= 2} {\n        return $n\n    }\n    set i [expr {$n * 2}]\n    set factors {}\n    for {set number $n} {$number > 1} {incr number -1} {\n        if {[expr {$number * 2}] > $n} {\n            lappend factors $number\n        }\n    }\n    while {1} {\n        foreach a $factors {\n            if {[expr {$i % $a}] != 0} {\n                set i [expr {$i + $n}]\n                break\n            }\n            if {$a == [lindex $factors end] && [expr {$i % $a}] == 0} {\n                return $i\n            }\n        }\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smallest_multiple 13] == 360360}\nassert {[smallest_multiple 2] == 2}\nassert {[smallest_multiple 1] == 1}",
        "declaration": "proc smallest_multiple {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smallest_multiple 13] == 360360}",
        "prompt_text": "Write a function to find the smallest multiple of the first n numbers.",
        "prompt_explain": "Write a function to find the smallest multiple of the first n numbers.\n>>> smallest_multiple 13\n360360",
        "func_title": "proc smallest_multiple {n}"
    },
    {
        "prompt": "# Write a Tcl function to count the total unset bits from 1 to n.\n# >>> count_Unset_Bits 2\n# 1\n# >>> count_Unset_Bits 5\n# 4\n# >>> count_Unset_Bits 14\n# 17\nproc count_Unset_Bits {n} {",
        "canonical_solution": "    set cnt 0\n    for {set i 1} {$i <= $n} {incr i} {\n        set temp $i\n        while {$temp != 0} {\n            if {[expr {$temp % 2}] == 0} {\n                incr cnt\n            }\n            set temp [expr {$temp / 2}]\n        }\n    }\n    return $cnt\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Unset_Bits 2] == 1}\nassert {[count_Unset_Bits 5] == 4}\nassert {[count_Unset_Bits 14] == 17}",
        "declaration": "proc count_Unset_Bits {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Unset_Bits 2] == 1}",
        "prompt_text": "Write a Tcl function to count the total unset bits from 1 to n.",
        "prompt_explain": "Write a Tcl function to count the total unset bits from 1 to n.\n>>> count_Unset_Bits 2\n1\n>>> count_Unset_Bits 5\n4\n>>> count_Unset_Bits 14\n17",
        "func_title": "proc count_Unset_Bits {n}"
    },
    {
        "prompt": "# Write a function to find the previous palindrome of a specified number.\n# >>> previous_palindrome 99\n# 88\nproc previous_palindrome {num} {",
        "canonical_solution": "    for {set x [expr {$num - 1}]} {$x > 0} {incr x -1} {\n        if {$x == [string reverse $x]} {\n            return $x\n        }\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[previous_palindrome 99] == 88}\nassert {[previous_palindrome 1221] == 1111}\nassert {[previous_palindrome 120] == 111}",
        "declaration": "proc previous_palindrome {num} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[previous_palindrome 99] == 88}",
        "prompt_text": "Write a function to find the previous palindrome of a specified number.",
        "prompt_explain": "Write a function to find the previous palindrome of a specified number.\n>>> previous_palindrome 99\n88",
        "func_title": "proc previous_palindrome {num}"
    },
    {
        "prompt": "# Write a function to validate a Gregorian date.\n# >>> check_date 11 11 2002\n# 1\n# >>> check_date 13 11 2002\n# 0\n# >>> check_date '11' '11' '2002'\n# 1\nproc check_date {m d y} {",
        "canonical_solution": "    if {[catch {clock scan \"$y-$m-$d\" -format \"%Y-%m-%d\"} result]} {\n        return 0\n    } else {\n        return 1\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_date 11 11 2002] == 1}\nassert {[check_date 13 11 2002] == 0}\nassert {[check_date '11' '11' '2002'] == 1}",
        "declaration": "proc check_date {m d y} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_date 11 11 2002] == 1}",
        "prompt_text": "Write a function to validate a Gregorian date.",
        "prompt_explain": "Write a function to validate a Gregorian date.\n>>> check_date 11 11 2002\n1\n>>> check_date 13 11 2002\n0\n>>> check_date '11' '11' '2002'\n1",
        "func_title": "proc check_date {m d y}"
    },
    {
        "prompt": "# Write a function to check for a number at the end of a string.\n# >>> end_num 'abcdef'\n# False\n# >>> end_num 'abcdef7'\n# True\n# >>> end_num 'abc'\n# False\nproc end_num {string} {",
        "canonical_solution": "    if {[regexp {.*[0-9]$} $string]} {\n        return True\n    } else {\n        return False\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[end_num 'abcdef'] == False}\nassert {[end_num 'abcdef7'] == True}\nassert {[end_num 'abc'] == False}",
        "declaration": "proc end_num {string} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[end_num 'abcdef'] == False}",
        "prompt_text": "Write a function to check for a number at the end of a string.",
        "prompt_explain": "Write a function to check for a number at the end of a string.\n>>> end_num 'abcdef'\nFalse\n>>> end_num 'abcdef7'\nTrue\n>>> end_num 'abc'\nFalse",
        "func_title": "proc end_num {string}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the given string is made up of two alternating characters or not.\n# >>> is_Two_Alter \"abab\"\n# 1\n# >>> is_Two_Alter \"aaaa\"\n# 0\nproc is_Two_Alter {s} {",
        "canonical_solution": "    set len [string length $s]\n    for {set i 0} {$i < [expr {$len - 2}]} {incr i} {\n        if {[string index $s $i] != [string index $s [expr {$i + 2}]]} {\n            return 0\n        }\n    }\n    if {[string index $s 0] == [string index $s 1]} {\n        return 0\n    }\n    return 1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Two_Alter \"abab\"] == 1}\nassert {[is_Two_Alter \"aaaa\"] == 0}\nassert {[is_Two_Alter \"xyz\"] == 0}",
        "declaration": "proc is_Two_Alter {s} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Two_Alter \"abab\"] == 1}",
        "prompt_text": "Write a Tcl function to check whether the given string is made up of two alternating characters or not.",
        "prompt_explain": "Write a Tcl function to check whether the given string is made up of two alternating characters or not.\n>>> is_Two_Alter \"abab\"\n1\n>>> is_Two_Alter \"aaaa\"\n0",
        "func_title": "proc is_Two_Alter {s}"
    },
    {
        "prompt": "# Given a list of coin denominations and a total amount, return the number of ways to make change for that amount using the denominations.\n# >>> coin_change {1 2 3} 3 4\n# 4\nproc coin_change {S m n} {",
        "canonical_solution": "    set table [lrepeat [expr {$n + 1}] [lrepeat $m 0]]\n    for {set i 0} {$i < $m} {incr i} {\n        lset table 0 $i 1\n    }\n    for {set i 1} {$i <= $n} {incr i} {\n        for {set j 0} {$j < $m} {incr j} {\n            set x [expr {($i - [lindex $S $j] >= 0) ? [lindex $table [expr {$i - [lindex $S $j]}] $j] : 0}]\n            set y [expr {($j >= 1) ? [lindex $table $i [expr {$j - 1}]] : 0}]\n            lset table $i $j [expr {$x + $y}]\n        }\n    }\n    return [lindex $table $n [expr {$m - 1}]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[coin_change {1 2 3} 3 4] == 4}\nassert {[coin_change {4 5 6 7 8 9} 6 9] == 2}\nassert {[coin_change {4 5 6 7 8 9} 6 4] == 1}",
        "declaration": "proc coin_change {S m n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[coin_change {1 2 3} 3 4] == 4}",
        "prompt_text": "Given a list of coin denominations and a total amount, return the number of ways to make change for that amount using the denominations.",
        "prompt_explain": "Given a list of coin denominations and a total amount, return the number of ways to make change for that amount using the denominations.\n>>> coin_change {1 2 3} 3 4\n4",
        "func_title": "proc coin_change {S m n}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all items in the list.\n# >>> multiply_list {1 -2 3}\n# -6\nproc multiply_list {items} {",
        "canonical_solution": "    set tot 1\n    foreach x $items {\n        set tot [expr {$tot * $x}]\n    }\n    return $tot\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[multiply_list {1 -2 3}] == -6}\nassert {[multiply_list {1 2 3 4}] == 24}\nassert {[multiply_list {3 1 2 3}] == 18}",
        "declaration": "proc multiply_list {items} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[multiply_list {1 -2 3}] == -6}",
        "prompt_text": "Given a list of integers, return the product of all items in the list.",
        "prompt_explain": "Given a list of integers, return the product of all items in the list.\n>>> multiply_list {1 -2 3}\n-6",
        "func_title": "proc multiply_list {items}"
    },
    {
        "prompt": "# Given a tuple of integers, return the product of all the numbers in the tuple.\n# >>> multiple_tuple {4 3 2 2 -1 18}\n# -864\nproc multiple_tuple {nums} {",
        "canonical_solution": "    set product 1\n    foreach num $nums {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[multiple_tuple {4 3 2 2 -1 18}] == -864}\nassert {[multiple_tuple {1 2 3}] == 6}\nassert {[multiple_tuple {-2 -4 -6}] == -48}",
        "declaration": "proc multiple_tuple {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[multiple_tuple {4 3 2 2 -1 18}] == -864}",
        "prompt_text": "Given a tuple of integers, return the product of all the numbers in the tuple.",
        "prompt_explain": "Given a tuple of integers, return the product of all the numbers in the tuple.\n>>> multiple_tuple {4 3 2 2 -1 18}\n-864",
        "func_title": "proc multiple_tuple {nums}"
    },
    {
        "prompt": "# Given a binary tree, calculate its height.\n# >>> max_height $root\n# 3\nproc max_height {node} {",
        "canonical_solution": "    if {$node eq \"\"} {\n        return 0\n    } else {\n        set left_height [max_height [dict get $node left]]\n        set right_height [max_height [dict get $node right]]\n        if {$left_height > $right_height} {\n            return [expr {$left_height + 1}]\n        } else {\n            return [expr {$right_height + 1}]\n        }\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nset root [dict create data 1 left [dict create data 2 left [dict create data 4 left \"\" right \"\"] right [dict create data 5 left \"\" right \"\"]] right [dict create data 3 left \"\" right \"\"]]\nset root1 [dict create data 1 left [dict create data 2 left [dict create data 4 left \"\" right \"\"] right \"\"] right [dict create data 3 left [dict create data 5 left \"\" right \"\"] right [dict create data 6 left \"\" right [dict create data 7 left \"\" right [dict create data 8 left \"\" right \"\"]]]]]\nset root2 [dict create data 1 left [dict create data 2 left [dict create data 4 left [dict create data 6 left \"\" right \"\"] right [dict create data 7 left \"\" right \"\"]] right [dict create data 5 left \"\" right \"\"]] right [dict create data 3 left \"\" right \"\"]]\n\nassert {[max_height $root] == 3}\nassert {[max_height $root1] == 5}\nassert {[max_height $root2] == 4}",
        "declaration": "proc max_height {node} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nset root [dict create data 1 left [dict create data 2 left [dict create data 4 left \"\" right \"\"] right [dict create data 5 left \"\" right \"\"]] right [dict create data 3 left \"\" right \"\"]]\n\nassert {[max_height $root] == 3}",
        "prompt_text": "Given a binary tree, calculate its height.",
        "prompt_explain": "Given a binary tree, calculate its height.\n>>> max_height $root\n3",
        "func_title": "proc max_height {node}"
    },
    {
        "prompt": "# Given a tuple and a value, return the count of the value in the tuple.\n# >>> count_tuplex {2 4 5 6 2 3 4 4 7} 4\n# 3\nproc count_tuplex {tuplex value} {",
        "canonical_solution": "    set count 0\n    foreach element $tuplex {\n        if {$element == $value} {\n            incr count\n        }\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_tuplex {2 4 5 6 2 3 4 4 7} 4] == 3}\nassert {[count_tuplex {2 4 5 6 2 3 4 4 7} 2] == 2}\nassert {[count_tuplex {2 4 7 7 7 3 4 4 7} 7] == 4}",
        "declaration": "proc count_tuplex {tuplex value} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_tuplex {2 4 5 6 2 3 4 4 7} 4] == 3}",
        "prompt_text": "Given a tuple and a value, return the count of the value in the tuple.",
        "prompt_explain": "Given a tuple and a value, return the count of the value in the tuple.\n>>> count_tuplex {2 4 5 6 2 3 4 4 7} 4\n3",
        "func_title": "proc count_tuplex {tuplex value}"
    },
    {
        "prompt": "# Write a function to calculate the sum of series 1+2+3+.+n.\n# >>> sum_series 7\n# 784\nproc sum_series {number} {",
        "canonical_solution": "    set total [expr {pow(($number * ($number + 1)) / 2, 2)}]\n    return $total\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_series 7] == 784}\nassert {[sum_series 5] == 225}\nassert {[sum_series 15] == 14400}",
        "declaration": "proc sum_series {number} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_series 7] == 784}",
        "prompt_text": "Write a function to calculate the sum of series 1+2+3+.+n.",
        "prompt_explain": "Write a function to calculate the sum of series 1+2+3+.+n.\n>>> sum_series 7\n784",
        "func_title": "proc sum_series {number}"
    },
    {
        "prompt": "# Write a function to calculate the sum of series 1+2+3+.+n.\n# >>> series_sum 6\n# 91\nproc series_sum {number} {",
        "canonical_solution": "    set total [expr {($number * ($number + 1) * (2 * $number + 1)) / 6}]\n    return $total\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[series_sum 6] == 91}\nassert {[series_sum 7] == 140}\nassert {[series_sum 12] == 650}",
        "declaration": "proc series_sum {number} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[series_sum 6] == 91}",
        "prompt_text": "Write a function to calculate the sum of series 1+2+3+.+n.",
        "prompt_explain": "Write a function to calculate the sum of series 1+2+3+.+n.\n>>> series_sum 6\n91",
        "func_title": "proc series_sum {number}"
    },
    {
        "prompt": "# Given a list and a check list, return True if any element of the check list is present in the given list, otherwise return False.\n# >>> check_element {4 5 7 9 3} {6 7 10 11}\n# True\nproc check_element {test_tup check_list} {",
        "canonical_solution": "    set res False\n    foreach ele $check_list {\n        if {$ele in $test_tup} {\n            set res True\n            break\n        }\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_element {4 5 7 9 3} {6 7 10 11}] == True}\nassert {[check_element {1 2 3 4} {4 6 7 8 9}] == True}\nassert {[check_element {3 2 1 4 5} {9 8 7 6}] == False}",
        "declaration": "proc check_element {test_tup check_list} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_element {4 5 7 9 3} {6 7 10 11}] == True}",
        "prompt_text": "Given a list and a check list, return True if any element of the check list is present in the given list, otherwise return False.",
        "prompt_explain": "Given a list and a check list, return True if any element of the check list is present in the given list, otherwise return False.\n>>> check_element {4 5 7 9 3} {6 7 10 11}\nTrue",
        "func_title": "proc check_element {test_tup check_list}"
    },
    {
        "prompt": "# Given a string, write a function to separate and print the numbers and their position in the string.\n# >>> num_position \"there are 70 flats in this apartment\"\n# 10\nproc num_position {text} {",
        "canonical_solution": "    set positions {}\n    set i 0\n    while {$i < [string length $text]} {\n        if {[string is digit [string index $text $i]]} {\n            set start $i\n            while {$i < [string length $text] && [string is digit [string index $text $i]]} {\n                incr i\n            }\n            lappend positions $start\n        } else {\n            incr i\n        }\n    }\n    if {[llength $positions] > 0} {\n        return [lindex $positions 0]\n    } else {\n        return -1\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[num_position \"there are 70 flats in this apartment\"] == 10}\nassert {[num_position \"every adult have 32 teeth\"] == 17}\nassert {[num_position \"isha has 79 chocolates in her bag\"] == 9}",
        "declaration": "proc num_position {text} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[num_position \"there are 70 flats in this apartment\"] == 10}",
        "prompt_text": "Given a string, write a function to separate and print the numbers and their position in the string.",
        "prompt_explain": "Given a string, write a function to separate and print the numbers and their position in the string.\n>>> num_position \"there are 70 flats in this apartment\"\n10",
        "func_title": "proc num_position {text}"
    },
    {
        "prompt": "# Given integers n, r, and p, compute the value of nCr mod p.\n# >>> nCr_mod_p 10 2 13\n# 6\nproc nCr_mod_p {n r p} {",
        "canonical_solution": "    if {$r > [expr {$n - $r}]} {\n        set r [expr {$n - $r}]\n    }\n    set C [lrepeat [expr {$r + 1}] 0]\n    lset C 0 1\n    for {set i 1} {$i <= $n} {incr i} {\n        for {set j [expr {min($i, $r)}]} {$j > 0} {incr j -1} {\n            lset C $j [expr {([lindex $C $j] + [lindex $C [expr {$j - 1}]]) % $p}]\n        }\n    }\n    return [lindex $C $r]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[nCr_mod_p 10 2 13] == 6}\nassert {[nCr_mod_p 11 3 14] == 11}\nassert {[nCr_mod_p 18 14 19] == 1}",
        "declaration": "proc nCr_mod_p {n r p} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[nCr_mod_p 10 2 13] == 6}",
        "prompt_text": "Given integers n, r, and p, compute the value of nCr mod p.",
        "prompt_explain": "Given integers n, r, and p, compute the value of nCr mod p.\n>>> nCr_mod_p 10 2 13\n6",
        "func_title": "proc nCr_mod_p {n r p}"
    },
    {
        "prompt": "# Given a list of integers, find the minimum number of subsets with distinct elements.\n# >>> subset {1 2 3 4}\n# 1\n# >>> subset {5 6 9 3 4 3 4}\n# 2\nproc subset {ar} {",
        "canonical_solution": "    set res 0\n    set ar [lsort -integer $ar]\n    set n [llength $ar]\n    for {set i 0} {$i < $n} {incr i} {\n        set count 1\n        for {set j [expr {$i + 1}]} {$j < $n} {incr j} {\n            if {[lindex $ar $i] == [lindex $ar $j]} {\n                incr count\n            } else {\n                break\n            }\n        }\n        set res [expr {max($res, $count)}]\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[subset {1 2 3 4}] == 1}\nassert {[subset {5 6 9 3 4 3 4}] == 2}\nassert {[subset {1 2 3}] == 1}",
        "declaration": "proc subset {ar} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[subset {1 2 3 4}] == 1}",
        "prompt_text": "Given a list of integers, find the minimum number of subsets with distinct elements.",
        "prompt_explain": "Given a list of integers, find the minimum number of subsets with distinct elements.\n>>> subset {1 2 3 4}\n1\n>>> subset {5 6 9 3 4 3 4}\n2",
        "func_title": "proc subset {ar}"
    },
    {
        "prompt": "# Write a function that gives profit amount if the given amount has profit else return none.\n# >>> profit_amount 1500 1200\n# 300\n# >>> profit_amount 100 200\n# None\n# >>> profit_amount 2000 5000\n# None\nproc profit_amount {actual_cost sale_amount} {",
        "canonical_solution": "    if {$actual_cost > $sale_amount} {\n        set amount [expr {$actual_cost - $sale_amount}]\n        return $amount\n    } else {\n        return \"None\"\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[profit_amount 1500 1200] == 300}\nassert {[profit_amount 100 200] eq \"None\"}\nassert {[profit_amount 2000 5000] eq \"None\"}",
        "declaration": "proc profit_amount {actual_cost sale_amount} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[profit_amount 1500 1200] == 300}",
        "prompt_text": "Write a function that gives profit amount if the given amount has profit else return none.",
        "prompt_explain": "Write a function that gives profit amount if the given amount has profit else return none.\n>>> profit_amount 1500 1200\n300\n>>> profit_amount 100 200\nNone\n>>> profit_amount 2000 5000\nNone",
        "func_title": "proc profit_amount {actual_cost sale_amount}"
    },
    {
        "prompt": "# Given a number, determine if it is an abundant number. An abundant number is a number for which the sum of its proper divisors is greater than the number itself.\n# >>> is_abundant 12\n# 1\n# >>> is_abundant 13\n# 0\nproc is_abundant {n} {",
        "canonical_solution": "    set sum 0\n    for {set i 1} {$i < $n} {incr i} {\n        if {$n % $i == 0} {\n            incr sum $i\n        }\n    }\n    return [expr {$sum > $n}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_abundant 12] == 1}\nassert {[is_abundant 13] == 0}\nassert {[is_abundant 9] == 0}",
        "declaration": "proc is_abundant {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_abundant 12] == 1}",
        "prompt_text": "Given a number, determine if it is an abundant number. An abundant number is a number for which the sum of its proper divisors is greater than the number itself.",
        "prompt_explain": "Given a number, determine if it is an abundant number. An abundant number is a number for which the sum of its proper divisors is greater than the number itself.\n>>> is_abundant 12\n1\n>>> is_abundant 13\n0",
        "func_title": "proc is_abundant {n}"
    },
    {
        "prompt": "# Given a list of numbers, return the average of the list.\n# >>> Average {15 9 55 41 35 20 62 49}\n# 35.75\nproc Average {lst} {",
        "canonical_solution": "    set sum 0\n    foreach num $lst {\n        set sum [expr {$sum + $num}]\n    }\n    return [expr {$sum / double([llength $lst])}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Average {15 9 55 41 35 20 62 49}] == 35.75}\nassert {[Average {4 5 1 2 9 7 10 8}] == 5.75}\nassert {[Average {1 2 3}] == 2}",
        "declaration": "proc Average {lst} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Average {15 9 55 41 35 20 62 49}] == 35.75}",
        "prompt_text": "Given a list of numbers, return the average of the list.",
        "prompt_explain": "Given a list of numbers, return the average of the list.\n>>> Average {15 9 55 41 35 20 62 49}\n35.75",
        "func_title": "proc Average {lst}"
    },
    {
        "prompt": "# Write a function to convert a roman numeral to an integer.\n# >>> roman_to_int \"MMMCMLXXXVI\"\n# 3986\nproc roman_to_int {s} {",
        "canonical_solution": "    set rom_val {I 1 V 5 X 10 L 50 C 100 D 500 M 1000}\n    set int_val 0\n    set length [string length $s]\n    for {set i 0} {$i < $length} {incr i} {\n        set current_char [string index $s $i]\n        set current_val [dict get $rom_val $current_char]\n        if {$i > 0} {\n            set prev_char [string index $s [expr {$i - 1}]]\n            set prev_val [dict get $rom_val $prev_char]\n            if {$current_val > $prev_val} {\n                set int_val [expr {$int_val + $current_val - 2 * $prev_val}]\n            } else {\n                set int_val [expr {$int_val + $current_val}]\n            }\n        } else {\n            set int_val [expr {$int_val + $current_val}]\n        }\n    }\n    return $int_val\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[roman_to_int \"MMMCMLXXXVI\"] == 3986}\nassert {[roman_to_int \"MMMM\"] == 4000}\nassert {[roman_to_int \"C\"] == 100}",
        "declaration": "proc roman_to_int {s} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[roman_to_int \"MMMCMLXXXVI\"] == 3986}",
        "prompt_text": "Write a function to convert a roman numeral to an integer.",
        "prompt_explain": "Write a function to convert a roman numeral to an integer.\n>>> roman_to_int \"MMMCMLXXXVI\"\n3986",
        "func_title": "proc roman_to_int {s}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the length of the word is even or not.\n# >>> word_len \"program\"\n# False\n# >>> word_len \"solution\"\n# True\n# >>> word_len \"data\"\n# True\nproc word_len {s} {",
        "canonical_solution": "    set words [split $s \" \"]\n    foreach word $words {\n        if {[expr {[string length $word] % 2}] == 0} {\n            return True\n        } else {\n            return False\n        }\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[word_len \"program\"] eq False}\nassert {[word_len \"solution\"] eq True}\nassert {[word_len \"data\"] eq True}",
        "declaration": "proc word_len {s} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[word_len \"program\"] eq False}",
        "prompt_text": "Write a Tcl function to check whether the length of the word is even or not.",
        "prompt_explain": "Write a Tcl function to check whether the length of the word is even or not.\n>>> word_len \"program\"\nFalse\n>>> word_len \"solution\"\nTrue\n>>> word_len \"data\"\nTrue",
        "func_title": "proc word_len {s}"
    },
    {
        "prompt": "# Given a periodic function defined by A, B, and N, find the maximum possible value for the function.\n# >>> floor_Max 11 10 9\n# 9\nproc floor_Max {A B N} {",
        "canonical_solution": "    set x [expr {min($B - 1, $N)}]\n    return [expr {($A * $x) / $B}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[floor_Max 11 10 9] == 9}\nassert {[floor_Max 5 7 4] == 2}\nassert {[floor_Max 2 2 1] == 1}",
        "declaration": "proc floor_Max {A B N} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[floor_Max 11 10 9] == 9}",
        "prompt_text": "Given a periodic function defined by A, B, and N, find the maximum possible value for the function.",
        "prompt_explain": "Given a periodic function defined by A, B, and N, find the maximum possible value for the function.\n>>> floor_Max 11 10 9\n9",
        "func_title": "proc floor_Max {A B N}"
    },
    {
        "prompt": "# Write a function to find minimum of two numbers.\n# >>> min_of_two 10 20\n# 10\nproc min_of_two {x y} {",
        "canonical_solution": "    if {$x < $y} {\n        return $x\n    }\n    return $y\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_of_two 10 20] == 10}\nassert {[min_of_two 19 15] == 15}\nassert {[min_of_two -10 -20] == -20}",
        "declaration": "proc min_of_two {x y} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_of_two 10 20] == 10}",
        "prompt_text": "Write a function to find minimum of two numbers.",
        "prompt_explain": "Write a function to find minimum of two numbers.\n>>> min_of_two 10 20\n10",
        "func_title": "proc min_of_two {x y}"
    }
]