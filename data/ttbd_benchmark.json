[
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 15 20 25}] == 30}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {5 0 10}] == 0}\nassert {[product_of_numbers {2 2 2 2}] == 16}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three four five\"] == 5}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 20 30}] == 60}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product {1 2 3 4 5}\n# 120\nproc product {numbers} {",
        "canonical_solution": "    set result 1\n    foreach num $numbers {\n        set result [expr {$result * $num}]\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product {1 2 3 4 5}] == 120}\nassert {[product {10 20 30}] == 6000}\nassert {[product {1 3 5 7}] == 105}",
        "declaration": "proc product {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product {1 2 3 4 5}\n120",
        "func_title": "proc product {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {0 -1 -2}] == 0}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World!\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World!\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all elements.\n# >>> product_list {1 2 3 4 5}\n# 120\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {0 1 2}] == 0}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all elements.",
        "prompt_explain": "Given a list of integers, return the product of all elements.\n>>> product_list {1 2 3 4 5}\n120",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value.\n# >>> min_value {1 2 3 4 5}\n# 1\nproc min_value {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}\nassert {[min_value {10 20 30}] == 10}\nassert {[min_value {-1 -2 -3}] == -3}",
        "declaration": "proc min_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value.",
        "prompt_explain": "Given a list of integers, return the minimum value.\n>>> min_value {1 2 3 4 5}\n1",
        "func_title": "proc min_value {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World!\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World!\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> max_list {1 2 3 4 5}\n# 5\nproc max_list {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}\nassert {[max_list {10 20 30}] == 30}\nassert {[max_list {-1 -2 -3}] == -1}",
        "declaration": "proc max_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> max_list {1 2 3 4 5}\n5",
        "func_title": "proc max_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> max_list {1 3 2 8 5}\n# 8\nproc max_list {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 3 2 8 5}] == 8}\nassert {[max_list {10 20 30}] == 30}\nassert {[max_list {-1 -2 -3}] == -1}",
        "declaration": "proc max_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 3 2 8 5}] == 8}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> max_list {1 3 2 8 5}\n8",
        "func_title": "proc max_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 20 30}] == 60}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {3 1 4 1 5 9}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {3 1 4 1 5 9}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {3 1 4 1 5 9}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {3 1 4 1 5 9}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World!\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}\nassert {[count_words \"Tcl programming is fun\"] == 4}\nassert {[count_words \"OneWord\"] == 1}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World!\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4 5}\n# 120\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4 5}] == 120}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4 5}\n120",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a scripting language\"\n# 5\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a scripting language\"\n5",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> max_list {1 2 3 4 5}\n# 5\nproc max_list {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}\nassert {[max_list {10 20 30}] == 30}\nassert {[max_list {-1 -2 -3}] == -1}",
        "declaration": "proc max_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> max_list {1 2 3 4 5}\n5",
        "func_title": "proc max_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 15 20 25}] == 30}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World Tcl\"\n# 3\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World Tcl\"] == 3}\nassert {[count_words \"One Two Three Four\"] == 4}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World Tcl\"] == 3}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World Tcl\"\n3",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {5}] == 5}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 15 20 25}] == 30}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {1 3 2 8 5}\n# 8\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 8 5}] == 8}\nassert {[find_max {10 20 30 40 50}] == 50}\nassert {[find_max {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 8 5}] == 8}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {1 3 2 8 5}\n8",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4 5}\n# 120\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4 5}] == 120}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4 5}\n120",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string. Words are separated by spaces.\n# >>> count_words \"Hello World!\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string. Words are separated by spaces.",
        "prompt_explain": "Given a string, return the number of words in the string. Words are separated by spaces.\n>>> count_words \"Hello World!\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even {1 2 3 4 5 6}\n# 12\nproc sum_even {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}\nassert {[sum_even {10 20 30}] == 60}\nassert {[sum_even {1 3 5 7}] == 0}",
        "declaration": "proc sum_even {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_list {1 2 3 4}\n# 24\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4}] == 24}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {0 1 2 3}] == 0}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_list {1 2 3 4}\n24",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"hello world\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"hello world\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a powerful scripting language\"\n# 6\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}\nassert {[count_words \"\"] == 0}\nassert {[count_words \"SingleWord\"] == 1}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a powerful scripting language\"\n6",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_in_list {1 3 2 8 5}\n# 8\nproc max_in_list {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_in_list {1 3 2 8 5}] == 8}\nassert {[max_in_list {10 20 30}] == 30}\nassert {[max_in_list {-1 -2 -3}] == -1}",
        "declaration": "proc max_in_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_in_list {1 3 2 8 5}] == 8}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_in_list {1 3 2 8 5}\n8",
        "func_title": "proc max_in_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the average value.\n# >>> average_list {1 2 3 4 5}\n# 3\nproc average_list {numbers} {",
        "canonical_solution": "    set sum 0\n    set count [llength $numbers]\n    foreach num $numbers {\n        incr sum $num\n    }\n    return [expr {$sum / $count}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average_list {1 2 3 4 5}] == 3}\nassert {[average_list {10 20 30}] == 20}\nassert {[average_list {2 4 6 8}] == 5}",
        "declaration": "proc average_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average_list {1 2 3 4 5}] == 3}",
        "prompt_text": "Given a list of integers, return the average value.",
        "prompt_explain": "Given a list of integers, return the average value.\n>>> average_list {1 2 3 4 5}\n3",
        "func_title": "proc average_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"OneWord\"] == 1}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the average value.\n# >>> average_value {1 2 3 4 5}\n# 3.0\nproc average_value {numbers} {",
        "canonical_solution": "    set sum 0\n    set count [llength $numbers]\n    foreach num $numbers {\n        incr sum $num\n    }\n    return [expr {$sum / double($count)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average_value {1 2 3 4 5}] == 3.0}\nassert {[average_value {10 20 30}] == 20.0}\nassert {[average_value {1}] == 1.0}",
        "declaration": "proc average_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average_value {1 2 3 4 5}] == 3.0}",
        "prompt_text": "Given a list of integers, return the average value.",
        "prompt_explain": "Given a list of integers, return the average value.\n>>> average_value {1 2 3 4 5}\n3.0",
        "func_title": "proc average_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list without using the built-in max command.\n# >>> find_max {1 5 3 9 2}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list without using the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list without using the built-in max command.\n>>> find_max {1 5 3 9 2}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"hello world\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world\"] == 2}\nassert {[count_words \"one two three four\"] == 4}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"hello world\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 15 20 25}] == 30}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value without using the built-in max command.\n# >>> find_max {1 3 2 8 5}\n# 8\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 8 5}] == 8}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 8 5}] == 8}",
        "prompt_text": "Given a list of integers, return the maximum value without using the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value without using the built-in max command.\n>>> find_max {1 3 2 8 5}\n8",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {5 10 2}] == 100}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers.",
        "prompt_explain": "Given a list of integers, return the product of all numbers.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 20 30}] == 60}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {1 3 2 5 4}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 5 4}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 5 4}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {1 3 2 5 4}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 20 30}] == 60}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product {1 2 3 4 5}\n# 120\nproc product {numbers} {",
        "canonical_solution": "    set prod 1\n    foreach num $numbers {\n        set prod [expr {$prod * $num}]\n    }\n    return $prod\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product {1 2 3 4 5}] == 120}\nassert {[product {10 20 30}] == 6000}\nassert {[product {0 1 2 3}] == 0}",
        "declaration": "proc product {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product {1 2 3 4 5}\n120",
        "func_title": "proc product {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 5 3 9 2}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -5 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 5 3 9 2}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even {1 2 3 4 5 6}\n# 12\nproc sum_even {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}\nassert {[sum_even {10 15 20 25}] == 30}\nassert {[sum_even {1 3 5 7}] == 0}",
        "declaration": "proc sum_even {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_list {1 2 3 4 5}\n# 120\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {1 1 1 1}] == 1}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_list {1 2 3 4 5}\n120",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all elements.\n# >>> product_list {1 2 3 4 5}\n# 120\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {}] == 1}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all elements.",
        "prompt_explain": "Given a list of integers, return the product of all elements.\n>>> product_list {1 2 3 4 5}\n120",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4 5}\n# 120\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4 5}] == 120}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4 5}\n120",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_list {1 2 3 4 5}\n# 5\nproc max_list {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}\nassert {[max_list {10 20 30}] == 30}\nassert {[max_list {0 0 0}] == 0}",
        "declaration": "proc max_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_list {1 2 3 4 5}\n5",
        "func_title": "proc max_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"hello world\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world\"] == 2}\nassert {[count_words \"tcl programming is fun\"] == 4}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"hello world\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even {1 2 3 4 5 6}\n# 12\nproc sum_even {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}\nassert {[sum_even {10 20 30}] == 60}\nassert {[sum_even {1 3 5 7}] == 0}",
        "declaration": "proc sum_even {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {1 3 2 5 4}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 5 4}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 5 4}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {1 3 2 5 4}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value in the list. Do not use the built-in min command.\n# >>> find_min {1 3 2 5 4}\n# 1\nproc find_min {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_min {1 3 2 5 4}] == 1}\nassert {[find_min {10 20 30}] == 10}\nassert {[find_min {-1 -2 -3}] == -3}",
        "declaration": "proc find_min {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_min {1 3 2 5 4}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value in the list. Do not use the built-in min command.",
        "prompt_explain": "Given a list of integers, return the minimum value in the list. Do not use the built-in min command.\n>>> find_min {1 3 2 5 4}\n1",
        "func_title": "proc find_min {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_list {1 2 3 4 5}\n# 120\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {1 1 1 1}] == 1}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_list {1 2 3 4 5}\n120",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of numbers, return the sum of all numbers.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        set sum [expr {$sum + $num}]\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of numbers, return the sum of all numbers.",
        "prompt_explain": "Given a list of numbers, return the sum of all numbers.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value.\n# >>> min_value {1 2 3 4 5}\n# 1\nproc min_value {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}\nassert {[min_value {10 20 30}] == 10}\nassert {[min_value {-1 -2 -3}] == -3}",
        "declaration": "proc min_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value.",
        "prompt_explain": "Given a list of integers, return the minimum value.\n>>> min_value {1 2 3 4 5}\n1",
        "func_title": "proc min_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value.\n# >>> min_value {1 2 3 4 5}\n# 1\nproc min_value {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}\nassert {[min_value {10 20 30}] == 10}\nassert {[min_value {-1 -2 -3}] == -3}",
        "declaration": "proc min_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value.",
        "prompt_explain": "Given a list of integers, return the minimum value.\n>>> min_value {1 2 3 4 5}\n1",
        "func_title": "proc min_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30 40}] == 100}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4 5}\n# 120\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4 5}] == 120}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4 5}\n120",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a scripting language\"\n# 5\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}\nassert {[count_words \"\"] == 0}\nassert {[count_words \"OneWord\"] == 1}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a scripting language\"\n5",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 5 3 9 2}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 5 3 9 2}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {}] == 1}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_list {1 2 3 4 5}\n# 5\nproc max_list {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}\nassert {[max_list {10 20 30}] == 30}\nassert {[max_list {-1 -2 -3}] == -1}",
        "declaration": "proc max_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_list {1 2 3 4 5}\n5",
        "func_title": "proc max_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list, return the number of elements in the list.\n# >>> list_length {1 2 3 4 5}\n# 5\nproc list_length {lst} {",
        "canonical_solution": "    return [llength $lst]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[list_length {1 2 3 4 5}] == 5}\nassert {[list_length {}] == 0}\nassert {[list_length {a b c d e f g}] == 7}",
        "declaration": "proc list_length {lst} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[list_length {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list, return the number of elements in the list.",
        "prompt_explain": "Given a list, return the number of elements in the list.\n>>> list_length {1 2 3 4 5}\n5",
        "func_title": "proc list_length {lst}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {0 -1 -2}] == 0}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 20 30}] == 60}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 3 2 5 4}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 5 4}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 5 4}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 3 2 5 4}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a scripting language\"\n# 5\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a scripting language\"\n5",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product {1 2 3 4}\n# 24\nproc product {numbers} {",
        "canonical_solution": "    set result 1\n    foreach num $numbers {\n        set result [expr {$result * $num}]\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product {1 2 3 4}] == 24}\nassert {[product {10 20 30}] == 6000}\nassert {[product {0 1 2 3}] == 0}",
        "declaration": "proc product {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product {1 2 3 4}\n24",
        "func_title": "proc product {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 20 30}] == 60}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string. Words are separated by spaces.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One\"] == 1}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string. Words are separated by spaces.",
        "prompt_explain": "Given a string, return the number of words in the string. Words are separated by spaces.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {1 3 2 5 4}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 5 4}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 5 4}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {1 3 2 5 4}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a powerful scripting language\"\n# 6\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}\nassert {[count_words \"\"] == 0}\nassert {[count_words \"OneWord\"] == 1}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a powerful scripting language\"\n6",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {3 1 4 1 5 9}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {3 1 4 1 5 9}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {3 1 4 1 5 9}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {3 1 4 1 5 9}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 15 20 25}] == 30}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {3 1 4 1 5 9}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {3 1 4 1 5 9}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {3 1 4 1 5 9}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {3 1 4 1 5 9}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    set words [split $str \" \"]\n    return [llength $words]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"One\"] == 1}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a scripting language\"\n# 5\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}\nassert {[count_words \"\"] == 0}\nassert {[count_words \"OneWord\"] == 1}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a scripting language\"\n5",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 5 3 9 2}\n# 9\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 5 3 9 2}] == 9}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 5 3 9 2}\n9",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all elements.\n# >>> product_list {1 2 3 4 5}\n# 120\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {}] == 1}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all elements.",
        "prompt_explain": "Given a list of integers, return the product of all elements.\n>>> product_list {1 2 3 4 5}\n120",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a string, return true if the string is a palindrome, false otherwise.\n# >>> is_palindrome \"madam\"\n# true\nproc is_palindrome {str} {",
        "canonical_solution": "    return [expr {$str eq [string reverse $str]}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_palindrome \"madam\"] == 1}\nassert {[is_palindrome \"hello\"] == 0}\nassert {[is_palindrome \"racecar\"] == 1}",
        "declaration": "proc is_palindrome {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_palindrome \"madam\"] == 1}",
        "prompt_text": "Given a string, return true if the string is a palindrome, false otherwise.",
        "prompt_explain": "Given a string, return true if the string is a palindrome, false otherwise.\n>>> is_palindrome \"madam\"\ntrue",
        "func_title": "proc is_palindrome {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> max_list {1 2 3 4 5}\n# 5\nproc max_list {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}\nassert {[max_list {10 20 30}] == 30}\nassert {[max_list {-1 -2 -3}] == -1}",
        "declaration": "proc max_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> max_list {1 2 3 4 5}\n5",
        "func_title": "proc max_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a powerful scripting language\"\n# 6\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a powerful scripting language\"\n6",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 5 3 9 2}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -5 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 5 3 9 2}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {1 3 5 7}] == 0}\nassert {[sum_even_numbers {2 4 6 8}] == 20}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World Tcl Programming\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World Tcl Programming\"] == 4}\nassert {[count_words \"One\"] == 1}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World Tcl Programming\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World Tcl Programming\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a scripting language\"\n# 5\nproc count_words {str} {",
        "canonical_solution": "    set words [split $str \" \"]\n    return [llength $words]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}\nassert {[count_words \"\"] == 0}\nassert {[count_words \"OneWord\"] == 1}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a scripting language\"\n5",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 5 3 9 2}\n# 9\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 5 3 9 2}] == 9}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 5 3 9 2}\n9",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value.\n# >>> min_value {5 3 9 1 4}\n# 1\nproc min_value {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {5 3 9 1 4}] == 1}\nassert {[min_value {10 20 30}] == 10}\nassert {[min_value {-1 -2 -3}] == -3}",
        "declaration": "proc min_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {5 3 9 1 4}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value.",
        "prompt_explain": "Given a list of integers, return the minimum value.\n>>> min_value {5 3 9 1 4}\n1",
        "func_title": "proc min_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 20 30}] == 60}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value in the list. Do not use the built-in min command.\n# >>> find_min {1 2 3 4 5}\n# 1\nproc find_min {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_min {1 2 3 4 5}] == 1}\nassert {[find_min {10 20 30}] == 10}\nassert {[find_min {-1 -2 -3 -4 -5}] == -5}",
        "declaration": "proc find_min {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_min {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value in the list. Do not use the built-in min command.",
        "prompt_explain": "Given a list of integers, return the minimum value in the list. Do not use the built-in min command.\n>>> find_min {1 2 3 4 5}\n1",
        "func_title": "proc find_min {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even {1 2 3 4 5 6}\n# 12\nproc sum_even {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}\nassert {[sum_even {10 15 20 25}] == 30}\nassert {[sum_even {1 3 5 7}] == 0}",
        "declaration": "proc sum_even {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_list {1 2 3 4 5}\n# 120\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {}] == 1}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_list {1 2 3 4 5}\n120",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string. Words are separated by spaces.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"OneWord\"] == 1}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string. Words are separated by spaces.",
        "prompt_explain": "Given a string, return the number of words in the string. Words are separated by spaces.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value without using the built-in max command.\n# >>> find_max {1 5 3 9 2}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value without using the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value without using the built-in max command.\n>>> find_max {1 5 3 9 2}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {5 10 2}] == 100}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list without using the built-in max command.\n# >>> find_max {1 3 2 5 4}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 5 4}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 5 4}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list without using the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list without using the built-in max command.\n>>> find_max {1 3 2 5 4}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4 5}\n# 120\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4 5}] == 120}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4 5}\n120",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a scripting language\"\n# 5\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a scripting language\"\n5",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a string, return true if the string is a palindrome, false otherwise.\n# >>> is_palindrome \"racecar\"\n# 1\nproc is_palindrome {str} {",
        "canonical_solution": "    return [expr {$str eq [string reverse $str]}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_palindrome \"racecar\"] == 1}\nassert {[is_palindrome \"hello\"] == 0}\nassert {[is_palindrome \"\"] == 1}",
        "declaration": "proc is_palindrome {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_palindrome \"racecar\"] == 1}",
        "prompt_text": "Given a string, return true if the string is a palindrome, false otherwise.",
        "prompt_explain": "Given a string, return true if the string is a palindrome, false otherwise.\n>>> is_palindrome \"racecar\"\n1",
        "func_title": "proc is_palindrome {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> max_value {1 5 3 9 2}\n# 9\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 5 3 9 2}] == 9}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> max_value {1 5 3 9 2}\n9",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a scripting language\"\n# 5\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}\nassert {[count_words \"OneWord\"] == 1}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a scripting language\"\n5",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all elements.\n# >>> product_list {1 2 3 4 5}\n# 120\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {0}] == 0}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all elements.",
        "prompt_explain": "Given a list of integers, return the product of all elements.\n>>> product_list {1 2 3 4 5}\n120",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 3 2 5 4}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 5 4}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 5 4}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 3 2 5 4}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4 5}\n# 120\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4 5}] == 120}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {}] == 1}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4 5}\n120",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value.\n# >>> min_value {1 2 3 4 5}\n# 1\nproc min_value {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}\nassert {[min_value {10 20 30}] == 10}\nassert {[min_value {-1 -2 -3}] == -3}",
        "declaration": "proc min_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value.",
        "prompt_explain": "Given a list of integers, return the minimum value.\n>>> min_value {1 2 3 4 5}\n1",
        "func_title": "proc min_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"Tcl programming is fun\"] == 4}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {}] == 1}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 15 20 25}] == 30}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string. Words are separated by spaces.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string. Words are separated by spaces.",
        "prompt_explain": "Given a string, return the number of words in the string. Words are separated by spaces.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {1 5 3 9 2}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -5 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {1 5 3 9 2}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {0}] == 0}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of strings, return the number of strings that start with a vowel.\n# >>> count_vowel_start {apple banana orange melon}\n# 2\nproc count_vowel_start {strings} {",
        "canonical_solution": "    set vowels {a e i o u A E I O U}\n    set count 0\n    foreach str $strings {\n        if {[string index $str 0] in $vowels} {\n            incr count\n        }\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_vowel_start {apple banana orange melon}] == 2}\nassert {[count_vowel_start {Elephant Umbrella}] == 2}\nassert {[count_vowel_start {Cat Dog}] == 0}",
        "declaration": "proc count_vowel_start {strings} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_vowel_start {apple banana orange melon}] == 2}",
        "prompt_text": "Given a list of strings, return the number of strings that start with a vowel.",
        "prompt_explain": "Given a list of strings, return the number of strings that start with a vowel.\n>>> count_vowel_start {apple banana orange melon}\n2",
        "func_title": "proc count_vowel_start {strings}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> max_list {1 2 3 4 5}\n# 5\nproc max_list {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}\nassert {[max_list {10 20 30}] == 30}\nassert {[max_list {-1 -2 -3}] == -1}",
        "declaration": "proc max_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> max_list {1 2 3 4 5}\n5",
        "func_title": "proc max_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all elements.\n# >>> product_list {1 2 3 4 5}\n# 120\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {0 1 2}] == 0}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all elements.",
        "prompt_explain": "Given a list of integers, return the product of all elements.\n>>> product_list {1 2 3 4 5}\n120",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even {1 2 3 4 5 6}\n# 12\nproc sum_even {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}\nassert {[sum_even {10 20 30}] == 60}\nassert {[sum_even {1 3 5 7}] == 0}",
        "declaration": "proc sum_even {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string. Words are separated by whitespace.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string. Words are separated by whitespace.",
        "prompt_explain": "Given a string, return the number of words in the string. Words are separated by whitespace.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {1 3 2 5 4}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 5 4}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 5 4}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {1 3 2 5 4}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a powerful scripting language\"\n# 6\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}\nassert {[count_words \"\"] == 0}\nassert {[count_words \"OneWord\"] == 1}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a powerful scripting language\"\n6",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 3 2 8 5}\n# 8\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 8 5}] == 8}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 8 5}] == 8}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 3 2 8 5}\n8",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        set sum [expr {$sum + $num}]\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a powerful scripting language\"\n# 6\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a powerful scripting language\"\n6",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 15 20 25}] == 30}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string. Words are separated by whitespace.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string. Words are separated by whitespace.",
        "prompt_explain": "Given a string, return the number of words in the string. Words are separated by whitespace.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {1 5 3 9 2}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -5 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {1 5 3 9 2}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {1}] == 1}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list, return the number of elements in the list.\n# >>> list_length {a b c d e}\n# 5\nproc list_length {lst} {",
        "canonical_solution": "    return [llength $lst]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[list_length {a b c d e}] == 5}\nassert {[list_length {1 2 3}] == 3}\nassert {[list_length {}] == 0}",
        "declaration": "proc list_length {lst} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[list_length {a b c d e}] == 5}",
        "prompt_text": "Given a list, return the number of elements in the list.",
        "prompt_explain": "Given a list, return the number of elements in the list.\n>>> list_length {a b c d e}\n5",
        "func_title": "proc list_length {lst}"
    },
    {
        "prompt": "# Given a string, return true if the string is a palindrome, otherwise return false.\n# >>> is_palindrome \"racecar\"\n# 1\nproc is_palindrome {str} {",
        "canonical_solution": "    return [expr {$str eq [string reverse $str]}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_palindrome \"racecar\"] == 1}\nassert {[is_palindrome \"hello\"] == 0}\nassert {[is_palindrome \"12321\"] == 1}",
        "declaration": "proc is_palindrome {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_palindrome \"racecar\"] == 1}",
        "prompt_text": "Given a string, return true if the string is a palindrome, otherwise return false.",
        "prompt_explain": "Given a string, return true if the string is a palindrome, otherwise return false.\n>>> is_palindrome \"racecar\"\n1",
        "func_title": "proc is_palindrome {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {0 -1 -2}] == 0}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a powerful scripting language\"\n# 6\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}\nassert {[count_words \"\"] == 0}\nassert {[count_words \"OneWord\"] == 1}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a powerful scripting language\"\n6",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 5 3 9 2}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 5 3 9 2}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even {1 2 3 4 5 6}\n# 12\nproc sum_even {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}\nassert {[sum_even {10 20 30}] == 60}\nassert {[sum_even {1 3 5 7}] == 0}",
        "declaration": "proc sum_even {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_list {1 2 3 4 5}\n# 120\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {1 1 1 1}] == 1}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_list {1 2 3 4 5}\n120",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 15 20 25}] == 30}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product {1 2 3 4}\n# 24\nproc product {numbers} {",
        "canonical_solution": "    set prod 1\n    foreach num $numbers {\n        set prod [expr {$prod * $num}]\n    }\n    return $prod\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product {1 2 3 4}] == 24}\nassert {[product {5 0 10}] == 0}\nassert {[product {1 1 1 1}] == 1}",
        "declaration": "proc product {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product {1 2 3 4}\n24",
        "func_title": "proc product {numbers}"
    },
    {
        "prompt": "# Given a string, return the length of the longest word in the string.\n# >>> longest_word_length \"The quick brown fox\"\n# 5\nproc longest_word_length {str} {",
        "canonical_solution": "    set words [split $str \" \"]\n    set max_length 0\n    foreach word $words {\n        set length [string length $word]\n        if {$length > $max_length} {\n            set max_length $length\n        }\n    }\n    return $max_length\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[longest_word_length \"The quick brown fox\"] == 5}\nassert {[longest_word_length \"Jumped over the lazy dog\"] == 5}\nassert {[longest_word_length \"a bb ccc dddd\"] == 4}",
        "declaration": "proc longest_word_length {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[longest_word_length \"The quick brown fox\"] == 5}",
        "prompt_text": "Given a string, return the length of the longest word in the string.",
        "prompt_explain": "Given a string, return the length of the longest word in the string.\n>>> longest_word_length \"The quick brown fox\"\n5",
        "func_title": "proc longest_word_length {str}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"One two three four\"] == 4}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all elements.\n# >>> product_list {1 2 3 4 5}\n# 120\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {0}] == 0}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all elements.",
        "prompt_explain": "Given a list of integers, return the product of all elements.\n>>> product_list {1 2 3 4 5}\n120",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World!\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}\nassert {[count_words \"One two three four\"] == 4}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World!\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the average of all elements.\n# >>> average_list {1 2 3 4 5}\n# 3\nproc average_list {numbers} {",
        "canonical_solution": "    set sum 0\n    set count 0\n    foreach num $numbers {\n        incr sum $num\n        incr count\n    }\n    return [expr {$sum / $count}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average_list {1 2 3 4 5}] == 3}\nassert {[average_list {10 20 30}] == 20}\nassert {[average_list {0}] == 0}",
        "declaration": "proc average_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average_list {1 2 3 4 5}] == 3}",
        "prompt_text": "Given a list of integers, return the average of all elements.",
        "prompt_explain": "Given a list of integers, return the average of all elements.\n>>> average_list {1 2 3 4 5}\n3",
        "func_title": "proc average_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all elements.\n# >>> product_list {1 2 3 4 5}\n# 120\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {}] == 1}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all elements.",
        "prompt_explain": "Given a list of integers, return the product of all elements.\n>>> product_list {1 2 3 4 5}\n120",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World!\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World!\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a scripting language\"\n# 5\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}\nassert {[count_words \"\"] == 0}\nassert {[count_words \"OneWord\"] == 1}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a scripting language\"\n5",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 5 3 9 2}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 5 3 9 2}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of numbers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        set sum [expr {$sum + $num}]\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of numbers, return the sum of all elements.",
        "prompt_explain": "Given a list of numbers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list, return the number of elements in the list.\n# >>> list_length {1 2 3 4 5}\n# 5\nproc list_length {lst} {",
        "canonical_solution": "    return [llength $lst]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[list_length {1 2 3 4 5}] == 5}\nassert {[list_length {}] == 0}\nassert {[list_length {a b c d e f g}] == 7}",
        "declaration": "proc list_length {lst} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[list_length {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list, return the number of elements in the list.",
        "prompt_explain": "Given a list, return the number of elements in the list.\n>>> list_length {1 2 3 4 5}\n5",
        "func_title": "proc list_length {lst}"
    },
    {
        "prompt": "# Given a list of numbers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of numbers, return the maximum value.",
        "prompt_explain": "Given a list of numbers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of numbers, return the minimum value.\n# >>> min_value {1 2 3 4 5}\n# 1\nproc min_value {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}\nassert {[min_value {10 20 30}] == 10}\nassert {[min_value {-1 -2 -3}] == -3}",
        "declaration": "proc min_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of numbers, return the minimum value.",
        "prompt_explain": "Given a list of numbers, return the minimum value.\n>>> min_value {1 2 3 4 5}\n1",
        "func_title": "proc min_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 20 30}] == 60}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World!\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World!\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value.\n# >>> min_value {1 2 3 4 5}\n# 1\nproc min_value {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}\nassert {[min_value {10 20 30}] == 10}\nassert {[min_value {-1 -2 -3}] == -3}",
        "declaration": "proc min_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value.",
        "prompt_explain": "Given a list of integers, return the minimum value.\n>>> min_value {1 2 3 4 5}\n1",
        "func_title": "proc min_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {1 3 5 7}] == 0}\nassert {[sum_even_numbers {2 4 6 8}] == 20}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a powerful scripting language\"\n# 6\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}\nassert {[count_words \"\"] == 0}\nassert {[count_words \"OneWord\"] == 1}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a powerful scripting language\"\n6",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 3 2 8 5}\n# 8\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 8 5}] == 8}\nassert {[find_max {-1 -3 -2 -8 -5}] == -1}\nassert {[find_max {10}] == 10}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 8 5}] == 8}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 3 2 8 5}\n8",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {5}] == 5}\nassert {[product_of_numbers {}] == 1}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One\"] == 1}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 100 1000}] == 1000}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value.\n# >>> min_value {1 2 3 4 5}\n# 1\nproc min_value {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}\nassert {[min_value {10 100 1000}] == 10}\nassert {[min_value {-1 -2 -3}] == -3}",
        "declaration": "proc min_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value.",
        "prompt_explain": "Given a list of integers, return the minimum value.\n>>> min_value {1 2 3 4 5}\n1",
        "func_title": "proc min_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"Tcl is a scripting language\"] == 5}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of times a specific character appears in the string.\n# >>> count_char \"hello\" l\n# 2\nproc count_char {str char} {",
        "canonical_solution": "    set count 0\n    foreach chr [split $str \"\"] {\n        if {$chr eq $char} {\n            incr count\n        }\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_char \"hello\" l] == 2}\nassert {[count_char \"mississippi\" s] == 4}\nassert {[count_char \"abcdef\" z] == 0}",
        "declaration": "proc count_char {str char} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_char \"hello\" l] == 2}",
        "prompt_text": "Given a string, return the number of times a specific character appears in the string.",
        "prompt_explain": "Given a string, return the number of times a specific character appears in the string.\n>>> count_char \"hello\" l\n2",
        "func_title": "proc count_char {str char}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 15 20 25}] == 30}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string. Words are separated by whitespace.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string. Words are separated by whitespace.",
        "prompt_explain": "Given a string, return the number of words in the string. Words are separated by whitespace.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {3 1 4 1 5 9}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {3 1 4 1 5 9}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {3 1 4 1 5 9}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {3 1 4 1 5 9}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_list {1 2 3 4}\n# 24\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4}] == 24}\nassert {[product_list {5 0 10}] == 0}\nassert {[product_list {-1 -2 -3}] == -6}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_list {1 2 3 4}\n24",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 15 20 25}] == 30}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {3 1 4 1 5 9}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {3 1 4 1 5 9}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {3 1 4 1 5 9}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {3 1 4 1 5 9}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    set words [split $str \" \"]\n    return [llength $words]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"One\"] == 1}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string. Words are separated by spaces.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string. Words are separated by spaces.",
        "prompt_explain": "Given a string, return the number of words in the string. Words are separated by spaces.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {1 5 3 9 2}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {1 5 3 9 2}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {1 3 5 7}] == 0}\nassert {[sum_even_numbers {2 4 6 8}] == 20}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a powerful scripting language\"\n# 6\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}\nassert {[count_words \"\"] == 0}\nassert {[count_words \"OneWord\"] == 1}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a powerful scripting language\"\n6",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {1 5 3 9 2}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -5 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {1 5 3 9 2}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4 5}\n# 120\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4 5}] == 120}\nassert {[product_of_numbers {10}] == 10}\nassert {[product_of_numbers {}] == 1}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4 5}\n120",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"hello world\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world\"] == 2}\nassert {[count_words \"tcl programming is fun\"] == 4}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"hello world\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {-1 -2 -3 -4 -5}] == -15}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"Tcl is a scripting language\"] == 5}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of times a specific character appears in the string.\n# >>> count_char \"hello\" l\n# 2\nproc count_char {str char} {",
        "canonical_solution": "    set count 0\n    foreach chr [split $str \"\"] {\n        if {$chr eq $char} {\n            incr count\n        }\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_char \"hello\" l] == 2}\nassert {[count_char \"mississippi\" s] == 4}\nassert {[count_char \"abcdef\" z] == 0}",
        "declaration": "proc count_char {str char} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_char \"hello\" l] == 2}",
        "prompt_text": "Given a string, return the number of times a specific character appears in the string.",
        "prompt_explain": "Given a string, return the number of times a specific character appears in the string.\n>>> count_char \"hello\" l\n2",
        "func_title": "proc count_char {str char}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world\"] == 2}\nassert {[count_words \"One two three four\"] == 4}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a string, return true if the string is a palindrome, false otherwise.\n# >>> is_palindrome \"racecar\"\n# true\nproc is_palindrome {str} {",
        "canonical_solution": "    return [expr {$str eq [string reverse $str]}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_palindrome \"racecar\"] == 1}\nassert {[is_palindrome \"hello\"] == 0}\nassert {[is_palindrome \"\"] == 1}",
        "declaration": "proc is_palindrome {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_palindrome \"racecar\"] == 1}",
        "prompt_text": "Given a string, return true if the string is a palindrome, false otherwise.",
        "prompt_explain": "Given a string, return true if the string is a palindrome, false otherwise.\n>>> is_palindrome \"racecar\"\ntrue",
        "func_title": "proc is_palindrome {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value.\n# >>> min_value {1 2 3 4 5}\n# 1\nproc min_value {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}\nassert {[min_value {10 20 30}] == 10}\nassert {[min_value {-1 -2 -3}] == -3}",
        "declaration": "proc min_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value.",
        "prompt_explain": "Given a list of integers, return the minimum value.\n>>> min_value {1 2 3 4 5}\n1",
        "func_title": "proc min_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even {1 2 3 4 5 6}\n# 12\nproc sum_even {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}\nassert {[sum_even {10 20 30}] == 60}\nassert {[sum_even {1 3 5 7}] == 0}",
        "declaration": "proc sum_even {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world, this is Tcl.\"\n# 5\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world, this is Tcl.\"] == 5}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world, this is Tcl.\"] == 5}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world, this is Tcl.\"\n5",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all elements.\n# >>> product_list {1 2 3 4}\n# 24\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4}] == 24}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {0 1 2 3}] == 0}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all elements.",
        "prompt_explain": "Given a list of integers, return the product of all elements.\n>>> product_list {1 2 3 4}\n24",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 15 20 25}] == 30}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a powerful scripting language\"\n# 6\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}\nassert {[count_words \"\"] == 0}\nassert {[count_words \"OneWord\"] == 1}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a powerful scripting language\"\n6",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 5 3 9 2}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -5 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 5 3 9 2}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {-1 -2 -3 -4 -5}] == -15}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value.\n# >>> min_value {1 2 3 4 5}\n# 1\nproc min_value {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}\nassert {[min_value {10 20 30}] == 10}\nassert {[min_value {-1 -2 -3 -4 -5}] == -5}",
        "declaration": "proc min_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value.",
        "prompt_explain": "Given a list of integers, return the minimum value.\n>>> min_value {1 2 3 4 5}\n1",
        "func_title": "proc min_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a powerful scripting language\"\n# 6\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a powerful scripting language\"\n6",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 5 3 9 2}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 5 3 9 2}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {5 0 10}] == 0}\nassert {[product_of_numbers {2 2 2 2}] == 16}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 20 30}] == 60}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4 5}\n# 120\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4 5}] == 120}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {1 1 1 1}] == 1}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4 5}\n120",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a scripting language\"\n# 5\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a scripting language\"\n5",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the average value.\n# >>> average_value {1 2 3 4 5}\n# 3.0\nproc average_value {numbers} {",
        "canonical_solution": "    set sum 0\n    set count [llength $numbers]\n    foreach num $numbers {\n        incr sum $num\n    }\n    return [expr {$sum / double($count)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average_value {1 2 3 4 5}] == 3.0}\nassert {[average_value {10 20 30}] == 20.0}\nassert {[average_value {1}] == 1.0}",
        "declaration": "proc average_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average_value {1 2 3 4 5}] == 3.0}",
        "prompt_text": "Given a list of integers, return the average value.",
        "prompt_explain": "Given a list of integers, return the average value.\n>>> average_value {1 2 3 4 5}\n3.0",
        "func_title": "proc average_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 11 12 13 14}] == 36}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One\"] == 1}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value without using the built-in max command.\n# >>> find_max {1 5 3 9 2}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value without using the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value without using the built-in max command.\n>>> find_max {1 5 3 9 2}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers.",
        "prompt_explain": "Given a list of integers, return the product of all numbers.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 15 20 25}] == 30}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string. Words are separated by whitespace.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string. Words are separated by whitespace.",
        "prompt_explain": "Given a string, return the number of words in the string. Words are separated by whitespace.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {1 5 3 9 2}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -5 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {1 5 3 9 2}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_list {1 2 3 4}\n# 24\nproc product_of_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_list {1 2 3 4}] == 24}\nassert {[product_of_list {5 0 10}] == 0}\nassert {[product_of_list {1 1 1 1}] == 1}",
        "declaration": "proc product_of_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_list {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_list {1 2 3 4}\n24",
        "func_title": "proc product_of_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even {1 2 3 4 5 6}\n# 12\nproc sum_even {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}\nassert {[sum_even {10 20 30}] == 60}\nassert {[sum_even {1 3 5 7}] == 0}",
        "declaration": "proc sum_even {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 5 3 9 2}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -5 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 5 3 9 2}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World Tcl\"\n# 3\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World Tcl\"] == 3}\nassert {[count_words \"One two three four\"] == 4}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World Tcl\"] == 3}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World Tcl\"\n3",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_list {1 2 3 4}\n# 24\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4}] == 24}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {}] == 1}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_list {1 2 3 4}\n24",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        set sum [expr {$sum + $num}]\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_list {1 2 3 4 5}\n# 5\nproc max_list {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}\nassert {[max_list {10 20 30}] == 30}\nassert {[max_list {0 0 0}] == 0}",
        "declaration": "proc max_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_list {1 2 3 4 5}\n5",
        "func_title": "proc max_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value.\n# >>> min_list {1 2 3 4 5}\n# 1\nproc min_list {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_list {1 2 3 4 5}] == 1}\nassert {[min_list {10 20 30}] == 10}\nassert {[min_list {0 0 0}] == 0}",
        "declaration": "proc min_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_list {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value.",
        "prompt_explain": "Given a list of integers, return the minimum value.\n>>> min_list {1 2 3 4 5}\n1",
        "func_title": "proc min_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World!\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World!\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One\"] == 1}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_list {1 2 3 4 5}\n# 5\nproc max_list {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}\nassert {[max_list {10 20 30}] == 30}\nassert {[max_list {0 -1 -2}] == 0}",
        "declaration": "proc max_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_list {1 2 3 4 5}\n5",
        "func_title": "proc max_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of times a specified substring occurs in the string.\n# >>> count_substring \"hello hello hello\" \"hello\"\n# 3\nproc count_substring {str substr} {",
        "canonical_solution": "    set count 0\n    set idx [string first $substr $str]\n    while {$idx != -1} {\n        incr count\n        set idx [string first $substr $str [expr {$idx + 1}]]\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_substring \"hello hello hello\" \"hello\"] == 3}\nassert {[count_substring \"abcabcabc\" \"abc\"] == 3}\nassert {[count_substring \"xyz\" \"abc\"] == 0}",
        "declaration": "proc count_substring {str substr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_substring \"hello hello hello\" \"hello\"] == 3}",
        "prompt_text": "Given a string, return the number of times a specified substring occurs in the string.",
        "prompt_explain": "Given a string, return the number of times a specified substring occurs in the string.\n>>> count_substring \"hello hello hello\" \"hello\"\n3",
        "func_title": "proc count_substring {str substr}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a scripting language\"\n# 5\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}\nassert {[count_words \"\"] == 0}\nassert {[count_words \"OneWord\"] == 1}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a scripting language\"\n5",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 3 2 5 4}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 5 4}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 5 4}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 3 2 5 4}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value without using the built-in max command.\n# >>> find_max {1 5 3 9 2}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value without using the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value without using the built-in max command.\n>>> find_max {1 5 3 9 2}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"hello world\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world\"] == 2}\nassert {[count_words \"tcl programming is fun\"] == 4}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"hello world\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even {1 2 3 4 5 6}\n# 12\nproc sum_even {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}\nassert {[sum_even {10 20 30}] == 60}\nassert {[sum_even {1 3 5 7}] == 0}",
        "declaration": "proc sum_even {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the average value of the list.\n# >>> average {1 2 3 4 5}\n# 3\nproc average {numbers} {",
        "canonical_solution": "    set sum 0\n    set count [llength $numbers]\n    foreach num $numbers {\n        incr sum $num\n    }\n    return [expr {$sum / $count}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average {1 2 3 4 5}] == 3}\nassert {[average {10 20 30}] == 20}\nassert {[average {0}] == 0}",
        "declaration": "proc average {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average {1 2 3 4 5}] == 3}",
        "prompt_text": "Given a list of integers, return the average value of the list.",
        "prompt_explain": "Given a list of integers, return the average value of the list.\n>>> average {1 2 3 4 5}\n3",
        "func_title": "proc average {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 11 12 13}] == 22}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 3 2 8 5}\n# 8\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 8 5}] == 8}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 8 5}] == 8}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 3 2 8 5}\n8",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a scripting language\"\n# 5\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}\nassert {[count_words \"OneWord\"] == 1}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a scripting language\"\n5",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {5 0 10}] == 0}\nassert {[product_of_numbers {1 1 1 1}] == 1}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value.\n# >>> min_value {1 2 3 4 5}\n# 1\nproc min_value {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}\nassert {[min_value {10 20 30}] == 10}\nassert {[min_value {-1 -2 -3}] == -3}",
        "declaration": "proc min_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value.",
        "prompt_explain": "Given a list of integers, return the minimum value.\n>>> min_value {1 2 3 4 5}\n1",
        "func_title": "proc min_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even {1 2 3 4 5 6}\n# 12\nproc sum_even {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}\nassert {[sum_even {10 15 20 25}] == 30}\nassert {[sum_even {1 3 5 7}] == 0}",
        "declaration": "proc sum_even {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 3 2 8 5}\n# 8\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 8 5}] == 8}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 8 5}] == 8}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 3 2 8 5}\n8",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a powerful scripting language\"\n# 6\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}\nassert {[count_words \"\"] == 0}\nassert {[count_words \"OneWord\"] == 1}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a powerful scripting language\"\n6",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_list {1 2 3 4}\n# 24\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4}] == 24}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {}] == 1}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_list {1 2 3 4}\n24",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 20 30}] == 60}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {1 3 2 5 4}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 5 4}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 5 4}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {1 3 2 5 4}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_list {1 2 3 4 5}\n# 120\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {1 1 1 1}] == 1}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_list {1 2 3 4 5}\n120",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value.\n# >>> min_value {1 2 3 4 5}\n# 1\nproc min_value {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}\nassert {[min_value {10 20 30}] == 10}\nassert {[min_value {-1 -2 -3}] == -3}",
        "declaration": "proc min_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value.",
        "prompt_explain": "Given a list of integers, return the minimum value.\n>>> min_value {1 2 3 4 5}\n1",
        "func_title": "proc min_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 20 30}] == 60}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value without using the built-in max command.\n# >>> find_max {1 3 2 5 4}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 5 4}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 5 4}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value without using the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value without using the built-in max command.\n>>> find_max {1 3 2 5 4}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"hello world tcl programming\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world tcl programming\"] == 4}\nassert {[count_words \"one\"] == 1}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world tcl programming\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"hello world tcl programming\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_list {1 2 3 4 5}\n# 120\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {}] == 1}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_list {1 2 3 4 5}\n120",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a powerful scripting language\"\n# 6\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a powerful scripting language\"\n6",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {0}] == 0}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n# >>> has_close_elements {1.0 2.0 3.0} 0.5\n# false\n# >>> has_close_elements {1.0 2.8 3.0 4.0 5.0 2.0} 0.3\n# true\nproc has_close_elements {numbers threshold} {\n",
        "canonical_solution": "    set length [llength $numbers]\n    for {set i 0} {$i < $length} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $length} {incr j} {\n            set diff [expr {abs([lindex $numbers $i] - [lindex $numbers $j])}]\n            if {$diff < $threshold} {\n                return true\n            }\n        }\n    }\n    return false\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nset a {1.0 2.0 3.9 4.0 5.0 2.2}\nassert {[has_close_elements $a 0.3] == true}\nassert {[has_close_elements $a 0.05] == false}\n\nassert {[has_close_elements {1.0 2.0 5.9 4.0 5.0} 0.95] == true}\nassert {[has_close_elements {1.0 2.0 5.9 4.0 5.0} 0.8] == false}\nassert {[has_close_elements {1.0 2.0 3.0 4.0 5.0} 2.0] == true}\nassert {[has_close_elements {1.1 2.2 3.1 4.1 5.1} 1.0] == true}\nassert {[has_close_elements {1.1 2.2 3.1 4.1 5.1} 0.5] == false}\n",
        "declaration": "proc has_close_elements {numbers threshold} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[has_close_elements {1.0 2.0 3.0} 0.5] == false}\nassert {[has_close_elements {1.0 2.8 3.0 4.0 5.0 2.0} 0.3] == true}\n",
        "prompt_text": "Check if in given list of numbers, are any two numbers closer to each other than given threshold.",
        "prompt_explain": "Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n>>> has_close_elements {1.0 2.0 3.0} 0.5\nfalse\n>>> has_close_elements {1.0 2.8 3.0 4.0 5.0 2.0} 0.3\ntrue",
        "func_title": "proc has_close_elements {numbers threshold}"
    },
    {
        "prompt": "# Input to this function is a string containing multiple groups of nested parentheses. Your goal is to separate those group into separate strings and return the list of those. Separate groups are balanced (each open brace is properly closed) and not nested within each other Ignore any spaces in the input string.\n# >>> separate_paren_groups \"( ) (( )) (( )( ))\"\n# {() (()) (()())}\nproc separate_paren_groups {paren_string} {\n",
        "canonical_solution": "    set all_parens {}\n    set current_paren \"\"\n    set level 0\n    foreach chr [split $paren_string \"\"] {\n        if {$chr eq \"(\"} {\n            incr level\n            append current_paren $chr\n        }\n        if {$chr eq \")\"} {\n            incr level -1\n            append current_paren $chr\n            if {$level == 0} {\n                lappend all_parens $current_paren\n                set current_paren \"\"\n            }\n        }\n    }\n    return $all_parens\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] ne [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [separate_paren_groups \"(()()) ((())) () ((())()())\"] {(()()) ((())) () ((())()())}]}\nassert {[issame [separate_paren_groups \"() (()) ((())) (((())))\"] {() (()) ((())) (((())))}]}\nassert {[issame [separate_paren_groups \"(()(())((())))\"] {(()(())((()())))}]}\nassert {[issame [separate_paren_groups \"( ) (( )) (( )( ))\"] {() (()) (()())}]}\n",
        "declaration": "proc separate_paren_groups {paren_string} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] ne [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [separate_paren_groups \"( ) (( )) (( )( ))\"] {() (()) (()())}]}\n",
        "prompt_text": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to separate those group into separate strings and return the list of those. Separate groups are balanced (each open brace is properly closed) and not nested within each other Ignore any spaces in the input string.",
        "prompt_explain": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to separate those group into separate strings and return the list of those. Separate groups are balanced (each open brace is properly closed) and not nested within each other Ignore any spaces in the input string.\n>>> separate_paren_groups \"( ) (( )) (( )( ))\"\n{() (()) (()())}",
        "func_title": "proc separate_paren_groups {paren_string}"
    },
    {
        "prompt": "# Given a positive integer n, you have to make a pile of n levels of stones. The first level has n stones. The number of stones in the next level is: - the next odd number if n is odd. - the next even number if n is even. Return the number of stones in each level in a list, where element at index i represents the number of stones in the level (i+1).\n# Examples:\n# >>> make_a_pile 3\n# {3 5 7}\nproc make_a_pile {n} {\n",
        "canonical_solution": "    set out [list $n]\n    for {set i 1} {$i < $n} {incr i} {\n        lappend out [expr {[lindex $out end] + 2}]\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [make_a_pile 3] {3 5 7}]}\nassert {[issame [make_a_pile 4] {4 6 8 10}]}\nassert {[issame [make_a_pile 5] {5 7 9 11 13}]}\nassert {[issame [make_a_pile 6] {6 8 10 12 14 16}]}\nassert {[issame [make_a_pile 8] {8 10 12 14 16 18 20 22}]}\n",
        "declaration": "proc make_a_pile {n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [make_a_pile 3] {3 5 7}]}\n",
        "prompt_text": "Given a positive integer n, you have to make a pile of n levels of stones. The first level has n stones. The number of stones in the next level is: - the next odd number if n is odd. - the next even number if n is even. Return the number of stones in each level in a list, where element at index i represents the number of stones in the level (i+1).",
        "prompt_explain": "Given a positive integer n, you have to make a pile of n levels of stones.\nThe first level has n stones.\nThe number of stones in the next level is:\n- the next odd number if n is odd.\n- the next even number if n is even.\nReturn the number of stones in each level in a list, where element at index i represents the number of stones in the level (i+1).\n\nExamples:\n>>> make_a_pile 3\n{3 5 7}",
        "func_title": "proc make_a_pile {n}"
    },
    {
        "prompt": "# You will be given a string of words separated by commas or spaces. Your task is to split the string into words and return a list of the words.\n#\n# For example:\n# words_string \"Hi, my name is John\" == {Hi my name is John}\n# words_string \"One, two, three, four, five, six\" == {One two three four five six}\nproc words_string {s} {\n",
        "canonical_solution": "    set out {}\n    set current \"\"\n    append s \" \"\n    for {set i 0} {$i < [string length $s]} {incr i} {\n        set char [string index $s $i]\n        if {$char eq \" \" || $char eq \",\"} {\n            if {[string length $current] > 0} {\n                lappend out $current\n                set current \"\"\n            }\n        } else {\n            append current $char\n        }\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] ne [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [words_string \"Hi, my name is John\"] {Hi my name is John}]}\nassert {[issame [words_string \"One, two, three, four, five, six\"] {One two three four five six}]}\nassert {[issame [words_string \"Hi, my name\"] {Hi my name}]}\nassert {[issame [words_string \"One,, two, three, four, five, six,\"] {One two three four five six}]}\nassert {[issame [words_string \"\"] {}]}\nassert {[issame [words_string \"ahmed     , gamal\"] {ahmed gamal}]}\n",
        "declaration": "proc words_string {s} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] ne [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [words_string \"Hi, my name is John\"] {Hi my name is John}]}\nassert {[issame [words_string \"One, two, three, four, five, six\"] {One two three four five six}]}\n",
        "prompt_text": "You will be given a string of words separated by commas or spaces. Your task is to split the string into words and return a list of the words.",
        "prompt_explain": "You will be given a string of words separated by commas or spaces. Your task is to split the string into words and return a list of the words.\n\nFor example:\nwords_string \"Hi, my name is John\" == {Hi my name is John}\nwords_string \"One, two, three, four, five, six\" == {One two three four five six}",
        "func_title": "proc words_string {s}"
    },
    {
        "prompt": "# This function takes two positive numbers x and y and returns the biggest even integer number that is in the range [x, y] inclusive. If there's no such number, then the function should return -1.\n# For example:\n# choose_num 12 15 = 14\n# choose_num 13 12 = -1\nproc choose_num {x y} {\n",
        "canonical_solution": "    if {$y < $x} {return -1}\n    if {$y == $x && $y % 2 == 1} {return -1}\n    if {$y % 2 == 1} {return [expr {$y - 1}]}\n    return $y\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[choose_num 12 15] == 14}\nassert {[choose_num 13 12] == -1}\nassert {[choose_num 33 12354] == 12354}\nassert {[choose_num 5234 5233] == -1}\nassert {[choose_num 6 29] == 28}\nassert {[choose_num 27 10] == -1}\nassert {[choose_num 7 7] == -1}\nassert {[choose_num 546 546] == 546}\n",
        "declaration": "proc choose_num {x y} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[choose_num 12 15] == 14}\nassert {[choose_num 13 12] == -1}\n",
        "prompt_text": "This function takes two positive numbers x and y and returns the biggest even integer number that is in the range [x, y] inclusive. If there's no such number, then the function should return -1.",
        "prompt_explain": "This function takes two positive numbers x and y and returns the biggest even integer number that is in the range [x, y] inclusive. If there's no such number, then the function should return -1.\n\nFor example:\nchoose_num 12 15 = 14\nchoose_num 13 12 = -1",
        "func_title": "proc choose_num {x y}"
    },
    {
        "prompt": "# You are given two positive integers n and m, and your task is to compute the average of the integers from n through m (including n and m).\n# Round the answer to the nearest integer(smaller one) and convert that to binary.\n# If n is greater than m, return \"-1\".\n# Example:\n# rounded_avg 1 5 => \"11\"\n# rounded_avg 7 5 => \"-1\"\n# rounded_avg 10 20 => \"1111\"\n# rounded_avg 20 33 => \"11010\"\nproc rounded_avg {n m} {\n",
        "canonical_solution": "    if {$n > $m} { return \"-1\" }\n    set num [expr {($m + $n) / 2}]\n    set out \"\"\n    while {$num > 0} {\n        set out [expr {$num % 2}]$out\n        set num [expr {$num / 2}]\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[rounded_avg 1 5] == \"11\"}\nassert {[rounded_avg 7 13] == \"1010\"}\nassert {[rounded_avg 964 977] == \"1111001010\"}\nassert {[rounded_avg 996 997] == \"1111100100\"}\nassert {[rounded_avg 560 851] == \"1011000001\"}\nassert {[rounded_avg 185 546] == \"101101101\"}\nassert {[rounded_avg 362 496] == \"110101101\"}\nassert {[rounded_avg 350 902] == \"1001110010\"}\nassert {[rounded_avg 197 233] == \"11010111\"}\nassert {[rounded_avg 7 5] == \"-1\"}\nassert {[rounded_avg 5 1] == \"-1\"}\nassert {[rounded_avg 5 5] == \"101\"}\n",
        "declaration": "proc rounded_avg {n m} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[rounded_avg 1 5] == \"11\"}\nassert {[rounded_avg 7 5] == \"-1\"}\nassert {[rounded_avg 10 20] == \"1111\"}\nassert {[rounded_avg 20 33] == \"11010\"}\n",
        "prompt_text": "You are given two positive integers n and m, and your task is to compute the average of the integers from n through m (including n and m). Round the answer to the nearest integer(smaller one) and convert that to binary. If n is greater than m, return \"-1\".",
        "prompt_explain": "You are given two positive integers n and m, and your task is to compute the average of the integers from n through m (including n and m).\nRound the answer to the nearest integer(smaller one) and convert that to binary.\nIf n is greater than m, return \"-1\".\nExample:\nrounded_avg 1 5 => \"11\"\nrounded_avg 7 5 => \"-1\"\nrounded_avg 10 20 => \"1111\"\nrounded_avg 20 33 => \"11010\"",
        "func_title": "proc rounded_avg {n m}"
    },
    {
        "prompt": "# Given a list of positive integers x. return a sorted list of all elements that hasn't any even digit.\n# Note: Returned list should be sorted in increasing order.\n# For example:\n# >>> unique_digits {15 33 1422 1}\n# {1 15 33}\n# >>> unique_digits {152 323 1422 10}\n# {}\nproc unique_digits {x} {\n",
        "canonical_solution": "    set out {}\n    foreach num $x {\n        set u 1\n        if {$num == 0} {set u 0}\n        set temp $num\n        while {$temp > 0 && $u} {\n            if {[expr {$temp % 2}] == 0} {set u 0}\n            set temp [expr {$temp / 10}]\n        }\n        if {$u} {lappend out $num}\n    }\n    set out [lsort -integer $out]\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return 0}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {return 0}\n    }\n    return 1\n}\n\nassert {[issame [unique_digits {15 33 1422 1}] {1 15 33}]}\nassert {[issame [unique_digits {152 323 1422 10}] {}]}\nassert {[issame [unique_digits {12345 2033 111 151}] {111 151}]}\nassert {[issame [unique_digits {135 103 31}] {31 135}]}\n",
        "declaration": "proc unique_digits {x} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return 0}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {return 0}\n    }\n    return 1\n}\n\nassert {[issame [unique_digits {15 33 1422 1}] {1 15 33}]}\nassert {[issame [unique_digits {152 323 1422 10}] {}]}\n",
        "prompt_text": "Given a list of positive integers x. return a sorted list of all elements that hasn't any even digit. Note: Returned list should be sorted in increasing order.",
        "prompt_explain": "Given a list of positive integers x. return a sorted list of all elements that hasn't any even digit.\n\nNote: Returned list should be sorted in increasing order.\n\nFor example:\n>>> unique_digits {15 33 1422 1}\n{1 15 33}\n>>> unique_digits {152 323 1422 10}\n{}",
        "func_title": "proc unique_digits {x}"
    },
    {
        "prompt": "# Implement the function f that takes n as a parameter, and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even or the sum of numbers from 1 to i otherwise. i starts from 1. the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n# Example:\n# f(5) == {1 2 6 24 15}\nproc f {n} {\n",
        "canonical_solution": "    set out {}\n    set sum 0\n    set prod 1\n    for {set i 1} {$i <= $n} {incr i} {\n        set sum [expr {$sum + $i}]\n        set prod [expr {$prod * $i}]\n        if {$i % 2 == 0} {\n            lappend out $prod\n        } else {\n            lappend out $sum\n        }\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [f 5] {1 2 6 24 15}]}\nassert {[issame [f 7] {1 2 6 24 15 720 28}]}\nassert {[issame [f 1] {1}]}\nassert {[issame [f 3] {1 2 6}]}\n",
        "declaration": "proc f {n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [f 5] {1 2 6 24 15}]}\n",
        "prompt_text": "Implement the function f that takes n as a parameter, and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even or the sum of numbers from 1 to i otherwise. i starts from 1. the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).",
        "prompt_explain": "Implement the function f that takes n as a parameter, and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even or the sum of numbers from 1 to i otherwise. i starts from 1. the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\nExample:\nf(5) == {1 2 6 24 15}",
        "func_title": "proc f {n}"
    },
    {
        "prompt": "# Write a function count_nums which takes a list of integers and returns the number of elements which has a sum of digits > 0. If a number is negative, then its first signed digit will be negative: e.g. -123 has signed digits -1, 2, and 3.\n# >>> count_nums {} == 0\n# >>> count_nums {-1 11 -11} == 1\n# >>> count_nums {1 1 2} == 3\nproc count_nums {n} {\n",
        "canonical_solution": "    set num 0\n    foreach i $n {\n        if {$i > 0} {\n            incr num\n        } else {\n            set sum 0\n            set w [expr {abs($i)}]\n            while {$w >= 10} {\n                set sum [expr {$sum + $w % 10}]\n                set w [expr {$w / 10}]\n            }\n            set sum [expr {$sum - $w}]\n            if {$sum > 0} {\n                incr num\n            }\n        }\n    }\n    return $num\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_nums {}] == 0}\nassert {[count_nums {-1 -2 0}] == 0}\nassert {[count_nums {1 1 2 -2 3 4 5}] == 6}\nassert {[count_nums {1 6 9 -6 0 1 5}] == 5}\nassert {[count_nums {1 100 98 -7 1 -1}] == 4}\nassert {[count_nums {12 23 34 -45 -56 0}] == 5}\nassert {[count_nums {-0 1}] == 1}\nassert {[count_nums {1}] == 1}\n",
        "declaration": "proc count_nums {n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_nums {}] == 0}\nassert {[count_nums {-1 11 -11}] == 1}\nassert {[count_nums {1 1 2}] == 3}\n",
        "prompt_text": "Write a function count_nums which takes a list of integers and returns the number of elements which has a sum of digits > 0. If a number is negative, then its first signed digit will be negative: e.g. -123 has signed digits -1, 2, and 3.",
        "prompt_explain": "Write a function count_nums which takes a list of integers and returns\nthe number of elements which has a sum of digits > 0.\nIf a number is negative, then its first signed digit will be negative:\ne.g. -123 has signed digits -1, 2, and 3.\n>>> count_nums {} == 0\n>>> count_nums {-1 11 -11} == 1\n>>> count_nums {1 1 2} == 3",
        "func_title": "proc count_nums {n}"
    },
    {
        "prompt": "# We have a list \"arr\" of N integers arr[1], arr[2], ..., arr[N].The numbers in the list will be randomly ordered. Your task is to determine if it is possible to get a list sorted in non-decreasing order by performing the following operation on the given list: You are allowed to perform right shift operation any number of times. One right shift operation means shifting all elements of the list by one position in the right direction. The last element of the list will be moved to the starting position in the list i.e. 0th index. If it is possible to obtain the sorted list by performing the above operation then return true else return false. If the given list is empty then return true. Note: The given list is guaranteed to have unique elements. For Example:\n# move_one_ball {3 4 5 1 2} ==> true\n# Explanation: By performing 2 right shift operations, non-decreasing order can be achieved for the given list.\n# move_one_ball {3 5 4 1 2} ==> false\n# Explanation:It is not possible to get non-decreasing order for the given list by performing any number of right shift operations.\nproc move_one_ball {arr} {\n",
        "canonical_solution": "    set num 0\n    if {[llength $arr] == 0} {return true}\n    for {set i 1} {$i < [llength $arr]} {incr i} {\n        if {[lindex $arr $i] < [lindex $arr [expr {$i - 1}]]} {\n            incr num\n        }\n    }\n    if {[lindex $arr end] > [lindex $arr 0]} {\n        incr num\n    }\n    if {$num < 2} {return true}\n    return false\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[move_one_ball {3 4 5 1 2}] == true}\nassert {[move_one_ball {3 5 10 1 2}] == true}\nassert {[move_one_ball {4 3 1 2}] == false}\nassert {[move_one_ball {3 5 4 1 2}] == false}\nassert {[move_one_ball {}] == true}\n",
        "declaration": "proc move_one_ball {arr} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[move_one_ball {3 4 5 1 2}] == true}\nassert {[move_one_ball {3 5 4 1 2}] == false}\n",
        "prompt_text": "We have a list \"arr\" of N integers arr[1], arr[2], ..., arr[N].The numbers in the list will be randomly ordered. Your task is to determine if it is possible to get a list sorted in non-decreasing order by performing the following operation on the given list: You are allowed to perform right shift operation any number of times. One right shift operation means shifting all elements of the list by one position in the right direction. The last element of the list will be moved to the starting position in the list i.e. 0th index. If it is possible to obtain the sorted list by performing the above operation then return true else return false. If the given list is empty then return true. Note: The given list is guaranteed to have unique elements. For Example: ",
        "prompt_explain": "We have a list \"arr\" of N integers arr[1], arr[2], ..., arr[N].The numbers in the list will be randomly ordered. Your task is to determine if it is possible to get a list sorted in non-decreasing order by performing the following operation on the given list: You are allowed to perform right shift operation any number of times. One right shift operation means shifting all elements of the list by one position in the right direction. The last element of the list will be moved to the starting position in the list i.e. 0th index. If it is possible to obtain the sorted list by performing the above operation then return true else return false. If the given list is empty then return true. Note: The given list is guaranteed to have unique elements. For Example:\nmove_one_ball {3 4 5 1 2} ==> true\nExplanation: By performing 2 right shift operations, non-decreasing order can be achieved for the given list.\nmove_one_ball {3 5 4 1 2} ==> false\nExplanation:It is not possible to get non-decreasing order for the given list by performing any number of right shift operations.\n",
        "func_title": "proc move_one_ball {arr}"
    },
    {
        "prompt": "# Input are two strings a and b consisting only of 1s and 0s.\n# Perform binary XOR on these inputs and return result also as a string.\n# >>> string_xor \"010\" \"110\"\n# \"100\"\nproc string_xor {a b} {\n",
        "canonical_solution": "    set output \"\"\n    set len_a [string length $a]\n    set len_b [string length $b]\n    set max_len [expr {max($len_a, $len_b)}]\n    for {set i 0} {$i < $max_len} {incr i} {\n        set char_a [expr {$i < $len_a ? [string index $a $i] : \"0\"}]\n        set char_b [expr {$i < $len_b ? [string index $b $i] : \"0\"}]\n        if {$char_a == $char_b} {\n            append output \"0\"\n        } else {\n            append output \"1\"\n        }\n    }\n    return $output\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[string_xor \"111000\" \"101010\"] == \"010010\"}\nassert {[string_xor \"1\" \"1\"] == \"0\"}\nassert {[string_xor \"0101\" \"0000\"] == \"0101\"}\n",
        "declaration": "proc string_xor {a b} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[string_xor \"010\" \"110\"] == \"100\"}\n",
        "prompt_text": "Input are two strings a and b consisting only of 1s and 0s. Perform binary XOR on these inputs and return result also as a string.",
        "prompt_explain": "Input are two strings a and b consisting only of 1s and 0s.\nPerform binary XOR on these inputs and return result also as a string.\n>>> string_xor \"010\" \"110\"\n\"100\"",
        "func_title": "proc string_xor {a b}"
    },
    {
        "prompt": "# In this problem, you will implement a function that takes two lists of numbers, and determines whether it is possible to perform an exchange of elements between them to make lst1 a list of only even numbers. There is no limit on the number of exchanged elements between lst1 and lst2. If it is possible to exchange elements between the lst1 and lst2 to make all the elements of lst1 to be even, return \"YES\". Otherwise, return \"NO\".\n# For example:\n# exchange {1 2 3 4} {1 2 3 4} => \"YES\"\n# exchange {1 2 3 4} {1 5 3 4} => \"NO\"\n# It is assumed that the input lists will be non-empty.\nproc exchange {lst1 lst2} {\n",
        "canonical_solution": "    set num 0\n    foreach n $lst1 {\n        if {$n % 2 == 0} {\n            incr num\n        }\n    }\n    foreach n $lst2 {\n        if {$n % 2 == 0} {\n            incr num\n        }\n    }\n    if {$num >= [llength $lst1]} {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[exchange {1 2 3 4} {1 2 3 4}] == \"YES\"}\nassert {[exchange {1 2 3 4} {1 5 3 4}] == \"NO\"}\nassert {[exchange {1 2 3 4} {2 1 4 3}] == \"YES\"}\nassert {[exchange {5 7 3} {2 6 4}] == \"YES\"}\nassert {[exchange {5 7 3} {2 6 3}] == \"NO\"}\nassert {[exchange {3 2 6 1 8 9} {3 5 5 1 1 1}] == \"NO\"}\nassert {[exchange {100 200} {200 200}] == \"YES\"}\n",
        "declaration": "proc exchange {lst1 lst2} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[exchange {1 2 3 4} {1 2 3 4}] == \"YES\"}\nassert {[exchange {1 2 3 4} {1 5 3 4}] == \"NO\"}\n",
        "prompt_text": "In this problem, you will implement a function that takes two lists of numbers, and determines whether it is possible to perform an exchange of elements between them to make lst1 a list of only even numbers. There is no limit on the number of exchanged elements between lst1 and lst2. If it is possible to exchange elements between the lst1 and lst2 to make all the elements of lst1 to be even, return \"YES\". Otherwise, return \"NO\".",
        "prompt_explain": "In this problem, you will implement a function that takes two lists of numbers, and determines whether it is possible to perform an exchange of elements between them to make lst1 a list of only even numbers. There is no limit on the number of exchanged elements between lst1 and lst2. If it is possible to exchange elements between the lst1 and lst2 to make all the elements of lst1 to be even, return \"YES\". Otherwise, return \"NO\".\nFor example:\nexchange {1 2 3 4} {1 2 3 4} => \"YES\"\nexchange {1 2 3 4} {1 5 3 4} => \"NO\"\nIt is assumed that the input lists will be non-empty.",
        "func_title": "proc exchange {lst1 lst2}"
    },
    {
        "prompt": "# Given a string representing a space separated lowercase letters, return a dictionary\n# of the letter with the most repetition and containing the corresponding count.\n# If several letters have the same occurrence, return all of them.\n#\n# Example:\n# histogram(\"a b c\") == {a 1 b 1 c 1}\n# histogram(\"a b b a\") == {a 2 b 2}\n# histogram(\"a b c a b\") == {a 2 b 2}\n# histogram(\"b b b b a\") == {b 4}\n# histogram(\"\") == {}\nproc histogram {test} {\n",
        "canonical_solution": "    array set count {}\n    set max 0\n    foreach char [split $test \" \"] {\n        if {$char ne \"\"} {\n            incr count($char)\n            if {$count($char) > $max} {\n                set max $count($char)\n            }\n        }\n    }\n    array set out {}\n    foreach {char cnt} [array get count] {\n        if {$cnt == $max} {\n            set out($char) $cnt\n        }\n    }\n    return [array get out]\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[array size a] != [array size b]} {\n        return false\n    }\n    foreach {key val} [array get a] {\n        if {![info exists b($key)] || $b($key) != $val} {\n            return false\n        }\n    }\n    return true\n}\n\narray set expected1 {a 2 b 2}\nassert {[issame [array get [histogram \"a b b a\"]] [array get expected1]]}\n\narray set expected2 {a 2 b 2}\nassert {[issame [array get [histogram \"a b c a b\"]] [array get expected2]]}\n\narray set expected3 {a 1 b 1 c 1 d 1 g 1}\nassert {[issame [array get [histogram \"a b c d g\"]] [array get expected3]]}\n\narray set expected4 {r 1 t 1 g 1}\nassert {[issame [array get [histogram \"r t g\"]] [array get expected4]]}\n\narray set expected5 {b 4}\nassert {[issame [array get [histogram \"b b b b a\"]] [array get expected5]]}\n\narray set expected6 {}\nassert {[issame [array get [histogram \"\"]] [array get expected6]]}\n\narray set expected7 {a 1}\nassert {[issame [array get [histogram \"a\"]] [array get expected7]]}\n",
        "declaration": "proc histogram {test} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[array size a] != [array size b]} {\n        return false\n    }\n    foreach {key val} [array get a] {\n        if {![info exists b($key)] || $b($key) != $val} {\n            return false\n        }\n    }\n    return true\n}\n\narray set expected1 {a 2 b 2}\nassert {[issame [array get [histogram \"a b b a\"]] [array get expected1]]}\n\narray set expected2 {a 2 b 2}\nassert {[issame [array get [histogram \"a b c a b\"]] [array get expected2]]}\n\narray set expected3 {a 1 b 1 c 1}\nassert {[issame [array get [histogram \"a b c\"]] [array get expected3]]}\n\narray set expected4 {b 4}\nassert {[issame [array get [histogram \"b b b b a\"]] [array get expected4]]}\n\narray set expected5 {}\nassert {[issame [array get [histogram \"\"]] [array get expected5]]}\n",
        "prompt_text": "Given a string representing a space separated lowercase letters, return a dictionary of the letter with the most repetition and containing the corresponding count. If several letters have the same occurrence, return all of them.",
        "prompt_explain": "Given a string representing a space separated lowercase letters, return a dictionary\nof the letter with the most repetition and containing the corresponding count.\nIf several letters have the same occurrence, return all of them.\n\nExample:\nhistogram(\"a b c\") == {a 1 b 1 c 1}\nhistogram(\"a b b a\") == {a 2 b 2}\nhistogram(\"a b c a b\") == {a 2 b 2}\nhistogram(\"b b b b a\") == {b 4}\nhistogram(\"\") == {}",
        "func_title": "proc histogram {test}"
    },
    {
        "prompt": "# Given a list of integers nums, find the minimum sum of any non-empty sub-list of nums.\n# Example\n# minSubListSum {2 3 4 1 2 4} == 1\n# minSubListSum {-1 -2 -3} == -6\nproc minSubListSum {nums} {\n",
        "canonical_solution": "    set current [lindex $nums 0]\n    set min [lindex $nums 0]\n    set length [llength $nums]\n    for {set i 1} {$i < $length} {incr i} {\n        if {$current < 0} {\n            set current [expr {$current + [lindex $nums $i]}]\n        } else {\n            set current [lindex $nums $i]\n        }\n        if {$current < $min} {\n            set min $current\n        }\n    }\n    return $min\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[minSubListSum {2 3 4 1 2 4}] == 1}\nassert {[minSubListSum {-1 -2 -3}] == -6}\nassert {[minSubListSum {-1 -2 -3 2 -10}] == -14}\nassert {[minSubListSum {-9999999999999999}] == -9999999999999999}\nassert {[minSubListSum {0 10 20 1000000}] == 0}\nassert {[minSubListSum {-1 -2 -3 10 -5}] == -6}\nassert {[minSubListSum {100 -1 -2 -3 10 -5}] == -6}\nassert {[minSubListSum {10 11 13 8 3 4}] == 3}\nassert {[minSubListSum {100 -33 32 -1 0 -2}] == -33}\nassert {[minSubListSum {-10}] == -10}\nassert {[minSubListSum {7}] == 7}\nassert {[minSubListSum {1 -1}] == -1}\n",
        "declaration": "proc minSubListSum {nums} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[minSubListSum {2 3 4 1 2 4}] == 1}\nassert {[minSubListSum {-1 -2 -3}] == -6}\n",
        "prompt_text": "Given a list of integers nums, find the minimum sum of any non-empty sub-list of nums. Example minSubListSum {2 3 4 1 2 4} == 1 minSubListSum {-1 -2 -3} == -6",
        "prompt_explain": "Given a list of integers nums, find the minimum sum of any non-empty sub-list of nums.\nExample\nminSubListSum {2 3 4 1 2 4} == 1\nminSubListSum {-1 -2 -3} == -6",
        "func_title": "proc minSubListSum {nums}"
    },
    {
        "prompt": "# You are given a rectangular grid of wells. Each row represents a single well, and each 1 in a row represents a single unit of water. Each well has a corresponding bucket that can be used to extract water from it, and all buckets have the same capacity. Your task is to use the buckets to empty the wells. Output the number of times you need to lower the buckets.\n# Example 1:\n# Input:\n# grid : {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}\n# bucket_capacity : 1\n# Output: 6\n#\n# Example 2:\n# Input:\n# grid : {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}\n# bucket_capacity : 2\n# Output: 5\n#\n# Example 3:\n# Input:\n# grid : {{0,0,0}, {0,0,0}}\n# bucket_capacity : 5\n# Output: 0\n#\n# Constraints:\n# * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid{:,1}.length <= 10^2\n# * grid{i}{j} -> 0 | 1\n# * 1 <= capacity <= 10\nproc max_fill {grid capacity} {\n",
        "canonical_solution": "    set out 0\n    foreach row $grid {\n        set sum 0\n        foreach cell $row {\n            incr sum $cell\n        }\n        if {$sum > 0} {\n            incr out [expr {($sum - 1) / $capacity + 1}]\n        }\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_fill {{0 0 1 0} {0 1 0 0} {1 1 1 1}} 1] == 6}\nassert {[max_fill {{0 0 1 1} {0 0 0 0} {1 1 1 1} {0 1 1 1}} 2] == 5}\nassert {[max_fill {{0 0 0} {0 0 0}} 5] == 0}\nassert {[max_fill {{1 1 1 1} {1 1 1 1}} 2] == 4}\nassert {[max_fill {{1 1 1 1} {1 1 1 1}} 9] == 2}\n",
        "declaration": "proc max_fill {grid capacity} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_fill {{0 0 1 0} {0 1 0 0} {1 1 1 1}} 1] == 6}\nassert {[max_fill {{0 0 1 1} {0 0 0 0} {1 1 1 1} {0 1 1 1}} 2] == 5}\nassert {[max_fill {{0 0 0} {0 0 0}} 5] == 0}\n",
        "prompt_text": "You are given a rectangular grid of wells. Each row represents a single well, and each 1 in a row represents a single unit of water. Each well has a corresponding bucket that can be used to extract water from it, and all buckets have the same capacity. Your task is to use the buckets to empty the wells. Output the number of times you need to lower the buckets. Example 1: Input: grid : {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}} bucket_capacity : 1 Output: 6 Example 2: Input: grid : {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}} bucket_capacity : 2 Output: 5 Example 3: Input: grid : {{0,0,0}, {0,0,0}} bucket_capacity : 5 Output: 0 Constraints: * all wells have the same length * 1 <= grid.length <= 10^2 * 1 <= grid{:,1}.length <= 10^2 * grid{i}{j} -> 0 | 1 * 1 <= capacity <= 10",
        "prompt_explain": "You are given a rectangular grid of wells. Each row represents a single well, and each 1 in a row represents a single unit of water. Each well has a corresponding bucket that can be used to extract water from it, and all buckets have the same capacity. Your task is to use the buckets to empty the wells. Output the number of times you need to lower the buckets.\n\nExample 1:\nInput:\ngrid : {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}\nbucket_capacity : 1\nOutput: 6\n\nExample 2:\nInput:\ngrid : {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}\nbucket_capacity : 2\nOutput: 5\n\nExample 3:\nInput:\ngrid : {{0,0,0}, {0,0,0}}\nbucket_capacity : 5\nOutput: 0\n\nConstraints:\n* all wells have the same length\n* 1 <= grid.length <= 10^2\n* 1 <= grid{:,1}.length <= 10^2\n* grid{i}{j} -> 0 | 1\n* 1 <= capacity <= 10",
        "func_title": "proc max_fill {grid capacity}"
    },
    {
        "prompt": "# You are given a list of two strings, both strings consist of open parentheses '(' or close parentheses ')' only.\n# Your job is to check if it is possible to concatenate the two strings in some order, that the resulting string will be good.\n# A string S is considered to be good if and only if all parentheses in S are balanced. For example: the string \"(())()\" is good, while the string \"())\" is not.\n# Return \"Yes\" if there's a way to make a good string, and return \"No\" otherwise.\n#\n# Examples:\n# match_parens {{\"()(\", \")\"}} == \"Yes\"\n# match_parens {{\")\", \")\"}} == \"No\"\nproc match_parens {lst} {\n",
        "canonical_solution": "    set l1 [lindex $lst 0][lindex $lst 1]\n    set count 0\n    set can true\n    foreach char [split $l1 \"\"] {\n        if {$char eq \"(\"} {\n            incr count\n        } elseif {$char eq \")\"} {\n            incr count -1\n        }\n        if {$count < 0} {\n            set can false\n        }\n    }\n    if {$count != 0} {\n        return \"No\"\n    }\n    if {$can} {\n        return \"Yes\"\n    }\n    set l1 [lindex $lst 1][lindex $lst 0]\n    set can true\n    set count 0\n    foreach char [split $l1 \"\"] {\n        if {$char eq \"(\"} {\n            incr count\n        } elseif {$char eq \")\"} {\n            incr count -1\n        }\n        if {$count < 0} {\n            set can false\n        }\n    }\n    if {$can} {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[match_parens {{\"()(\", \")\"}}] eq \"Yes\"}\nassert {[match_parens {{\")\", \")\"}}] eq \"No\"}\nassert {[match_parens {{\"(()(())\", \"())())\"}}] eq \"No\"}\nassert {[match_parens {{\")())\", \"(()()(\"}}] eq \"Yes\"}\nassert {[match_parens {{\"(())))\", \"(()())((\"}}] eq \"Yes\"}\nassert {[match_parens {{\"()\", \"())\"}}] eq \"No\"}\nassert {[match_parens {{\"(()(\", \"()))()\"}}] eq \"Yes\"}\nassert {[match_parens {{\"((((\", \"((())\"}}] eq \"No\"}\nassert {[match_parens {{\")(()\", \"(()(\"}}] eq \"No\"}\nassert {[match_parens {{\")(\", \")(\"}}] eq \"No\"}\nassert {[match_parens {{\"(\", \")\"}}] eq \"Yes\"}\nassert {[match_parens {{\")\", \"(\"}}] eq \"Yes\"}\n",
        "declaration": "proc match_parens {lst} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[match_parens {{\"()(\", \")\"}}] eq \"Yes\"}\nassert {[match_parens {{\")\", \")\"}}] eq \"No\"}\n",
        "prompt_text": "You are given a list of two strings, both strings consist of open parentheses '(' or close parentheses ')' only. Your job is to check if it is possible to concatenate the two strings in some order, that the resulting string will be good. A string S is considered to be good if and only if all parentheses in S are balanced. For example: the string \"(())()\" is good, while the string \"())\" is not. Return \"Yes\" if there's a way to make a good string, and return \"No\" otherwise.",
        "prompt_explain": "You are given a list of two strings, both strings consist of open parentheses '(' or close parentheses ')' only.\nYour job is to check if it is possible to concatenate the two strings in some order, that the resulting string will be good.\nA string S is considered to be good if and only if all parentheses in S are balanced. For example: the string \"(())()\" is good, while the string \"())\" is not.\nReturn \"Yes\" if there's a way to make a good string, and return \"No\" otherwise.\n\nExamples:\nmatch_parens {{\"()(\", \")\"}} == \"Yes\"\nmatch_parens {{\")\", \")\"}} == \"No\"",
        "func_title": "proc match_parens {lst}"
    },
    {
        "prompt": "# Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n# Examples\n# solution {5 8 7 1} ==> 12\n# solution {3 3 3 3 3} ==> 9\n# solution {30 13 24 321} ==>0\nproc solutions {lst} {\n",
        "canonical_solution": "    set sum 0\n    set length [llength $lst]\n    for {set i 0} {$i < $length} {incr i 2} {\n        set num [lindex $lst $i]\n        if {$num % 2 == 1} {\n            incr sum $num\n        }\n    }\n    return $sum\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[solutions {5 8 7 1}] == 12}\nassert {[solutions {3 3 3 3 3}] == 9}\nassert {[solutions {30 13 24 321}] == 0}\nassert {[solutions {5 9}] == 5}\nassert {[solutions {2 4 8}] == 0}\nassert {[solutions {30 13 23 32}] == 23}\nassert {[solutions {3 13 2 9}] == 3}\n",
        "declaration": "proc solutions {lst} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[solutions {5 8 7 1}] == 12}\nassert {[solutions {3 3 3 3 3}] == 9}\nassert {[solutions {30 13 24 321}] == 0}\n",
        "prompt_text": "Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions. Examples solution {5 8 7 1} ==> 12 solution {3 3 3 3 3} ==> 9 solution {30 13 24 321} ==>0",
        "prompt_explain": "Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\nExamples\nsolution {5 8 7 1} ==> 12\nsolution {3 3 3 3 3} ==> 9\nsolution {30 13 24 321} ==>0",
        "func_title": "proc solutions {lst}"
    },
    {
        "prompt": "# Given a non-empty list of integers arr and an integer k, return the sum of the elements with at most two digits from the first k elements of arr.\n# Example:\n# Input: arr = {111 21 3 4000 5 6 7 8 9}, k = 4\n# Output: 24 # sum of 21 + 3\n# Constraints:\n# 1. 1 <= len(arr) <= 100\n# 2. 1 <= k <= len(arr)\nproc add_elements {arr k} {\n",
        "canonical_solution": "    set sum 0\n    for {set i 0} {$i < $k} {incr i} {\n        set num [lindex $arr $i]\n        if {$num >= -99 && $num <= 99} {\n            incr sum $num\n        }\n    }\n    return $sum\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[add_elements {1 -2 -3 41 57 76 87 88 99} 3] == -4}\nassert {[add_elements {111 121 3 4000 5 6} 2] == 0}\nassert {[add_elements {11 21 3 90 5 6 7 8 9} 4] == 125}\nassert {[add_elements {111 21 3 4000 5 6 7 8 9} 4] == 24}\nassert {[add_elements {1} 1] == 1}\n",
        "declaration": "proc add_elements {arr k} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[add_elements {111 21 3 4000 5 6 7 8 9} 4] == 24}\n",
        "prompt_text": "Given a non-empty list of integers arr and an integer k, return the sum of the elements with at most two digits from the first k elements of arr. Example: Input: arr = {111 21 3 4000 5 6 7 8 9}, k = 4 Output: 24 # sum of 21 + 3 Constraints: 1. 1 <= len(arr) <= 100 2. 1 <= k <= len(arr)",
        "prompt_explain": "Given a non-empty list of integers arr and an integer k, return the sum of the elements with at most two digits from the first k elements of arr.\n\nExample:\n\nInput: arr = {111 21 3 4000 5 6 7 8 9}, k = 4\nOutput: 24 # sum of 21 + 3\n\nConstraints:\n1. 1 <= len(arr) <= 100\n2. 1 <= k <= len(arr)",
        "func_title": "proc add_elements {arr k}"
    },
    {
        "prompt": "# Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n# The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n# as follows: start with any positive integer n. Then each term is obtained from the\n# previous term as follows: if the previous term is even, the next term is one half of\n# the previous term. If the previous term is odd, the next term is 3 times the previous\n# term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n# Note:\n# 1. Collatz(1) is {1}.\n# 2. returned list sorted in increasing order.\n# For example:\n# get_odd_collatz 5 returns {1 5} // The collatz sequence for 5 is {5 16 8 4 2 1}, so the odd numbers are only 1, and 5.\nproc get_odd_collatz {n} {\n",
        "canonical_solution": "    set out {1}\n    while {$n != 1} {\n        if {$n % 2 == 1} {\n            lappend out $n\n            set n [expr {$n * 3 + 1}]\n        } else {\n            set n [expr {$n / 2}]\n        }\n    }\n    set out [lsort -integer $out]\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [get_odd_collatz 14] {1 5 7 11 13 17}]}\nassert {[issame [get_odd_collatz 5] {1 5}]}\nassert {[issame [get_odd_collatz 12] {1 3 5}]}\nassert {[issame [get_odd_collatz 1] {1}]}\n",
        "declaration": "proc get_odd_collatz {n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [get_odd_collatz 5] {1 5}]}\n",
        "prompt_text": "Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence. The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined as follows: start with any positive integer n. Then each term is obtained from the previous term as follows: if the previous term is even, the next term is one half of the previous term. If the previous term is odd, the next term is 3 times the previous term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1. Note: 1. Collatz(1) is {1}. 2. returned list sorted in increasing order.",
        "prompt_explain": "Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\nThe Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\nas follows: start with any positive integer n. Then each term is obtained from the\nprevious term as follows: if the previous term is even, the next term is one half of\nthe previous term. If the previous term is odd, the next term is 3 times the previous\nterm plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\nNote:\n1. Collatz(1) is {1}.\n2. returned list sorted in increasing order.\n\nFor example:\nget_odd_collatz 5 returns {1 5} // The collatz sequence for 5 is {5 16 8 4 2 1}, so the odd numbers are only 1, and 5.",
        "func_title": "proc get_odd_collatz {n}"
    },
    {
        "prompt": "# You have to write a function which validates a given date string and returns true if the date is valid otherwise false. The date is valid if all of the following rules are satisfied: 1. The date string is not empty. 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2. 3. The months should not be less than 1 or higher than 12. 4. The date should be in the format: mm-dd-yyyy\n# for example:\n# valid_date \"03-11-2000\" => true\n# valid_date \"15-01-2012\" => false\n# valid_date \"04-0-2040\" => false\n# valid_date \"06-04-2020\" => true\n# valid_date \"06/04/2020\" => false\nproc valid_date {date} {\n",
        "canonical_solution": "    if {[string length $date] != 10} {return false}\n    for {set i 0} {$i < 10} {incr i} {\n        if {$i == 2 || $i == 5} {\n            if {[string index $date $i] != \"-\"} {return false}\n        } else {\n            if {![string is digit -strict [string index $date $i]]} {return false}\n        }\n    }\n    set mm [string range $date 0 1]\n    set dd [string range $date 3 4]\n    set yy [string range $date 6 9]\n    if {$mm < 1 || $mm > 12} {return false}\n    if {$dd < 1 || $dd > 31} {return false}\n    if {$dd == 31 && ($mm == 4 || $mm == 6 || $mm == 9 || $mm == 11 || $mm == 2)} {return false}\n    if {$dd == 30 && $mm == 2} {return false}\n    return true\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[valid_date \"03-11-2000\"] == true}\nassert {[valid_date \"15-01-2012\"] == false}\nassert {[valid_date \"04-0-2040\"] == false}\nassert {[valid_date \"06-04-2020\"] == true}\nassert {[valid_date \"01-01-2007\"] == true}\nassert {[valid_date \"03-32-2011\"] == false}\nassert {[valid_date \"\"] == false}\nassert {[valid_date \"04-31-3000\"] == false}\nassert {[valid_date \"06-06-2005\"] == true}\nassert {[valid_date \"21-31-2000\"] == false}\nassert {[valid_date \"04-12-2003\"] == true}\nassert {[valid_date \"04122003\"] == false}\nassert {[valid_date \"20030412\"] == false}\nassert {[valid_date \"2003-04\"] == false}\nassert {[valid_date \"2003-04-12\"] == false}\nassert {[valid_date \"04-2003\"] == false}\n",
        "declaration": "proc valid_date {date} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[valid_date \"03-11-2000\"] == true}\nassert {[valid_date \"15-01-2012\"] == false}\nassert {[valid_date \"04-0-2040\"] == false}\nassert {[valid_date \"06-04-2020\"] == true}\nassert {[valid_date \"06/04/2020\"] == false}\n",
        "prompt_text": "You have to write a function which validates a given date string and returns true if the date is valid otherwise false. The date is valid if all of the following rules are satisfied: 1. The date string is not empty. 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2. 3. The months should not be less than 1 or higher than 12. 4. The date should be in the format: mm-dd-yyyy",
        "prompt_explain": "You have to write a function which validates a given date string and returns true if the date is valid otherwise false. The date is valid if all of the following rules are satisfied: 1. The date string is not empty. 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2. 3. The months should not be less than 1 or higher than 12. 4. The date should be in the format: mm-dd-yyyy\n\nfor example:\nvalid_date \"03-11-2000\" => true\n\nvalid_date \"15-01-2012\" => false\n\nvalid_date \"04-0-2040\" => false\n\nvalid_date \"06-04-2020\" => true\n\nvalid_date \"06/04/2020\" => false",
        "func_title": "proc valid_date {date}"
    },
    {
        "prompt": "# Given a list of numbers, return whether or not they are sorted in ascending order. If list has more than 1 duplicate of the same number, return false. Assume no negative numbers and only integers.\n# Examples\n# is_sorted {5}  true\n# is_sorted {1 2 3 4 5}  true\n# is_sorted {1 3 2 4 5}  false\n# is_sorted {1 2 3 4 5 6}  true\n# is_sorted {1 2 3 4 5 6 7}  true\n# is_sorted {1 3 2 4 5 6 7}  false\n# is_sorted {1 2 2 3 3 4}  true\n# is_sorted {1 2 2 2 3 4}  false\nproc is_sorted {lst} {\n",
        "canonical_solution": "    set length [llength $lst]\n    for {set i 1} {$i < $length} {incr i} {\n        if {[lindex $lst $i] < [lindex $lst [expr {$i - 1}]]} {\n            return false\n        }\n        if {$i >= 2 && [lindex $lst $i] == [lindex $lst [expr {$i - 1}]] && [lindex $lst $i] == [lindex $lst [expr {$i - 2}]]} {\n            return false\n        }\n    }\n    return true\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_sorted {5}] == true}\nassert {[is_sorted {1 2 3 4 5}] == true}\nassert {[is_sorted {1 3 2 4 5}] == false}\nassert {[is_sorted {1 2 3 4 5 6}] == true}\nassert {[is_sorted {1 2 3 4 5 6 7}] == true}\nassert {[is_sorted {1 3 2 4 5 6 7}] == false}\nassert {[is_sorted {}] == true}\nassert {[is_sorted {1}] == true}\nassert {[is_sorted {3 2 1}] == false}\nassert {[is_sorted {1 2 2 2 3 4}] == false}\nassert {[is_sorted {1 2 3 3 3 4}] == false}\nassert {[is_sorted {1 2 2 3 3 4}] == true}\nassert {[is_sorted {1 2 3 4}] == true}\n",
        "declaration": "proc is_sorted {lst} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_sorted {5}] == true}\nassert {[is_sorted {1 2 3 4 5}] == true}\nassert {[is_sorted {1 3 2 4 5}] == false}\nassert {[is_sorted {1 2 3 4 5 6}] == true}\nassert {[is_sorted {1 2 3 4 5 6 7}] == true}\nassert {[is_sorted {1 3 2 4 5 6 7}] == false}\nassert {[is_sorted {1 2 2 2 3 4}] == false}\nassert {[is_sorted {1 2 2 3 3 4}] == true}\n",
        "prompt_text": "Given a list of numbers, return whether or not they are sorted in ascending order. If list has more than 1 duplicate of the same number, return false. Assume no negative numbers and only integers.",
        "prompt_explain": "Given a list of numbers, return whether or not they are sorted in ascending order. If list has more than 1 duplicate of the same number, return false. Assume no negative numbers and only integers.\n\nExamples\nis_sorted {5}  true\nis_sorted {1 2 3 4 5}  true\nis_sorted {1 3 2 4 5}  false\nis_sorted {1 2 3 4 5 6}  true\nis_sorted {1 2 3 4 5 6 7}  true\nis_sorted {1 3 2 4 5 6 7}  false\nis_sorted {1 2 2 3 3 4}  true\nis_sorted {1 2 2 2 3 4}  false",
        "func_title": "proc is_sorted {lst}"
    },
    {
        "prompt": "# You are given two intervals, where each interval is a pair of integers. For example, interval = (start, end) = (1, 2). The given intervals are closed which means that the interval (start, end) includes both start and end. For each given interval, it is assumed that its start is less or equal its end. Your task is to determine whether the length of intersection of these two intervals is a prime number. Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3) which its length is 1, which not a prime number. If the length of the intersection is a prime number, return \"YES\", otherwise, return \"NO\". If the two intervals don't intersect, return \"NO\".\n# {input/output} samples:\n# intersection {1 2} {2 3} ==> \"NO\"\n# intersection {-1 1} {0 4} ==> \"NO\"\n# intersection {-3 -1} {-5 5} ==> \"YES\"\nproc intersection {interval1 interval2} {\n",
        "canonical_solution": "    set inter1 [expr {max([lindex $interval1 0], [lindex $interval2 0])}]\n    set inter2 [expr {min([lindex $interval1 1], [lindex $interval2 1])}]\n    set l [expr {$inter2 - $inter1}]\n    if {$l < 2} { return \"NO\" }\n    for {set i 2} {$i * $i <= $l} {incr i} {\n        if {$l % $i == 0} { return \"NO\" }\n    }\n    return \"YES\"\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[intersection {1 2} {2 3}] == \"NO\"}\nassert {[intersection {-1 1} {0 4}] == \"NO\"}\nassert {[intersection {-3 -1} {-5 5}] == \"YES\"}\nassert {[intersection {-2 2} {-4 0}] == \"YES\"}\nassert {[intersection {-11 2} {-1 -1}] == \"NO\"}\nassert {[intersection {1 2} {3 5}] == \"NO\"}\nassert {[intersection {1 2} {1 2}] == \"NO\"}\nassert {[intersection {-2 -2} {-3 -2}] == \"NO\"}\n",
        "declaration": "proc intersection {interval1 interval2} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[intersection {1 2} {2 3}] == \"NO\"}\nassert {[intersection {-1 1} {0 4}] == \"NO\"}\nassert {[intersection {-3 -1} {-5 5}] == \"YES\"}\n",
        "prompt_text": "You are given two intervals, where each interval is a pair of integers. For example, interval = (start, end) = (1, 2). The given intervals are closed which means that the interval (start, end) includes both start and end. For each given interval, it is assumed that its start is less or equal its end. Your task is to determine whether the length of intersection of these two intervals is a prime number. Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3) which its length is 1, which not a prime number. If the length of the intersection is a prime number, return \"YES\", otherwise, return \"NO\". If the two intervals don't intersect, return \"NO\".   {input/output} samples:",
        "prompt_explain": "You are given two intervals,\nwhere each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\nThe given intervals are closed which means that the interval (start, end)\nincludes both start and end.\nFor each given interval, it is assumed that its start is less or equal its end.\nYour task is to determine whether the length of intersection of these two\nintervals is a prime number.\nExample, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\nwhich its length is 1, which not a prime number.\nIf the length of the intersection is a prime number, return \"YES\",\notherwise, return \"NO\".\nIf the two intervals don't intersect, return \"NO\".\n\n\n{input/output} samples:\nintersection {1 2} {2 3} ==> \"NO\"\nintersection {-1 1} {0 4} ==> \"NO\"\nintersection {-3 -1} {-5 5} ==> \"YES\"",
        "func_title": "proc intersection {interval1 interval2}"
    },
    {
        "prompt": "# You are given a list arr of integers and you need to return sum of magnitudes of integers multiplied by product of all signs\n# of each number in the list, represented by 1, -1 or 0.\n# Note: return -32768 for empty arr.\n#\n# Example:\n# >>> prod_signs {1 2 2 -4} == -9\n# >>> prod_signs {0 1} == 0\n# >>> prod_signs {} == -32768\nproc prod_signs {arr} {\n",
        "canonical_solution": "    if {[llength $arr] == 0} {return -32768}\n    set sum 0\n    set prods 1\n    foreach num $arr {\n        set sum [expr {$sum + abs($num)}]\n        if {$num == 0} {set prods 0}\n        if {$num < 0} {set prods [expr {-$prods}]}\n    }\n    return [expr {$sum * $prods}]\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[prod_signs {1 2 2 -4}] == -9}\nassert {[prod_signs {0 1}] == 0}\nassert {[prod_signs {1 1 1 2 3 -1 1}] == -10}\nassert {[prod_signs {}] == -32768}\nassert {[prod_signs {2 4 1 2 -1 -1 9}] == 20}\nassert {[prod_signs {-1 1 -1 1}] == 4}\nassert {[prod_signs {-1 1 1 1}] == -4}\nassert {[prod_signs {-1 1 1 0}] == 0}\n",
        "declaration": "proc prod_signs {arr} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[prod_signs {1 2 2 -4}] == -9}\nassert {[prod_signs {0 1}] == 0}\nassert {[prod_signs {}] == -32768}\n",
        "prompt_text": "You are given a list arr of integers and you need to return sum of magnitudes of integers multiplied by product of all signs of each number in the list, represented by 1, -1 or 0. Note: return -32768 for empty arr.",
        "prompt_explain": "You are given a list arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the list, represented by 1, -1 or 0.\nNote: return -32768 for empty arr.\n\nExample:\n>>> prod_signs {1 2 2 -4} == -9\n>>> prod_signs {0 1} == 0\n>>> prod_signs {} == -32768",
        "func_title": "proc prod_signs {arr}"
    },
    {
        "prompt": "# Return a greatest common divisor of two integers a and b\n# >>> greatest_common_divisor 3 5\n# 1\n# >>> greatest_common_divisor 25 15\n# 5\nproc greatest_common_divisor {a b} {\n",
        "canonical_solution": "    while {$b != 0} {\n        set temp $b\n        set b [expr {$a % $b}]\n        set a $temp\n    }\n    return $a\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[greatest_common_divisor 3 7] == 1}\nassert {[greatest_common_divisor 10 15] == 5}\nassert {[greatest_common_divisor 49 14] == 7}\nassert {[greatest_common_divisor 144 60] == 12}\n",
        "declaration": "proc greatest_common_divisor {a b} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[greatest_common_divisor 3 5] == 1}\nassert {[greatest_common_divisor 25 15] == 5}\n",
        "prompt_text": "Return a greatest common divisor of two integers a and b",
        "prompt_explain": "Return a greatest common divisor of two integers a and b\n>>> greatest_common_divisor 3 5\n1\n>>> greatest_common_divisor 25 15\n5",
        "func_title": "proc greatest_common_divisor {a b}"
    },
    {
        "prompt": "# Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in the last couple centuries. However, what people don't know is Tribonacci sequence.\n# Tribonacci sequence is defined by the recurrence:\n# tri(1) = 3\n# tri(n) = 1 + n / 2, if n is even.\n# tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n# For example:\n# tri(2) = 1 + (2 / 2) = 2\n# tri(4) = 3\n# tri(3) = tri(2) + tri(1) + tri(4)\n#        = 2 + 3 + 3 = 8\n# You are given a non-negative integer number n, you have to a return a list of the\n# first n + 1 numbers of the Tribonacci sequence.\n# Examples:\n# tri(3) = {1, 3, 2, 8}\nproc tri {n} {\n",
        "canonical_solution": "    set out {1 3}\n    if {$n == 0} {return {1}}\n    for {set i 2} {$i <= $n} {incr i} {\n        if {$i % 2 == 0} {\n            lappend out [expr {1 + $i / 2}]\n        } else {\n            lappend out [expr {[lindex $out [expr {$i - 1}]] + [lindex $out [expr {$i - 2}]] + 1 + ($i + 1) / 2}]\n        }\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [tri 3] {1 3 2 8}]}\nassert {[issame [tri 4] {1 3 2 8 3}]}\nassert {[issame [tri 5] {1 3 2 8 3 15}]}\nassert {[issame [tri 6] {1 3 2 8 3 15 4}]}\nassert {[issame [tri 7] {1 3 2 8 3 15 4 24}]}\nassert {[issame [tri 8] {1 3 2 8 3 15 4 24 5}]}\nassert {[issame [tri 9] {1 3 2 8 3 15 4 24 5 35}]}\nassert {[issame [tri 20] {1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11}]}\nassert {[issame [tri 0] {1}]}\nassert {[issame [tri 1] {1 3}]}\n",
        "declaration": "proc tri {n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [tri 3] {1 3 2 8}]}\n",
        "prompt_text": "Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in the last couple centuries. However, what people don't know is Tribonacci sequence. Tribonacci sequence is defined by the recurrence:",
        "prompt_explain": "Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in\nthe last couple centuries. However, what people don't know is Tribonacci sequence.\nTribonacci sequence is defined by the recurrence:\ntri(1) = 3\ntri(n) = 1 + n / 2, if n is even.\ntri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\nFor example:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nYou are given a non-negative integer number n, you have to a return a list of the\nfirst n + 1 numbers of the Tribonacci sequence.\nExamples:\ntri(3) = {1, 3, 2, 8}",
        "func_title": "proc tri {n}"
    },
    {
        "prompt": "# Given a positive integer n, return the product of the odd digits. Return 0 if all digits are even.\n# For example:\n# digits(1)  == 1\n# digits(4)  == 0\n# digits(235) == 15\nproc digits {n} {\n",
        "canonical_solution": "    set prod 1\n    set has 0\n    foreach digit [split $n {}] {\n        if {$digit % 2 == 1} {\n            set has 1\n            set prod [expr {$prod * $digit}]\n        }\n    }\n    if {$has == 0} {return 0}\n    return $prod\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[digits 5] == 5}\nassert {[digits 54] == 5}\nassert {[digits 120] == 1}\nassert {[digits 5014] == 5}\nassert {[digits 98765] == 315}\nassert {[digits 5576543] == 2625}\nassert {[digits 2468] == 0}\n",
        "declaration": "proc digits {n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[digits 1] == 1}\nassert {[digits 4] == 0}\nassert {[digits 235] == 15}\n",
        "prompt_text": "Given a positive integer n, return the product of the odd digits. Return 0 if all digits are even.",
        "prompt_explain": "Given a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits(1)  == 1\ndigits(4)  == 0\ndigits(235) == 15",
        "func_title": "proc digits {n}"
    },
    {
        "prompt": "# You are given a list of numbers.\n# You need to return the sum of squared numbers in the given list,\n# round each element in the list to the upper int(Ceiling) first.\n# Examples:\n# For lst = {1,2,3} the output should be 14\n# For lst = {1,4,9} the output should be 98\n# For lst = {1,3,5,7} the output should be 84\n# For lst = {1.4,4.2,0} the output should be 29\n# For lst = {-2.4,1,1} the output should be 6\nproc sum_squares {lst} {\n",
        "canonical_solution": "    set sum 0\n    foreach num $lst {\n        set ceil_num [expr {ceil($num)}]\n        set sum [expr {$sum + $ceil_num * $ceil_num}]\n    }\n    return $sum\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_squares {1 2 3}] == 14}\nassert {[sum_squares {1.0 2 3}] == 14}\nassert {[sum_squares {1 3 5 7}] == 84}\nassert {[sum_squares {1.4 4.2 0}] == 29}\nassert {[sum_squares {-2.4 1 1}] == 6}\nassert {[sum_squares {100 1 15 2}] == 10230}\nassert {[sum_squares {10000 10000}] == 200000000}\nassert {[sum_squares {-1.4 4.6 6.3}] == 75}\nassert {[sum_squares {-1.4 17.9 18.9 19.9}] == 1086}\nassert {[sum_squares {0}] == 0}\nassert {[sum_squares {-1}] == 1}\nassert {[sum_squares {-1 1 0}] == 2}\n",
        "declaration": "proc sum_squares {lst} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_squares {1 2 3}] == 14}\nassert {[sum_squares {1 4 9}] == 98}\nassert {[sum_squares {1 3 5 7}] == 84}\nassert {[sum_squares {1.4 4.2 0}] == 29}\nassert {[sum_squares {-2.4 1 1}] == 6}\n",
        "prompt_text": "You are given a list of numbers. You need to return the sum of squared numbers in the given list, round each element in the list to the upper int(Ceiling) first. Examples: For lst = {1,2,3} the output should be 14 For lst = {1,4,9} the output should be 98 For lst = {1,3,5,7} the output should be 84 For lst = {1.4,4.2,0} the output should be 29 For lst = {-2.4,1,1} the output should be 6  ",
        "prompt_explain": "You are given a list of numbers.\nYou need to return the sum of squared numbers in the given list,\nround each element in the list to the upper int(Ceiling) first.\nExamples:\nFor lst = {1,2,3} the output should be 14\nFor lst = {1,4,9} the output should be 98\nFor lst = {1,3,5,7} the output should be 84\nFor lst = {1.4,4.2,0} the output should be 29\nFor lst = {-2.4,1,1} the output should be 6\n\n",
        "func_title": "proc sum_squares {lst}"
    },
    {
        "prompt": "# Create a function that returns true if the last character of a given string is an alphabetical character and is not a part of a word, and false otherwise. Note: \"word\" is a group of characters separated by space. \n# Examples:\n# check_if_last_char_is_a_letter \"apple pie\"  false\n# check_if_last_char_is_a_letter \"apple pi e\"  true\n# check_if_last_char_is_a_letter \"apple pi e \"  false\n# check_if_last_char_is_a_letter \"\"  false\nproc check_if_last_char_is_a_letter {txt} {\n",
        "canonical_solution": "    set length [string length $txt]\n    if {$length == 0} {return false}\n    set chr [string index $txt [expr {$length - 1}]]\n    if {![string is alpha $chr]} {return false}\n    if {$length == 1} {return true}\n    set chr [string index $txt [expr {$length - 2}]]\n    if {[string is alpha $chr]} {return false}\n    return true\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_if_last_char_is_a_letter \"apple\"] == false}\nassert {[check_if_last_char_is_a_letter \"apple pi e\"] == true}\nassert {[check_if_last_char_is_a_letter \"eeeee\"] == false}\nassert {[check_if_last_char_is_a_letter \"A\"] == true}\nassert {[check_if_last_char_is_a_letter \"Pumpkin pie \"] == false}\nassert {[check_if_last_char_is_a_letter \"Pumpkin pie 1\"] == false}\nassert {[check_if_last_char_is_a_letter \"\"] == false}\nassert {[check_if_last_char_is_a_letter \"eeeee e \"] == false}\nassert {[check_if_last_char_is_a_letter \"apple pie\"] == false}\nassert {[check_if_last_char_is_a_letter \"apple pi e \"] == false}\n",
        "declaration": "proc check_if_last_char_is_a_letter {txt} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_if_last_char_is_a_letter \"apple pi e\"] == true}\nassert {[check_if_last_char_is_a_letter \"\"] == false}\nassert {[check_if_last_char_is_a_letter \"apple pie\"] == false}\nassert {[check_if_last_char_is_a_letter \"apple pi e \"] == false}\n",
        "prompt_text": "Create a function that returns true if the last character of a given string is an alphabetical character and is not a part of a word, and false otherwise. Note: \"word\" is a group of characters separated by space.",
        "prompt_explain": "Create a function that returns true if the last character\nof a given string is an alphabetical character and is not\na part of a word, and false otherwise.\nNote: \"word\" is a group of characters separated by space.\n\nExamples:\ncheck_if_last_char_is_a_letter \"apple pie\"  false\ncheck_if_last_char_is_a_letter \"apple pi e\"  true\ncheck_if_last_char_is_a_letter \"apple pi e \"  false\ncheck_if_last_char_is_a_letter \"\"  false",
        "func_title": "proc check_if_last_char_is_a_letter {txt}"
    },
    {
        "prompt": "# Create a function which returns the largest index of an element which is not greater than or equal to the element immediately preceding it. If no such element exists then return -1. The given list will not contain duplicate values.\n# Examples:\n# can_arrange {1 2 4 3 5} = 3\n# can_arrange {1 2 3} = -1\nproc can_arrange {arr} {\n",
        "canonical_solution": "    set max -1\n    set length [llength $arr]\n    for {set i 0} {$i < $length} {incr i} {\n        if {[lindex $arr $i] <= $i} {\n            set max $i\n        }\n    }\n    return $max\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[can_arrange {1 2 4 3 5}] == 3}\nassert {[can_arrange {1 2 4 5}] == -1}\nassert {[can_arrange {1 4 2 5 6 7 8 9 10}] == 2}\nassert {[can_arrange {4 8 5 7 3}] == 4}\nassert {[can_arrange {}] == -1}\n",
        "declaration": "proc can_arrange {arr} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[can_arrange {1 2 4 3 5}] == 3}\nassert {[can_arrange {1 2 3}] == -1}\n",
        "prompt_text": "Create a function which returns the largest index of an element which is not greater than or equal to the element immediately preceding it. If no such element exists then return -1. The given list will not contain duplicate values.",
        "prompt_explain": "Create a function which returns the largest index of an element which\nis not greater than or equal to the element immediately preceding it. If\nno such element exists then return -1. The given list will not contain\nduplicate values.\n\nExamples:\ncan_arrange {1 2 4 3 5} = 3\ncan_arrange {1 2 3} = -1",
        "func_title": "proc can_arrange {arr}"
    },
    {
        "prompt": "# Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n# Example\n# is_equal_to_sum_even 4 == false\n# is_equal_to_sum_even 6 == false\n# is_equal_to_sum_even 8 == true\nproc is_equal_to_sum_even {n} {\n",
        "canonical_solution": "    if {$n % 2 == 0 && $n >= 8} {\n        return true\n    }\n    return false\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_equal_to_sum_even 4] == false}\nassert {[is_equal_to_sum_even 6] == false}\nassert {[is_equal_to_sum_even 8] == true}\nassert {[is_equal_to_sum_even 10] == true}\nassert {[is_equal_to_sum_even 11] == false}\nassert {[is_equal_to_sum_even 12] == true}\nassert {[is_equal_to_sum_even 13] == false}\nassert {[is_equal_to_sum_even 16] == true}\n",
        "declaration": "proc is_equal_to_sum_even {n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_equal_to_sum_even 4] == false}\nassert {[is_equal_to_sum_even 6] == false}\nassert {[is_equal_to_sum_even 8] == true}\n",
        "prompt_text": "Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers",
        "prompt_explain": "Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\nExample\nis_equal_to_sum_even 4 == false\nis_equal_to_sum_even 6 == false\nis_equal_to_sum_even 8 == true",
        "func_title": "proc is_equal_to_sum_even {n}"
    },
    {
        "prompt": "# The Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0\n# For example:\n# >>> special_factorial 4\n# 288\n# The function will receive an integer as input and should return the special factorial of this integer.\nproc special_factorial {n} {\n",
        "canonical_solution": "    set fact 1\n    set bfact 1\n    for {set i 1} {$i <= $n} {incr i} {\n        set fact [expr {$fact * $i}]\n        set bfact [expr {$bfact * $fact}]\n    }\n    return $bfact\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[special_factorial 4] == 288}\nassert {[special_factorial 5] == 34560}\nassert {[special_factorial 7] == 125411328000}\nassert {[special_factorial 1] == 1}\n",
        "declaration": "proc special_factorial {n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[special_factorial 4] == 288}\n",
        "prompt_text": "The Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0 ",
        "prompt_explain": "The Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial 4\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.",
        "func_title": "proc special_factorial {n}"
    },
    {
        "prompt": "# Return list of all prefixes from shortest to longest of the input string\n# >>> all_prefixes \"abc\"\n# {a ab abc}\nproc all_prefixes {str} {\n",
        "canonical_solution": "    set out {}\n    set current \"\"\n    for {set i 0} {$i < [string length $str]} {incr i} {\n        append current [string index $str $i]\n        lappend out $current\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] ne [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [all_prefixes \"\"] {}]}\nassert {[issame [all_prefixes \"asdfgh\"] {a as asd asdf asdfg asdfgh}]}\nassert {[issame [all_prefixes \"WWW\"] {W WW WWW}]}\n",
        "declaration": "proc all_prefixes {str} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] ne [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [all_prefixes \"abc\"] {a ab abc}]}\n",
        "prompt_text": "Return list of all prefixes from shortest to longest of the input string",
        "prompt_explain": "Return list of all prefixes from shortest to longest of the input string\n>>> all_prefixes \"abc\"\n{a ab abc}",
        "func_title": "proc all_prefixes {str}"
    },
    {
        "prompt": "# Create a function which takes a string representing a file's name, and returns \"Yes\" if the the file's name is valid, and returns \"No\" otherwise. A file's name is considered to be valid if and only if all the following conditions are met: - There should not be more than three digits ('0'-'9') in the file's name. - The file's name contains exactly one dot \".\" - The substring before the dot should not be empty, and it starts with a letter from the latin alphapet ('a'-'z' and 'A'-'Z'). - The substring after the dot should be one of these: {'txt\", \"exe\", \"dll\"}\n# Examples:\n# file_name_check \"example.txt\" => \"Yes\"\n# file_name_check \"1example.dll\"  => \"No\" // (the name should start with a latin alphapet letter)\nproc file_name_check {file_name} {\n",
        "canonical_solution": "    set numdigit 0\n    set numdot 0\n    if {[string length $file_name] < 5} {return \"No\"}\n    set w [string index $file_name 0]\n    if {![string is alpha $w]} {return \"No\"}\n    set last [string range $file_name end-3 end]\n    if {$last ne \".txt\" && $last ne \".exe\" && $last ne \".dll\"} {return \"No\"}\n    foreach char [split $file_name \"\"] {\n        if {[string is digit $char]} {incr numdigit}\n        if {$char eq \".\"} {incr numdot}\n    }\n    if {$numdigit > 3 || $numdot != 1} {return \"No\"}\n    return \"Yes\"\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[file_name_check \"example.txt\"] == \"Yes\"}\nassert {[file_name_check \"1example.dll\"] == \"No\"}\nassert {[file_name_check \"s1sdf3.asd\"] == \"No\"}\nassert {[file_name_check \"K.dll\"] == \"Yes\"}\nassert {[file_name_check \"MY16FILE3.exe\"] == \"Yes\"}\nassert {[file_name_check \"His12FILE94.exe\"] == \"No\"}\nassert {[file_name_check \"_Y.txt\"] == \"No\"}\nassert {[file_name_check \"?aREYA.exe\"] == \"No\"}\nassert {[file_name_check \"/this_is_valid.dll\"] == \"No\"}\nassert {[file_name_check \"this_is_valid.wow\"] == \"No\"}\nassert {[file_name_check \"this_is_valid.txt\"] == \"Yes\"}\nassert {[file_name_check \"this_is_valid.txtexe\"] == \"No\"}\nassert {[file_name_check \"#this2_i4s_5valid.ten\"] == \"No\"}\nassert {[file_name_check \"@this1_is6_valid.exe\"] == \"No\"}\nassert {[file_name_check \"this_is_12valid.6exe4.txt\"] == \"No\"}\nassert {[file_name_check \"all.exe.txt\"] == \"No\"}\nassert {[file_name_check \"I563_No.exe\"] == \"Yes\"}\nassert {[file_name_check \"Is3youfault.txt\"] == \"Yes\"}\nassert {[file_name_check \"no_one#knows.dll\"] == \"Yes\"}\nassert {[file_name_check \"1I563_Yes3.exe\"] == \"No\"}\nassert {[file_name_check \"I563_Yes3.txtt\"] == \"No\"}\nassert {[file_name_check \"final..txt\"] == \"No\"}\nassert {[file_name_check \"final132\"] == \"No\"}\nassert {[file_name_check \"_f4indsartal132.\"] == \"No\"}\nassert {[file_name_check \".txt\"] == \"No\"}\nassert {[file_name_check \"s.\"] == \"No\"}\n",
        "declaration": "proc file_name_check {file_name} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[file_name_check \"example.txt\"] == \"Yes\"}\nassert {[file_name_check \"1example.dll\"] == \"No\"}\n",
        "prompt_text": "Create a function which takes a string representing a file's name, and returns \"Yes\" if the the file's name is valid, and returns \"No\" otherwise. A file's name is considered to be valid if and only if all the following conditions are met: - There should not be more than three digits ('0'-'9') in the file's name. - The file's name contains exactly one dot \".\" - The substring before the dot should not be empty, and it starts with a letter from the latin alphapet ('a'-'z' and 'A'-'Z'). - The substring after the dot should be one of these: {'txt\", \"exe\", \"dll\"}",
        "prompt_explain": "Create a function which takes a string representing a file's name, and returns\n\"Yes\" if the the file's name is valid, and returns \"No\" otherwise.\nA file's name is considered to be valid if and only if all the following conditions\nare met:\n- There should not be more than three digits ('0'-'9') in the file's name.\n- The file's name contains exactly one dot \".\"\n- The substring before the dot should not be empty, and it starts with a letter from\nthe latin alphapet ('a'-'z' and 'A'-'Z').\n- The substring after the dot should be one of these: {'txt\", \"exe\", \"dll\"}\nExamples:\nfile_name_check(\"example.txt\") => \"Yes\"\nfile_name_check(\"1example.dll\")  => \"No\" // (the name should start with a latin alphapet letter)",
        "func_title": "proc file_name_check {file_name}"
    },
    {
        "prompt": "# This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n# Examples:\n# For lst = {1 2 3} the output should be 6\n# For lst = {}  the output should be 0\n# For lst = {-1 -5 2 -1 -5}  the output should be -126\nproc sum_squares {lst} {\n",
        "canonical_solution": "    set sum 0\n    set length [llength $lst]\n    for {set i 0} {$i < $length} {incr i} {\n        if {$i % 3 == 0} {\n            set sum [expr {$sum + [lindex $lst $i] * [lindex $lst $i]}]\n        } elseif {$i % 4 == 0} {\n            set sum [expr {$sum + [lindex $lst $i] * [lindex $lst $i] * [lindex $lst $i]}]\n        } else {\n            set sum [expr {$sum + [lindex $lst $i]}]\n        }\n    }\n    return $sum\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_squares {1 2 3}] == 6}\nassert {[sum_squares {1 4 9}] == 14}\nassert {[sum_squares {}] == 0}\nassert {[sum_squares {1 1 1 1 1 1 1 1 1}] == 9}\nassert {[sum_squares {-1 -1 -1 -1 -1 -1 -1 -1 -1}] == -3}\nassert {[sum_squares {0}] == 0}\nassert {[sum_squares {-1 -5 2 -1 -5}] == -126}\nassert {[sum_squares {-56 -99 1 0 -2}] == 3030}\nassert {[sum_squares {-1 0 0 0 0 0 0 0 -1}] == 0}\nassert {[sum_squares {-16 -9 -2 36 36 26 -20 25 -40 20 -4 12 -26 35 37}] == -14196}\nassert {[sum_squares {-1 -3 17 -1 -15 13 -1 14 -14 -12 -5 14 -14 6 13 11 16 16 4 10}] == -1448}\n",
        "declaration": "proc sum_squares {lst} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_squares {1 2 3}] == 6}\nassert {[sum_squares {}] == 0}\nassert {[sum_squares {-1 -5 2 -1 -5}] == -126}\n",
        "prompt_text": "This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. Examples: For lst = {1 2 3} the output should be 6 For lst = {}  the output should be 0 For lst = {-1 -5 2 -1 -5}  the output should be -126",
        "prompt_explain": "This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\nExamples:\nFor lst = {1 2 3} the output should be 6\nFor lst = {}  the output should be 0\nFor lst = {-1 -5 2 -1 -5}  the output should be -126",
        "func_title": "proc sum_squares {lst}"
    },
    {
        "prompt": "# Your task is to implement a function that will simplify the expression x * n. The function returns true if x * n evaluates to a whole number and false otherwise. Both x and n, are string representation of a fraction, and have the following format, <numerator>/<denominator> where both numerator and denominator are positive whole numbers.  You can assume that x, and n are valid fractions, and do not have zero as denominator. \n# simplify(\"1/5\", \"5/1\") = true\n# simplify(\"1/6\", \"2/1\") = false\n# simplify(\"7/10\", \"10/2\") = false\nproc simplify {x n} {\n",
        "canonical_solution": "    set x_parts [split $x \"/\"]\n    set n_parts [split $n \"/\"]\n    set a [lindex $x_parts 0]\n    set b [lindex $x_parts 1]\n    set c [lindex $n_parts 0]\n    set d [lindex $n_parts 1]\n    if {[expr {($a * $c) % ($b * $d)}] == 0} {\n        return true\n    } else {\n        return false\n    }\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[simplify \"1/5\" \"5/1\"] == true}\nassert {[simplify \"1/6\" \"2/1\"] == false}\nassert {[simplify \"5/1\" \"3/1\"] == true}\nassert {[simplify \"7/10\" \"10/2\"] == false}\nassert {[simplify \"2/10\" \"50/10\"] == true}\nassert {[simplify \"7/2\" \"4/2\"] == true}\nassert {[simplify \"11/6\" \"6/1\"] == true}\nassert {[simplify \"2/3\" \"5/2\"] == false}\nassert {[simplify \"5/2\" \"3/5\"] == false}\nassert {[simplify \"2/4\" \"8/4\"] == true}\nassert {[simplify \"2/4\" \"4/2\"] == true}\nassert {[simplify \"1/5\" \"5/1\"] == true}\nassert {[simplify \"1/5\" \"1/5\"] == false}\n",
        "declaration": "proc simplify {x n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[simplify \"1/5\" \"5/1\"] == true}\nassert {[simplify \"1/6\" \"2/1\"] == false}\nassert {[simplify \"7/10\" \"10/2\"] == false}\n",
        "prompt_text": "Your task is to implement a function that will simplify the expression x * n. The function returns true if x * n evaluates to a whole number and false otherwise. Both x and n, are string representation of a fraction, and have the following format, <numerator>/<denominator> where both numerator and denominator are positive whole numbers.  You can assume that x, and n are valid fractions, and do not have zero as denominator. ",
        "prompt_explain": "Your task is to implement a function that will simplify the expression\nx * n. The function returns true if x * n evaluates to a whole number and false\notherwise. Both x and n, are string representation of a fraction, and have the following format,\n<numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\nYou can assume that x, and n are valid fractions, and do not have zero as denominator.\n\nsimplify(\"1/5\", \"5/1\") = true\nsimplify(\"1/6\", \"2/1\") = false\nsimplify(\"7/10\", \"10/2\") = false",
        "func_title": "proc simplify {x n}"
    },
    {
        "prompt": "# Write a function that takes a list of numbers as input and returns the number of elements in the list that are greater than 10 and both first and last digits of a number are odd (1, 3, 5, 7, 9).\n# For example:\n# specialFilter {15 -73 14 -15} => 1\n# specialFilter {33 -2 -3 45 21 109} => 2\nproc specialFilter {nums} {\n",
        "canonical_solution": "    set count 0\n    foreach num $nums {\n        if {$num > 10} {\n            set strNum [string trimleft [string trimleft $num \"-\"] \"0\"]\n            set firstDigit [string index $strNum 0]\n            set lastDigit [string index $strNum end]\n            if {$firstDigit % 2 == 1 && $lastDigit % 2 == 1} {\n                incr count\n            }\n        }\n    }\n    return $count\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[specialFilter {5 -2 1 -5}] == 0}\nassert {[specialFilter {15 -73 14 -15}] == 1}\nassert {[specialFilter {33 -2 -3 45 21 109}] == 2}\nassert {[specialFilter {43 -12 93 125 121 109}] == 4}\nassert {[specialFilter {71 -2 -33 75 21 19}] == 3}\nassert {[specialFilter {1}] == 0}\nassert {[specialFilter {}] == 0}\n",
        "declaration": "proc specialFilter {nums} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[specialFilter {15 -73 14 -15}] == 1}\nassert {[specialFilter {33 -2 -3 45 21 109}] == 2}\n",
        "prompt_text": "Write a function that takes a list of numbers as input and returns the number of elements in the list that are greater than 10 and both first and last digits of a number are odd (1, 3, 5, 7, 9). For example: specialFilter {15 -73 14 -15} => 1 specialFilter {33 -2 -3 45 21 109} => 2",
        "prompt_explain": "Write a function that takes a list of numbers as input and returns\nthe number of elements in the list that are greater than 10 and both\nfirst and last digits of a number are odd (1, 3, 5, 7, 9).\nFor example:\nspecialFilter {15 -73 14 -15} => 1\nspecialFilter {33 -2 -3 45 21 109} => 2",
        "func_title": "proc specialFilter {nums}"
    },
    {
        "prompt": "# You are given a positive integer n. You have to create an integer list a of length n.\n# For each i (1  i  n), the value of a{i} = i * i - i + 1.\n# Return the number of triples (a{i}, a{j}, a{k}) of a where i < j < k,\n# and a[i] + a[j] + a[k] is a multiple of 3.\n# Example :\n# Input: n = 5\n# Output: 1\n# Explanation:\n# a = {1, 3, 7, 13, 21}\n# The only valid triple is (1, 7, 13).\nproc get_matrix_triples {n} {\n",
        "canonical_solution": "    set a {}\n    set sum {{0 0 0}}\n    set sum2 {{0 0 0}}\n    for {set i 1} {$i <= $n} {incr i} {\n        lappend a [expr {($i * $i - $i + 1) % 3}]\n        lappend sum [lindex $sum end]\n        lset sum end [expr {[lindex $a end]}] [expr {[lindex $sum end [lindex $a end]] + 1}]\n    }\n    for {set times 1} {$times < 3} {incr times} {\n        for {set i 1} {$i <= $n} {incr i} {\n            lappend sum2 [lindex $sum2 end]\n            if {$i >= 1} {\n                for {set j 0} {$j <= 2} {incr j} {\n                    lset sum2 end [expr {([lindex $a [expr {$i - 1}]] + $j) % 3}] [expr {[lindex $sum2 end [expr {([lindex $a [expr {$i - 1}]] + $j) % 3}]] + [lindex $sum [expr {$i - 1}] $j]}]\n                }\n            }\n        }\n        set sum $sum2\n        set sum2 {{0 0 0}}\n    }\n    return [lindex $sum $n 0]\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_matrix_triples 5] == 1}\nassert {[get_matrix_triples 6] == 4}\nassert {[get_matrix_triples 10] == 36}\nassert {[get_matrix_triples 100] == 53361}\n",
        "declaration": "proc get_matrix_triples {n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_matrix_triples 5] == 1}\n",
        "prompt_text": "You are given a positive integer n. You have to create an integer list a of length n. For each i (1  i  n), the value of a{i} = i * i - i + 1. Return the number of triples (a{i}, a{j}, a{k}) of a where i < j < k, and a[i] + a[j] + a[k] is a multiple of 3. Example : Input: n = 5 Output: 1 Explanation: a = {1, 3, 7, 13, 21} The only valid triple is (1, 7, 13).",
        "prompt_explain": "You are given a positive integer n. You have to create an integer list a of length n.\nFor each i (1  i  n), the value of a{i} = i * i - i + 1.\nReturn the number of triples (a{i}, a{j}, a{k}) of a where i < j < k,\nand a[i] + a[j] + a[k] is a multiple of 3.\n\nExample :\nInput: n = 5\nOutput: 1\nExplanation:\na = {1, 3, 7, 13, 21}\nThe only valid triple is (1, 7, 13).",
        "func_title": "proc get_matrix_triples {n}"
    },
    {
        "prompt": "# A simple program which should return the value of x if n is a prime number and should return the value of y otherwise.\n# Examples:\n# for x_or_y 7 34 12 == 34\n# for x_or_y 15 8 5 == 5\nproc x_or_y {n x y} {\n",
        "canonical_solution": "    set isp true\n    if {$n < 2} {set isp false}\n    for {set i 2} {$i * $i <= $n} {incr i} {\n        if {$n % $i == 0} {set isp false}\n    }\n    if {$isp} {return $x}\n    return $y\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[x_or_y 7 34 12] == 34}\nassert {[x_or_y 15 8 5] == 5}\nassert {[x_or_y 3 33 5212] == 33}\nassert {[x_or_y 1259 3 52] == 3}\nassert {[x_or_y 7919 -1 12] == -1}\nassert {[x_or_y 3609 1245 583] == 583}\nassert {[x_or_y 91 56 129] == 129}\nassert {[x_or_y 6 34 1234] == 1234}\nassert {[x_or_y 1 2 0] == 0}\nassert {[x_or_y 2 2 0] == 2}\n",
        "declaration": "proc x_or_y {n x y} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[x_or_y 7 34 12] == 34}\nassert {[x_or_y 15 8 5] == 5}\n",
        "prompt_text": "A simple program which should return the value of x if n is a prime number and should return the value of y otherwise.",
        "prompt_explain": "A simple program which should return the value of x if n is a prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y 7 34 12 == 34\nfor x_or_y 15 8 5 == 5\n",
        "func_title": "proc x_or_y {n x y}"
    },
    {
        "prompt": "# Given a list of numbers, return the sum of squares of the numbers in the list that are odd. Ignore numbers that are negative or not integers.\n# double_the_difference {1 3 2 0} == 1 + 9 + 0 + 0 = 10\n# double_the_difference {-1 -2 0} == 0\n# double_the_difference {9 -2} == 81\n# double_the_difference {0} == 0\n# If the input list is empty, return 0.\nproc double_the_difference {lst} {\n",
        "canonical_solution": "    set sum 0\n    foreach num $lst {\n        if {$num > 0 && $num == int($num) && int($num) % 2 == 1} {\n            set sum [expr {$sum + $num * $num}]\n        }\n    }\n    return $sum\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[double_the_difference {}] == 0}\nassert {[double_the_difference {5 4}] == 25}\nassert {[double_the_difference {0.1 0.2 0.3}] == 0}\nassert {[double_the_difference {-10 -20 -30}] == 0}\nassert {[double_the_difference {-1 -2 8}] == 0}\nassert {[double_the_difference {0.2 3 5}] == 34}\n\nset odd_sum 0\nset lst {}\nfor {set i -99} {$i < 100} {incr i 2} {\n    lappend lst $i\n    if {$i > 0 && $i % 2 == 1} {\n        set odd_sum [expr {$odd_sum + $i * $i}]\n    }\n}\nassert {[double_the_difference $lst] == $odd_sum}\n",
        "declaration": "proc double_the_difference {lst} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[double_the_difference {1 3 2 0}] == 10}\nassert {[double_the_difference {-1 -2 0}] == 0}\nassert {[double_the_difference {9 -2}] == 81}\nassert {[double_the_difference {0}] == 0}\n",
        "prompt_text": "Given a list of numbers, return the sum of squares of the numbers in the list that are odd. Ignore numbers that are negative or not integers.",
        "prompt_explain": "Given a list of numbers, return the sum of squares of the numbers in the list that are odd. Ignore numbers that are negative or not integers.\n\ndouble_the_difference {1 3 2 0} == 1 + 9 + 0 + 0 = 10\ndouble_the_difference {-1 -2 0} == 0\ndouble_the_difference {9 -2} == 81\ndouble_the_difference {0} == 0\n\nIf the input list is empty, return 0.",
        "func_title": "proc double_the_difference {lst}"
    },
    {
        "prompt": "# You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n# cycpattern_check \"abcd\" \"abd\" => false\n# cycpattern_check \"hello\" \"ell\" => true\n# cycpattern_check \"whassup\" \"psus\" => false\n# cycpattern_check \"abab\" \"baa\" => true\n# cycpattern_check \"efef\" \"eeff\" => false\n# cycpattern_check \"himenss\" \"simen\" => true\nproc cycpattern_check {a b} {\n",
        "canonical_solution": "    set len [string length $b]\n    for {set i 0} {$i < $len} {incr i} {\n        set rotate [string range $b $i end][string range $b 0 [expr {$i - 1}]]\n        if {[string first $rotate $a] != -1} {\n            return true\n        }\n    }\n    return false\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[cycpattern_check \"xyzw\" \"xyw\"] == false}\nassert {[cycpattern_check \"yello\" \"ell\"] == true}\nassert {[cycpattern_check \"whattup\" \"ptut\"] == false}\nassert {[cycpattern_check \"efef\" \"fee\"] == true}\nassert {[cycpattern_check \"abab\" \"aabb\"] == false}\nassert {[cycpattern_check \"winemtt\" \"tinem\"] == true}\n",
        "declaration": "proc cycpattern_check {a b} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[cycpattern_check \"abcd\" \"abd\"] == false}\nassert {[cycpattern_check \"hello\" \"ell\"] == true}\nassert {[cycpattern_check \"whassup\" \"psus\"] == false}\nassert {[cycpattern_check \"abab\" \"baa\"] == true}\nassert {[cycpattern_check \"efef\" \"eeff\"] == false}\nassert {[cycpattern_check \"himenss\" \"simen\"] == true}\n",
        "prompt_text": "You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word",
        "prompt_explain": "You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\ncycpattern_check \"abcd\" \"abd\" => false\ncycpattern_check \"hello\" \"ell\" => true\ncycpattern_check \"whassup\" \"psus\" => false\ncycpattern_check \"abab\" \"baa\" => true\ncycpattern_check \"efef\" \"eeff\" => false\ncycpattern_check \"himenss\" \"simen\" => true\n",
        "func_title": "proc cycpattern_check {a b}"
    },
    {
        "prompt": "# Given an integer. return a list that has the number of even and odd digits respectively.\n# Example:\n# even_odd_count -12 ==> {1 1}\n# even_odd_count 123 ==> {1 2}\nproc even_odd_count {num} {\n",
        "canonical_solution": "    set num [expr {abs($num)}]\n    set num_str [format \"%d\" $num]\n    set even 0\n    set odd 0\n    foreach digit [split $num_str \"\"] {\n        if {$digit % 2 == 0} {\n            incr even\n        } else {\n            incr odd\n        }\n    }\n    return [list $even $odd]\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [even_odd_count 7] {0 1}]}\nassert {[issame [even_odd_count -78] {1 1}]}\nassert {[issame [even_odd_count 3452] {2 2}]}\nassert {[issame [even_odd_count 346211] {3 3}]}\nassert {[issame [even_odd_count -345821] {3 3}]}\nassert {[issame [even_odd_count -2] {1 0}]}\nassert {[issame [even_odd_count -45347] {2 3}]}\nassert {[issame [even_odd_count 0] {1 0}]}\n",
        "declaration": "proc even_odd_count {num} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [even_odd_count -12] {1 1}]}\nassert {[issame [even_odd_count 123] {1 2}]}\n",
        "prompt_text": "Given an integer. return a list that has the number of even and odd digits respectively.",
        "prompt_explain": "Given an integer. return a list that has the number of even and odd digits respectively.\n\nExample:\neven_odd_count -12 ==> {1 1}\neven_odd_count 123 ==> {1 2}",
        "func_title": "proc even_odd_count {num}"
    },
    {
        "prompt": "# Given the lengths of the three sides of a triangle. Return true if the three sides form a right-angled triangle, false otherwise.\n# A right-angled triangle is a triangle in which one angle is right angle or 90 degree.\n# Example:\n# right_angle_triangle 3 4 5 == true\n# right_angle_triangle 1 2 3 == false\nproc right_angle_triangle {a b c} {\n",
        "canonical_solution": "    if {abs($a*$a + $b*$b - $c*$c) < 1e-4 || abs($a*$a + $c*$c - $b*$b) < 1e-4 || abs($b*$b + $c*$c - $a*$a) < 1e-4} {\n        return true\n    }\n    return false\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[right_angle_triangle 3 4 5] == true}\nassert {[right_angle_triangle 1 2 3] == false}\nassert {[right_angle_triangle 10 6 8] == true}\nassert {[right_angle_triangle 2 2 2] == false}\nassert {[right_angle_triangle 7 24 25] == true}\nassert {[right_angle_triangle 10 5 7] == false}\nassert {[right_angle_triangle 5 12 13] == true}\nassert {[right_angle_triangle 15 8 17] == true}\nassert {[right_angle_triangle 48 55 73] == true}\nassert {[right_angle_triangle 1 1 1] == false}\nassert {[right_angle_triangle 2 2 10] == false}\n",
        "declaration": "proc right_angle_triangle {a b c} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[right_angle_triangle 3 4 5] == true}\nassert {[right_angle_triangle 1 2 3] == false}\n",
        "prompt_text": "Given the lengths of the three sides of a triangle. Return true if the three sides form a right-angled triangle, false otherwise. A right-angled triangle is a triangle in which one angle is right angle or 90 degree.",
        "prompt_explain": "Given the lengths of the three sides of a triangle. Return true if the three\nsides form a right-angled triangle, false otherwise.\nA right-angled triangle is a triangle in which one angle is right angle or\n90 degree.\nExample:\nright_angle_triangle 3 4 5 == true\nright_angle_triangle 1 2 3 == false",
        "func_title": "proc right_angle_triangle {a b c}"
    },
    {
        "prompt": "# Given a string, find out how many distinct characters (regardless of case) does it consist of\n# >>> count_distinct_characters \"xyzXYZ\"\n# 3\n# >>> count_distinct_characters \"Jerry\"\n# 4\nproc count_distinct_characters {str} {\n",
        "canonical_solution": "    set distinct [list]\n    set str [string tolower $str]\n    foreach char [split $str \"\"] {\n        if {$char ni $distinct} {\n            lappend distinct $char\n        }\n    }\n    return [llength $distinct]\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_distinct_characters \"\"] == 0}\nassert {[count_distinct_characters \"abcde\"] == 5}\nassert {[count_distinct_characters \"abcdecadeCADE\"] == 5}\nassert {[count_distinct_characters \"aaaaAAAAaaaa\"] == 1}\nassert {[count_distinct_characters \"Jerry jERRY JeRRRY\"] == 5}\n",
        "declaration": "proc count_distinct_characters {str} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_distinct_characters \"xyzXYZ\"] == 3}\nassert {[count_distinct_characters \"Jerry\"] == 4}\n",
        "prompt_text": "Given a string, find out how many distinct characters (regardless of case) does it consist of",
        "prompt_explain": "Given a string, find out how many distinct characters (regardless of case) does it consist of\n>>> count_distinct_characters \"xyzXYZ\"\n3\n>>> count_distinct_characters \"Jerry\"\n4",
        "func_title": "proc count_distinct_characters {str}"
    },
    {
        "prompt": "# Given two lists operator, and operand. The first list has basic algebra operations, and the second list is a list of integers. Use the two given lists to build the algebraic expression and return the evaluation of this expression.\n# The basic algebra operations:\n# Addition ( + )\n# Subtraction ( - )\n# Multiplication ( * )\n# Floor division ( // )\n# Exponentiation ( ** )\n# Example:\n# operator {\"+\", \"*\", \"-\"}\n# list = {2, 3, 4, 5}\n# result = 2 + 3 * 4 - 5\n# => result = 9\n# Note:\n# The length of operator list is equal to the length of operand list minus one.\n# Operand is a list of non-negative integers.\n# Operator list has at least one operator, and operand list has at least two operands.\nproc do_algebra {operato operand} {\n",
        "canonical_solution": "    set result [lindex $operand 0]\n    set i 0\n    foreach op $operato {\n        set next [lindex $operand [expr {$i + 1}]]\n        switch $op {\n            \"+\" { set result [expr {$result + $next}] }\n            \"-\" { set result [expr {$result - $next}] }\n            \"*\" { set result [expr {$result * $next}] }\n            \"//\" { set result [expr {$result / $next}] }\n            \"**\" { set result [expr {$result ** $next}] }\n        }\n        incr i\n    }\n    return $result\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[do_algebra {\"**\" \"*\" \"+\"} {2 3 4 5}] == 37}\nassert {[do_algebra {\"+\" \"*\" \"-\"} {2 3 4 5}] == 9}\nassert {[do_algebra {\"//\" \"*\"} {7 3 4}] == 8}\n",
        "declaration": "proc do_algebra {operato operand} {\n",
        "example_test": "",
        "prompt_text": "Given two lists operator, and operand. The first list has basic algebra operations, and the second list is a list of integers. Use the two given lists to build the algebraic expression and return the evaluation of this expression. The basic algebra operations: Addition ( + ) Subtraction ( - ) Multiplication ( * ) Floor division ( // ) Exponentiation ( ** ) Example: operator {\"+\", \"*\", \"-\"} list = {2, 3, 4, 5} result = 2 + 3 * 4 - 5 => result = 9 Note: The length of operator list is equal to the length of operand list minus one. Operand is a list of non-negative integers. Operator list has at least one operator, and operand list has at least two operands.",
        "prompt_explain": "Given two lists operator, and operand. The first list has basic algebra operations, and the second list is a list of integers. Use the two given lists to build the algebraic expression and return the evaluation of this expression.\n\nThe basic algebra operations:\nAddition ( + )\nSubtraction ( - )\nMultiplication ( * )\nFloor division ( // )\nExponentiation ( ** )\n\nExample:\noperator {\"+\", \"*\", \"-\"}\nlist = {2, 3, 4, 5}\nresult = 2 + 3 * 4 - 5\n=> result = 9\n\nNote:\nThe length of operator list is equal to the length of operand list minus one.\nOperand is a list of non-negative integers.\nOperator list has at least one operator, and operand list has at least two operands.\n",
        "func_title": "proc do_algebra {operato operand}"
    },
    {
        "prompt": "# Input to this function is a string representing musical notes in a special ASCII format.\n# Your task is to parse this string and return list of integers corresponding to how many beats does each\n# not last.\n#\n# Here is a legend:\n# \"o\" - whole note, lasts four beats\n# \"o|\" - half note, lasts two beats\n# \".|\" - quater note, lasts one beat\n#\n# >>> parse_music \"o o| .| o| o| .| .| .| .| o o\"\n# {4 2 1 2 2 1 1 1 1 4 4}\nproc parse_music {music_string} {\n",
        "canonical_solution": "    set out {}\n    set current \"\"\n    if {[string length $music_string] > 0} {\n        append music_string \" \"\n    }\n    for {set i 0} {$i < [string length $music_string]} {incr i} {\n        set char [string index $music_string $i]\n        if {$char eq \" \"} {\n            if {$current eq \"o\"} {\n                lappend out 4\n            } elseif {$current eq \"o|\"} {\n                lappend out 2\n            } elseif {$current eq \".|\"} {\n                lappend out 1\n            }\n            set current \"\"\n        } else {\n            append current $char\n        }\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [parse_music \"\"] {}]}\nassert {[issame [parse_music \"o o o o\"] {4 4 4 4}]}\nassert {[issame [parse_music \".| .| .| .|\"] {1 1 1 1}]}\nassert {[issame [parse_music \"o| o| .| .| o o o o\"] {2 2 1 1 4 4 4 4}]}\nassert {[issame [parse_music \"o| .| o| .| o o| o o|\"] {2 1 2 1 4 2 4 2}]}\n",
        "declaration": "proc parse_music {music_string} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [parse_music \"o o| .| o| o| .| .| .| .| o o\"] {4 2 1 2 2 1 1 1 1 4 4}]}\n",
        "prompt_text": "Input to this function is a string representing musical notes in a special ASCII format. Your task is to parse this string and return list of integers corresponding to how many beats does each not last.  Here is a legend: \"o\" - whole note, lasts four beats \"o|\" - half note, lasts two beats \".|\" - quater note, lasts one beat ",
        "prompt_explain": "Input to this function is a string representing musical notes in a special ASCII format.\nYour task is to parse this string and return list of integers corresponding to how many beats does each\nnot last.\n\nHere is a legend:\n\"o\" - whole note, lasts four beats\n\"o|\" - half note, lasts two beats\n\".|\" - quater note, lasts one beat\n\n>>> parse_music \"o o| .| o| o| .| .| .| .| o o\"\n{4 2 1 2 2 1 1 1 1 4 4}",
        "func_title": "proc parse_music {music_string}"
    },
    {
        "prompt": "# Find how many times a given substring can be found in the original string. Count overlaping cases.\n# >>> how_many_times \"\" \"a\"\n# 0\n# >>> how_many_times \"aaa\" \"a\"\n# 3\n# >>> how_many_times \"aaaa\" \"aa\"\n# 3\nproc how_many_times {str substring} {\n",
        "canonical_solution": "    set out 0\n    set len [string length $str]\n    set sublen [string length $substring]\n    if {$len == 0} {return 0}\n    for {set i 0} {$i <= [expr {$len - $sublen}]} {incr i} {\n        if {[string equal -length $sublen [string range $str $i [expr {$i + $sublen - 1}]] $substring]} {\n            incr out\n        }\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[how_many_times \"\" \"x\"] == 0}\nassert {[how_many_times \"xyxyxyx\" \"x\"] == 4}\nassert {[how_many_times \"cacacacac\" \"cac\"] == 4}\nassert {[how_many_times \"john doe\" \"john\"] == 1}\n",
        "declaration": "proc how_many_times {str substring} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[how_many_times \"\" \"a\"] == 0}\nassert {[how_many_times \"aaa\" \"a\"] == 3}\nassert {[how_many_times \"aaaa\" \"aa\"] == 3}\n",
        "prompt_text": "Find how many times a given substring can be found in the original string. Count overlaping cases.",
        "prompt_explain": "Find how many times a given substring can be found in the original string. Count overlaping cases.\n>>> how_many_times \"\" \"a\"\n0\n>>> how_many_times \"aaa\" \"a\"\n3\n>>> how_many_times \"aaaa\" \"aa\"\n3",
        "func_title": "proc how_many_times {str substring}"
    },
    {
        "prompt": "# Given a positive floating point number, it can be decomposed into and integer part (largest integer smaller than given number) and decimals (leftover part always smaller than 1).  Return the decimal part of the number.\n# >>> truncate_number 3.5\n# 0.5\nproc truncate_number {number} {\n",
        "canonical_solution": "    return [expr {$number - int($number)}]\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[expr {abs([truncate_number 3.5] - 0.5) < 1e-4}]}\nassert {[expr {abs([truncate_number 1.33] - 0.33) < 1e-4}]}\nassert {[expr {abs([truncate_number 123.456] - 0.456) < 1e-4}]}\n",
        "declaration": "proc truncate_number {number} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[expr {abs([truncate_number 3.5] - 0.5) < 1e-4}]}\n",
        "prompt_text": "Given a positive floating point number, it can be decomposed into and integer part (largest integer smaller than given number) and decimals (leftover part always smaller than 1).  Return the decimal part of the number.",
        "prompt_explain": "Given a positive floating point number, it can be decomposed into\nand integer part (largest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the decimal part of the number.\n>>> truncate_number 3.5\n0.5",
        "func_title": "proc truncate_number {number}"
    },
    {
        "prompt": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each other and return them in order (smaller number, larger number).\n# >>> find_closest_elements {1.0 2.0 3.0 4.0 5.0 2.2}\n# 2.0 2.2\n# >>> find_closest_elements {1.0 2.0 3.0 4.0 5.0 2.0}\n# 2.0 2.0\nproc find_closest_elements {numbers} {\n",
        "canonical_solution": "    set out {}\n    set length [llength $numbers]\n    for {set i 0} {$i < $length} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $length} {incr j} {\n            set diff [expr {abs([lindex $numbers $i] - [lindex $numbers $j])}]\n            if {[llength $out] == 0 || $diff < [expr {abs([lindex $out 0] - [lindex $out 1])}]} {\n                set out [list [lindex $numbers $i] [lindex $numbers $j]]\n            }\n        }\n    }\n    if {[lindex $out 0] > [lindex $out 1]} {\n        set out [list [lindex $out 1] [lindex $out 0]]\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {abs([lindex $a $i] - [lindex $b $i]) > 1e-4} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [find_closest_elements {1.0 2.0 3.9 4.0 5.0 2.2}] {3.9 4.0}]}\nassert {[issame [find_closest_elements {1.0 2.0 5.9 4.0 5.0}] {5.0 5.9}]}\nassert {[issame [find_closest_elements {1.0 2.0 3.0 4.0 5.0 2.2}] {2.0 2.2}]}\nassert {[issame [find_closest_elements {1.0 2.0 3.0 4.0 5.0 2.0}] {2.0 2.0}]}\nassert {[issame [find_closest_elements {1.1 2.2 3.1 4.1 5.1}] {2.2 3.1}]}\n",
        "declaration": "proc find_closest_elements {numbers} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {abs([lindex $a $i] - [lindex $b $i]) > 1e-4} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [find_closest_elements {1.0 2.0 3.0 4.0 5.0 2.2}] {2.0 2.2}]}\nassert {[issame [find_closest_elements {1.0 2.0 3.0 4.0 5.0 2.0}] {2.0 2.0}]}\n",
        "prompt_text": "From a supplied list of numbers (of length at least two) select and return two that are the closest to each other and return them in order (smaller number, larger number).",
        "prompt_explain": "From a supplied list of numbers (of length at least two) select and return two that are the closest to each other and return them in order (smaller number, larger number).\n>>> find_closest_elements {1.0 2.0 3.0 4.0 5.0 2.2}\n2.0 2.2\n>>> find_closest_elements {1.0 2.0 3.0 4.0 5.0 2.0}\n2.0 2.0",
        "func_title": "proc find_closest_elements {numbers}"
    },
    {
        "prompt": "# Given list of numbers (of at least two elements), apply a linear transform to that list, such that the smallest number will become 0 and the largest will become 1\n# >>> rescale_to_unit {1.0 2.0 3.0 4.0 5.0}\n# {0.0 0.25 0.5 0.75 1.0}\nproc rescale_to_unit {numbers} {\n",
        "canonical_solution": "    set min [lindex $numbers 0]\n    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {set min $num}\n        if {$num > $max} {set max $num}\n    }\n    set result {}\n    foreach num $numbers {\n        lappend result [expr {($num - $min) / ($max - $min)}]\n    }\n    return $result\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    foreach ai $a bi $b {\n        if {abs($ai - $bi) > 1e-4} {return false}\n    }\n    return true\n}\n\nassert {[issame [rescale_to_unit {2.0 49.9}] {0.0 1.0}]}\nassert {[issame [rescale_to_unit {100.0 49.9}] {1.0 0.0}]}\nassert {[issame [rescale_to_unit {1.0 2.0 3.0 4.0 5.0}] {0.0 0.25 0.5 0.75 1.0}]}\nassert {[issame [rescale_to_unit {2.0 1.0 5.0 3.0 4.0}] {0.25 0.0 1.0 0.5 0.75}]}\nassert {[issame [rescale_to_unit {12.0 11.0 15.0 13.0 14.0}] {0.25 0.0 1.0 0.5 0.75}]}\n",
        "declaration": "proc rescale_to_unit {numbers} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    foreach ai $a bi $b {\n        if {abs($ai - $bi) > 1e-4} {return false}\n    }\n    return true\n}\n\nassert {[issame [rescale_to_unit {1.0 2.0 3.0 4.0 5.0}] {0.0 0.25 0.5 0.75 1.0}]}\n",
        "prompt_text": "Given list of numbers (of at least two elements), apply a linear transform to that list, such that the smallest number will become 0 and the largest will become 1",
        "prompt_explain": "Given list of numbers (of at least two elements), apply a linear transform to that list, such that the smallest number will become 0 and the largest will become 1\n>>> rescale_to_unit {1.0 2.0 3.0 4.0 5.0}\n{0.0 0.25 0.5 0.75 1.0}",
        "func_title": "proc rescale_to_unit {numbers}"
    },
    {
        "prompt": "# Filter given list of any python values only for integers\n# >>> filter_integers {a 3.14 5}\n# {5}\n# >>> filter_integers {1 2 3 abc {} {}}\n# {1 2 3}\nproc filter_integers {values} {\n",
        "canonical_solution": "    set out {}\n    foreach value $values {\n        if {[string is integer -strict $value]} {\n            lappend out $value\n        }\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [filter_integers {}] {}]}\nassert {[issame [filter_integers {4 {} 23.2 9 adasd}] {4 9}]}\nassert {[issame [filter_integers {3 c 3 3 a b}] {3 3 3}]}\n",
        "declaration": "proc filter_integers {values} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [filter_integers {a 3.14 5}] {5}]}\nassert {[issame [filter_integers {1 2 3 abc {} {}}] {1 2 3}]}\n",
        "prompt_text": "Filter given list of any python values only for integers",
        "prompt_explain": "Filter given list of any python values only for integers\n>>> filter_integers {a 3.14 5}\n{5}\n>>> filter_integers {1 2 3 abc {} {}}\n{1 2 3}",
        "func_title": "proc filter_integers {values}"
    },
    {
        "prompt": "# Return length of given string\n# >>> strlen \"\"\n# 0\n# >>> strlen \"abc\"\n# 3\nproc strlen {str} {\n",
        "canonical_solution": "    return [string length $str]\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[strlen \"\"] == 0}\nassert {[strlen \"x\"] == 1}\nassert {[strlen \"asdasnakj\"] == 9}\n",
        "declaration": "proc strlen {str} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[strlen \"\"] == 0}\nassert {[strlen \"abc\"] == 3}\n",
        "prompt_text": "Return length of given string",
        "prompt_explain": "Return length of given string\n>>> strlen \"\"\n0\n>>> strlen \"abc\"\n3",
        "func_title": "proc strlen {str}"
    },
    {
        "prompt": "# For a given number n, find the largest number that divides n evenly, smaller than n\n# >>> largest_divisor 15\n# 5\nproc largest_divisor {n} {\n",
        "canonical_solution": "    for {set i 2} {$i * $i <= $n} {incr i} {\n        if {$n % $i == 0} {\n            return [expr {$n / $i}]\n        }\n    }\n    return 1\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[largest_divisor 3] == 1}\nassert {[largest_divisor 7] == 1}\nassert {[largest_divisor 10] == 5}\nassert {[largest_divisor 100] == 50}\nassert {[largest_divisor 49] == 7}\n",
        "declaration": "proc largest_divisor {n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[largest_divisor 15] == 5}\n",
        "prompt_text": "For a given number n, find the largest number that divides n evenly, smaller than n",
        "prompt_explain": "For a given number n, find the largest number that divides n evenly, smaller than n\n>>> largest_divisor 15\n5",
        "func_title": "proc largest_divisor {n}"
    },
    {
        "prompt": "# Return list of prime factors of given integer in the order from smallest to largest.\n# Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n# Input number should be equal to the product of all factors\n# >>> factorize 8\n# {2 2 2}\n# >>> factorize 25\n# {5 5}\n# >>> factorize 70\n# {2 5 7}\nproc factorize {n} {\n",
        "canonical_solution": "    set out {}\n    for {set i 2} {$i * $i <= $n} {incr i} {\n        while {$n % $i == 0} {\n            set n [expr {$n / $i}]\n            lappend out $i\n        }\n    }\n    if {$n > 1} {\n        lappend out $n\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [factorize 2] {2}]}\nassert {[issame [factorize 4] {2 2}]}\nassert {[issame [factorize 8] {2 2 2}]}\nassert {[issame [factorize [expr {3 * 19}]] {3 19}]}\nassert {[issame [factorize [expr {3 * 19 * 3 * 19}]] {3 3 19 19}]}\nassert {[issame [factorize [expr {3 * 19 * 3 * 19 * 3 * 19}]] {3 3 3 19 19 19}]}\nassert {[issame [factorize [expr {3 * 19 * 19 * 19}]] {3 19 19 19}]}\nassert {[issame [factorize [expr {3 * 2 * 3}]] {2 3 3}]}\n",
        "declaration": "proc factorize {n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [factorize 8] {2 2 2}]}\nassert {[issame [factorize 25] {5 5}]}\nassert {[issame [factorize 70] {2 5 7}]}\n",
        "prompt_text": "Return list of prime factors of given integer in the order from smallest to largest. Each of the factors should be listed number of times corresponding to how many times it appears in factorization. Input number should be equal to the product of all factors",
        "prompt_explain": "Return list of prime factors of given integer in the order from smallest to largest.\nEach of the factors should be listed number of times corresponding to how many times it appears in factorization.\nInput number should be equal to the product of all factors\n>>> factorize 8\n{2 2 2}\n>>> factorize 25\n{5 5}\n>>> factorize 70\n{2 5 7}",
        "func_title": "proc factorize {n}"
    },
    {
        "prompt": "# From a list of integers, remove all elements that occur more than once. Keep order of elements left the same as in the input.\n# >>> remove_duplicates {1 2 3 2 4}\n# {1 3 4}\nproc remove_duplicates {numbers} {\n",
        "canonical_solution": "    set out {}\n    set has1 {}\n    set has2 {}\n    foreach num $numbers {\n        if {[lsearch -exact $has2 $num] != -1} continue\n        if {[lsearch -exact $has1 $num] != -1} {\n            lappend has2 $num\n        } else {\n            lappend has1 $num\n        }\n    }\n    foreach num $numbers {\n        if {[lsearch -exact $has2 $num] == -1} {\n            lappend out $num\n        }\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [remove_duplicates {}] {}]}\nassert {[issame [remove_duplicates {1 2 3 4}] {1 2 3 4}]}\nassert {[issame [remove_duplicates {1 2 3 2 4 3 5}] {1 4 5}]}\n",
        "declaration": "proc remove_duplicates {numbers} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [remove_duplicates {1 2 3 2 4}] {1 3 4}]}\n",
        "prompt_text": "From a list of integers, remove all elements that occur more than once. Keep order of elements left the same as in the input.",
        "prompt_explain": "From a list of integers, remove all elements that occur more than once.\nKeep order of elements left the same as in the input.\n>>> remove_duplicates {1 2 3 2 4}\n{1 3 4}",
        "func_title": "proc remove_duplicates {numbers}"
    },
    {
        "prompt": "# Filter an input list of strings only for ones that start with a given prefix.\n# >>> filter_by_prefix {} \"a\"\n# {}\n# >>> filter_by_prefix {\"abc\" \"bcd\" \"cde\" \"vector\"} \"a\"\n# {\"abc\" \"vector\"}\nproc filter_by_prefix {strings prefix} {\n",
        "canonical_solution": "    set out {}\n    foreach str $strings {\n        if {[string equal -length [string length $prefix] $str $prefix]} {\n            lappend out $str\n        }\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] ne [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [filter_by_prefix {} \"john\"] {}]}\nassert {[issame [filter_by_prefix {\"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\"} \"xxx\"] {\"xxx\" \"xxxAAA\" \"xxx\"}]}\n",
        "declaration": "proc filter_by_prefix {strings prefix} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] ne [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [filter_by_prefix {} \"a\"] {}]}\nassert {[issame [filter_by_prefix {\"abc\" \"bcd\" \"cde\" \"array\"} \"a\"] {\"abc\" \"array\"}]}\n",
        "prompt_text": "Filter an input list of strings only for ones that start with a given prefix.",
        "prompt_explain": "Filter an input list of strings only for ones that start with a given prefix.\n>>> filter_by_prefix {} \"a\"\n{}\n>>> filter_by_prefix {\"abc\" \"bcd\" \"cde\" \"vector\"} \"a\"\n{\"abc\" \"vector\"}",
        "func_title": "proc filter_by_prefix {strings prefix}"
    },
    {
        "prompt": "# You're given a list of deposit and withdrawal operations on a bank account that starts with zero balance. Your task is to detect if at any point the balance of account falls below zero, and at that point function should return true. Otherwise it should return false.\n# >>> below_zero {1 2 3}\n# false\n# >>> below_zero {1 2 -4 5}\n# true\nproc below_zero {operations} {\n",
        "canonical_solution": "    set balance 0\n    foreach op $operations {\n        incr balance $op\n        if {$balance < 0} {\n            return true\n        }\n    }\n    return false\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[below_zero {}] == false}\nassert {[below_zero {1 2 -3 1 2 -3}] == false}\nassert {[below_zero {1 2 -4 5 6}] == true}\nassert {[below_zero {1 -1 2 -2 5 -5 4 -4}] == false}\nassert {[below_zero {1 -1 2 -2 5 -5 4 -5}] == true}\nassert {[below_zero {1 -2 2 -2 5 -5 4 -4}] == true}\n",
        "declaration": "proc below_zero {operations} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[below_zero {1 2 3}] == false}\nassert {[below_zero {1 2 -4 5}] == true}\n",
        "prompt_text": "You're given a list of deposit and withdrawal operations on a bank account that starts with zero balance. Your task is to detect if at any point the balance of account falls below zero, and at that point function should return true. Otherwise it should return false.",
        "prompt_explain": "You're given a list of deposit and withdrawal operations on a bank account that starts with zero balance. Your task is to detect if at any point the balance of account falls below zero, and at that point function should return true. Otherwise it should return false.\n>>> below_zero {1 2 3}\nfalse\n>>> below_zero {1 2 -4 5}\ntrue",
        "func_title": "proc below_zero {operations}"
    },
    {
        "prompt": "# Return only positive numbers in the list.\n# >>> get_positive {-1 2 -4 5 6}\n# {2 5 6}\n# >>> get_positive {5 3 -5 2 -3 3 9 0 123 1 -10}\n# {5 3 2 3 9 123 1}\nproc get_positive {l} {\n",
        "canonical_solution": "    set out {}\n    foreach num $l {\n        if {$num > 0} {\n            lappend out $num\n        }\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {abs([lindex $a $i] - [lindex $b $i]) > 1e-4} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [get_positive {-1 -2 4 5 6}] {4 5 6}]}\nassert {[issame [get_positive {5 3 -5 2 3 3 9 0 123 1 -10}] {5 3 2 3 3 9 123 1}]}\nassert {[issame [get_positive {-1 -2}] {}]}\nassert {[issame [get_positive {}] {}]}\n",
        "declaration": "proc get_positive {l} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {abs([lindex $a $i] - [lindex $b $i]) > 1e-4} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [get_positive {-1 2 -4 5 6}] {2 5 6}]}\nassert {[issame [get_positive {5 3 -5 2 -3 3 9 0 123 1 -10}] {5 3 2 3 9 123 1}]}\n",
        "prompt_text": "Return only positive numbers in the list.",
        "prompt_explain": "Return only positive numbers in the list.\n>>> get_positive {-1 2 -4 5 6}\n{2 5 6}\n>>> get_positive {5 3 -5 2 -3 3 9 0 123 1 -10}\n{5 3 2 3 9 123 1}",
        "func_title": "proc get_positive {l}"
    },
    {
        "prompt": "# Return true if a given number is prime, and false otherwise.\n# >>> is_prime 6\n# false\n# >>> is_prime 101\n# true\n# >>> is_prime 11\n# true\n# >>> is_prime 13441\n# true\n# >>> is_prime 61\n# true\n# >>> is_prime 4\n# false\n# >>> is_prime 1\n# false\nproc is_prime {n} {\n",
        "canonical_solution": "    if {$n < 2} {return false}\n    for {set i 2} {$i * $i <= $n} {incr i} {\n        if {$n % $i == 0} {return false}\n    }\n    return true\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_prime 6] == false}\nassert {[is_prime 101] == true}\nassert {[is_prime 11] == true}\nassert {[is_prime 13441] == true}\nassert {[is_prime 61] == true}\nassert {[is_prime 4] == false}\nassert {[is_prime 1] == false}\nassert {[is_prime 5] == true}\nassert {[is_prime 11] == true}\nassert {[is_prime 17] == true}\nassert {[is_prime [expr {5 * 17}]] == false}\nassert {[is_prime [expr {11 * 7}]] == false}\nassert {[is_prime [expr {13441 * 19}]] == false}\n",
        "declaration": "proc is_prime {n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_prime 6] == false}\nassert {[is_prime 101] == true}\nassert {[is_prime 11] == true}\nassert {[is_prime 13441] == true}\nassert {[is_prime 61] == true}\nassert {[is_prime 4] == false}\nassert {[is_prime 1] == false}\n",
        "prompt_text": "Return true if a given number is prime, and false otherwise.",
        "prompt_explain": "Return true if a given number is prime, and false otherwise.\n>>> is_prime 6\nfalse\n>>> is_prime 101\ntrue\n>>> is_prime 11\ntrue\n>>> is_prime 13441\ntrue\n>>> is_prime 61\ntrue\n>>> is_prime 4\nfalse\n>>> is_prime 1\nfalse",
        "func_title": "proc is_prime {n}"
    },
    {
        "prompt": "# This function takes a list l and returns a list l' such that l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal to the values of the corresponding indices of l, but sorted.\n# >>> sort_third {1 2 3}\n# {1 2 3}\n# >>> sort_third {5 6 3 4 8 9 2}\n# {2 6 3 4 8 9 5}\nproc sort_third {l} {\n",
        "canonical_solution": "    set third {}\n    set length [llength $l]\n    for {set i 0} {$i < $length} {incr i 3} {\n        lappend third [lindex $l $i]\n    }\n    set third [lsort -integer $third]\n    set out {}\n    set thirdIndex 0\n    for {set i 0} {$i < $length} {incr i} {\n        if {$i % 3 == 0} {\n            lappend out [lindex $third $thirdIndex]\n            incr thirdIndex\n        } else {\n            lappend out [lindex $l $i]\n        }\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [sort_third {1 2 3}] {1 2 3}]}\nassert {[issame [sort_third {5 3 -5 2 -3 3 9 0 123 1 -10}] {5 3 -5 2 -3 3 9 0 123 1 -10}]}\nassert {[issame [sort_third {5 8 -12 4 23 2 3 11 12 -10}] {5 8 -12 4 23 2 3 11 12 -10}]}\nassert {[issame [sort_third {5 6 3 4 8 9 2}] {2 6 3 4 8 9 5}]}\nassert {[issame [sort_third {5 8 3 4 6 9 2}] {2 8 3 4 6 9 5}]}\nassert {[issame [sort_third {5 6 9 4 8 3 2}] {2 6 9 4 8 3 5}]}\nassert {[issame [sort_third {5 6 3 4 8 9 2 1}] {2 6 3 4 8 9 5 1}]}\n",
        "declaration": "proc sort_third {l} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [sort_third {1 2 3}] {1 2 3}]}\nassert {[issame [sort_third {5 6 3 4 8 9 2}] {2 6 3 4 8 9 5}]}\n",
        "prompt_text": "This function takes a list l and returns a list l' such that l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal to the values of the corresponding indices of l, but sorted.",
        "prompt_explain": "This function takes a list l and returns a list l' such that\nl' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\nto the values of the corresponding indices of l, but sorted.\n>>> sort_third {1 2 3}\n{1 2 3}\n>>> sort_third {5 6 3 4 8 9 2}\n{2 6 3 4 8 9 5}",
        "func_title": "proc sort_third {l}"
    },
    {
        "prompt": "# Return sorted unique elements in a list\n# >>> unique {5 3 5 2 3 3 9 0 123}\n# {0 2 3 5 9 123}\nproc unique {l} {\n",
        "canonical_solution": "    set out {}\n    foreach element $l {\n        if {[lsearch -exact $out $element] == -1} {\n            lappend out $element\n        }\n    }\n    set out [lsort -integer $out]\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [unique {5 3 5 2 3 3 9 0 123}] {0 2 3 5 9 123}]}\n",
        "declaration": "proc unique {l} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [unique {5 3 5 2 3 3 9 0 123}] {0 2 3 5 9 123}]}\n",
        "prompt_text": "Return sorted unique elements in a list",
        "prompt_explain": "Return sorted unique elements in a list\n>>> unique {5 3 5 2 3 3 9 0 123}\n{0 2 3 5 9 123}",
        "func_title": "proc unique {l}"
    },
    {
        "prompt": "# Return maximum element in the list.\n# >>> max_element {1 2 3}\n# 3\n# >>> max_element {5 3 -5 2 -3 3 9 0 123 1 -10}\n# 123\nproc max_element {l} {\n",
        "canonical_solution": "    set max -10000\n    foreach num $l {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {abs([max_element {1 2 3}] - 3) < 1e-4}\nassert {abs([max_element {5 3 -5 2 -3 3 9 0 124 1 -10}] - 124) < 1e-4}\n",
        "declaration": "proc max_element {l} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {abs([max_element {1 2 3}] - 3) < 1e-4}\nassert {abs([max_element {5 3 -5 2 -3 3 9 0 123 1 -10}] - 123) < 1e-4}\n",
        "prompt_text": "Return maximum element in the list.",
        "prompt_explain": "Return maximum element in the list.\n>>> max_element {1 2 3}\n3\n>>> max_element {5 3 -5 2 -3 3 9 0 123 1 -10}\n123",
        "func_title": "proc max_element {l}"
    },
    {
        "prompt": "# Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n# >>> fizz_buzz 50\n# 0\n# >>> fizz_buzz 78\n# 2\n# >>> fizz_buzz 79\n# 3\nproc fizz_buzz {n} {\n",
        "canonical_solution": "    set count 0\n    for {set i 0} {$i < $n} {incr i} {\n        if {$i % 11 == 0 || $i % 13 == 0} {\n            set q $i\n            while {$q > 0} {\n                if {$q % 10 == 7} {\n                    incr count\n                }\n                set q [expr {$q / 10}]\n            }\n        }\n    }\n    return $count\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[fizz_buzz 50] == 0}\nassert {[fizz_buzz 78] == 2}\nassert {[fizz_buzz 79] == 3}\nassert {[fizz_buzz 100] == 3}\nassert {[fizz_buzz 200] == 6}\nassert {[fizz_buzz 4000] == 192}\nassert {[fizz_buzz 10000] == 639}\nassert {[fizz_buzz 100000] == 8026}\n",
        "declaration": "proc fizz_buzz {n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[fizz_buzz 50] == 0}\nassert {[fizz_buzz 78] == 2}\nassert {[fizz_buzz 79] == 3}\n",
        "prompt_text": "Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.",
        "prompt_explain": "Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n>>> fizz_buzz 50\n0\n>>> fizz_buzz 78\n2\n>>> fizz_buzz 79\n3",
        "func_title": "proc fizz_buzz {n}"
    },
    {
        "prompt": "# This function takes a list l and returns a list l' such that l' is identical to l in the odd indices, while its values at the even indices are equal to the values of the even indices of l, but sorted.\n# >>> sort_even {1 2 3}\n# {1 2 3}\n# >>> sort_even {5 6 3 4}\n# {3 6 5 4}\nproc sort_even {l} {\n",
        "canonical_solution": "    set out {}\n    set even {}\n    for {set i 0} {[expr {$i * 2}] < [llength $l]} {incr i} {\n        lappend even [lindex $l [expr {$i * 2}]]\n    }\n    set even [lsort -real $even]\n    for {set i 0} {$i < [llength $l]} {incr i} {\n        if {$i % 2 == 0} {\n            lappend out [lindex $even [expr {$i / 2}]]\n        } else {\n            lappend out [lindex $l $i]\n        }\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {abs([lindex $a $i] - [lindex $b $i]) > 1e-4} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [sort_even {1 2 3}] {1 2 3}]}\nassert {[issame [sort_even {5 3 -5 2 -3 3 9 0 123 1 -10}] {-10 3 -5 2 -3 3 5 0 9 1 123}]}\nassert {[issame [sort_even {5 8 -12 4 23 2 3 11 12 -10}] {-12 8 3 4 5 2 12 11 23 -10}]}\n",
        "declaration": "proc sort_even {l} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {abs([lindex $a $i] - [lindex $b $i]) > 1e-4} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [sort_even {1 2 3}] {1 2 3}]}\nassert {[issame [sort_even {5 6 3 4}] {3 6 5 4}]}\n",
        "prompt_text": "This function takes a list l and returns a list l' such that l' is identical to l in the odd indices, while its values at the even indices are equal to the values of the even indices of l, but sorted.",
        "prompt_explain": "This function takes a list l and returns a list l' such that\nl' is identical to l in the odd indices, while its values at the even indices are equal\nto the values of the even indices of l, but sorted.\n>>> sort_even {1 2 3}\n{1 2 3}\n>>> sort_even {5 6 3 4}\n{3 6 5 4}",
        "func_title": "proc sort_even {l}"
    },
    {
        "prompt": "# takes as input string encoded with encode_cyclic function. Returns decoded string.\nproc decode_cyclic {s} {\n",
        "canonical_solution": "    set l [string length $s]\n    set num [expr {($l + 2) / 3}]\n    set output \"\"\n    for {set i 0} {$i * 3 < $l} {incr i} {\n        set x [string range $s [expr {$i * 3}] [expr {$i * 3 + 2}]]\n        if {[string length $x] == 3} {\n            set x [string index $x 2][string range $x 0 1]\n        }\n        append output $x\n    }\n    return $output\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nfor {set i 0} {$i < 100} {incr i} {\n    set l [expr {10 + int(rand() * 11)}]\n    set str \"\"\n    for {set j 0} {$j < $l} {incr j} {\n        set chr [expr {97 + int(rand() * 26)}]\n        append str [format %c $chr]\n    }\n\n    set encoded_str [encode_cyclic $str]\n    assert {[decode_cyclic $encoded_str] == $str}\n}\n",
        "declaration": "proc decode_cyclic {s} {\n",
        "example_test": "",
        "prompt_text": "takes as input string encoded with encode_cyclic function. Returns decoded string.",
        "prompt_explain": "takes as input string encoded with encode_cyclic function. Returns decoded string.",
        "func_title": "proc decode_cyclic {s}"
    },
    {
        "prompt": "# prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n# >>> prime_fib 1\n# 2\n# >>> prime_fib 2\n# 3\n# >>> prime_fib 3\n# 5\n# >>> prime_fib 4\n# 13\n# >>> prime_fib 5\n# 89\nproc prime_fib {n} {\n",
        "canonical_solution": "    set f1 1\n    set f2 2\n    set count 0\n    while {$count < $n} {\n        set temp $f1\n        set f1 $f2\n        set f2 [expr {$temp + $f2}]\n        set isprime 1\n        for {set w 2} {$w * $w <= $f1} {incr w} {\n            if {$f1 % $w == 0} {\n                set isprime 0\n                break\n            }\n        }\n        if {$isprime} {\n            incr count\n        }\n        if {$count == $n} {\n            return $f1\n        }\n    }\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[prime_fib 1] == 2}\nassert {[prime_fib 2] == 3}\nassert {[prime_fib 3] == 5}\nassert {[prime_fib 4] == 13}\nassert {[prime_fib 5] == 89}\nassert {[prime_fib 6] == 233}\nassert {[prime_fib 7] == 1597}\nassert {[prime_fib 8] == 28657}\nassert {[prime_fib 9] == 514229}\nassert {[prime_fib 10] == 433494437}\n",
        "declaration": "proc prime_fib {n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[prime_fib 1] == 2}\nassert {[prime_fib 2] == 3}\nassert {[prime_fib 3] == 5}\nassert {[prime_fib 4] == 13}\nassert {[prime_fib 5] == 89}\n",
        "prompt_text": "prime_fib returns n-th number that is a Fibonacci number and it's also prime.",
        "prompt_explain": "prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n>>> prime_fib 1\n2\n>>> prime_fib 2\n3\n>>> prime_fib 3\n5\n>>> prime_fib 4\n13\n>>> prime_fib 5\n89",
        "func_title": "proc prime_fib {n}"
    },
    {
        "prompt": "# For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n# Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n# MAD = average | x - x_mean |\n# >>> mean_absolute_deviation {1.0 2.0 3.0 4.0}\n# 1.0\nproc mean_absolute_deviation {numbers} {\n",
        "canonical_solution": "    set sum 0\n    set length [llength $numbers]\n    foreach num $numbers {\n        set sum [expr {$sum + $num}]\n    }\n    set avg [expr {$sum / $length}]\n    set msum 0\n    foreach num $numbers {\n        set msum [expr {$msum + abs($num - $avg)}]\n    }\n    return [expr {$msum / $length}]\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {abs([mean_absolute_deviation {1.0 2.0 3.0}] - [expr {2.0 / 3.0}]) < 1e-4}\nassert {abs([mean_absolute_deviation {1.0 2.0 3.0 4.0}] - 1.0) < 1e-4}\nassert {abs([mean_absolute_deviation {1.0 2.0 3.0 4.0 5.0}] - [expr {6.0 / 5.0}]) < 1e-4}\n",
        "declaration": "proc mean_absolute_deviation {numbers} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {abs([mean_absolute_deviation {1.0 2.0 3.0 4.0}] - 1.0) < 1e-4}\n",
        "prompt_text": "For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset. Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case): MAD = average | x - x_mean |",
        "prompt_explain": "For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\nMAD = average | x - x_mean |\n>>> mean_absolute_deviation {1.0 2.0 3.0 4.0}\n1.0",
        "func_title": "proc mean_absolute_deviation {numbers}"
    },
    {
        "prompt": "# triples_sum_to_zero takes a list of integers as an input.\n# it returns true if there are three distinct elements in the list that sum to zero, and false otherwise.\n# >>> triples_sum_to_zero {1 3 5 0}\n# false\n# >>> triples_sum_to_zero {1 3 -2 1}\n# true\n# >>> triples_sum_to_zero {1 2 3 7}\n# false\n# >>> triples_sum_to_zero {2 4 -5 3 9 7}\n# true\n# >>> triples_sum_to_zero {1}\n# false\nproc triples_sum_to_zero {l} {\n",
        "canonical_solution": "    set length [llength $l]\n    for {set i 0} {$i < $length} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $length} {incr j} {\n            for {set k [expr {$j + 1}]} {$k < $length} {incr k} {\n                if {[expr {[lindex $l $i] + [lindex $l $j] + [lindex $l $k]}] == 0} {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[triples_sum_to_zero {1 3 5 0}] == false}\nassert {[triples_sum_to_zero {1 3 5 -1}] == false}\nassert {[triples_sum_to_zero {1 3 -2 1}] == true}\nassert {[triples_sum_to_zero {1 2 3 7}] == false}\nassert {[triples_sum_to_zero {1 2 5 7}] == false}\nassert {[triples_sum_to_zero {2 4 -5 3 9 7}] == true}\nassert {[triples_sum_to_zero {1}] == false}\nassert {[triples_sum_to_zero {1 3 5 -100}] == false}\nassert {[triples_sum_to_zero {100 3 5 -100}] == false}\n",
        "declaration": "proc triples_sum_to_zero {l} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[triples_sum_to_zero {1 3 5 0}] == false}\nassert {[triples_sum_to_zero {1 3 -2 1}] == true}\nassert {[triples_sum_to_zero {1 2 3 7}] == false}\nassert {[triples_sum_to_zero {2 4 -5 3 9 7}] == true}\n",
        "prompt_text": "triples_sum_to_zero takes a list of integers as an input. it returns true if there are three distinct elements in the list that sum to zero, and false otherwise.",
        "prompt_explain": "triples_sum_to_zero takes a list of integers as an input.\nit returns true if there are three distinct elements in the list that\nsum to zero, and false otherwise.\n\n>>> triples_sum_to_zero {1 3 5 0}\nfalse\n>>> triples_sum_to_zero {1 3 -2 1}\ntrue\n>>> triples_sum_to_zero {1 2 3 7}\nfalse\n>>> triples_sum_to_zero {2 4 -5 3 9 7}\ntrue\n>>> triples_sum_to_zero {1}\nfalse",
        "func_title": "proc triples_sum_to_zero {l}"
    },
    {
        "prompt": "# Imagine a road that's a perfectly straight infinitely long line. n cars are driving left to right;  simultaneously, a different set of n cars are driving right to left.   The two sets of cars start out being very far from each other.  All cars move in the same speed.  Two cars are said to collide when a car that's moving left to right hits a car that's moving right to left. However, the cars are infinitely sturdy and strong; as a result, they continue moving in their trajectory as if they did not collide.  This function outputs the number of such collisions.\nproc car_race_collision {n} {\n",
        "canonical_solution": "    return [expr {$n * $n}]\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[car_race_collision 2] == 4}\nassert {[car_race_collision 3] == 9}\nassert {[car_race_collision 4] == 16}\nassert {[car_race_collision 8] == 64}\nassert {[car_race_collision 10] == 100}\n",
        "declaration": "proc car_race_collision {n} {\n",
        "example_test": "",
        "prompt_text": "Imagine a road that's a perfectly straight infinitely long line. n cars are driving left to right;  simultaneously, a different set of n cars are driving right to left.   The two sets of cars start out being very far from each other.  All cars move in the same speed.  Two cars are said to collide when a car that's moving left to right hits a car that's moving right to left. However, the cars are infinitely sturdy and strong; as a result, they continue moving in their trajectory as if they did not collide.  This function outputs the number of such collisions.",
        "prompt_explain": "Imagine a road that's a perfectly straight infinitely long line.\nn cars are driving left to right;  simultaneously, a different set of n cars\nare driving right to left.   The two sets of cars start out being very far from\neach other.  All cars move in the same speed.  Two cars are said to collide\nwhen a car that's moving left to right hits a car that's moving right to left.\nHowever, the cars are infinitely sturdy and strong; as a result, they continue moving\nin their trajectory as if they did not collide.\n\nThis function outputs the number of such collisions.",
        "func_title": "proc car_race_collision {n}"
    },
    {
        "prompt": "# Return list with elements incremented by 1.\n# >>> incr_list {1 2 3}\n# {2 3 4}\n# >>> incr_list {5 3 5 2 3 3 9 0 123}\n# {6 4 6 3 4 4 10 1 124}\nproc incr_list {l} {\n",
        "canonical_solution": "    set result {}\n    foreach num $l {\n        lappend result [expr {$num + 1}]\n    }\n    return $result\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    foreach num1 $a num2 $b {\n        if {$num1 != $num2} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [incr_list {}] {}]}\nassert {[issame [incr_list {3 2 1}] {4 3 2}]}\nassert {[issame [incr_list {5 2 5 2 3 3 9 0 123}] {6 3 6 3 4 4 10 1 124}]}\n",
        "declaration": "proc incr_list {l} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    foreach num1 $a num2 $b {\n        if {$num1 != $num2} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [incr_list {1 2 3}] {2 3 4}]}\nassert {[issame [incr_list {5 2 5 2 3 3 9 0 123}] {6 3 6 3 4 4 10 1 124}]}\n",
        "prompt_text": "Return list with elements incremented by 1.",
        "prompt_explain": "Return list with elements incremented by 1.\n>>> incr_list {1 2 3}\n{2 3 4}\n>>> incr_list {5 3 5 2 3 3 9 0 123}\n{6 4 6 3 4 4 10 1 124}",
        "func_title": "proc incr_list {l}"
    },
    {
        "prompt": "# pairs_sum_to_zero takes a list of integers as an input. it returns true if there are two distinct elements in the list that sum to zero, and false otherwise.\n# >>> pairs_sum_to_zero {1 3 5 0}\n# false\n# >>> pairs_sum_to_zero {1 3 -2 1}\n# false\n# >>> pairs_sum_to_zero {1 2 3 7}\n# false\n# >>> pairs_sum_to_zero {2 4 -5 3 5 7}\n# true\n# >>> pairs_sum_to_zero {1}\n# false\nproc pairs_sum_to_zero {l} {\n",
        "canonical_solution": "    set length [llength $l]\n    for {set i 0} {$i < $length} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $length} {incr j} {\n            if {[expr {[lindex $l $i] + [lindex $l $j]}] == 0} {\n                return true\n            }\n        }\n    }\n    return false\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[pairs_sum_to_zero {1 3 5 0}] == false}\nassert {[pairs_sum_to_zero {1 3 -2 1}] == false}\nassert {[pairs_sum_to_zero {1 2 3 7}] == false}\nassert {[pairs_sum_to_zero {2 4 -5 3 5 7}] == true}\nassert {[pairs_sum_to_zero {1}] == false}\nassert {[pairs_sum_to_zero {-3 9 -1 3 2 30}] == true}\nassert {[pairs_sum_to_zero {-3 9 -1 3 2 31}] == true}\nassert {[pairs_sum_to_zero {-3 9 -1 4 2 30}] == false}\nassert {[pairs_sum_to_zero {-3 9 -1 4 2 31}] == false}\n",
        "declaration": "proc pairs_sum_to_zero {l} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[pairs_sum_to_zero {1 3 5 0}] == false}\nassert {[pairs_sum_to_zero {1 3 -2 1}] == false}\nassert {[pairs_sum_to_zero {1 2 3 7}] == false}\nassert {[pairs_sum_to_zero {2 4 -5 3 5 7}] == true}\n",
        "prompt_text": "pairs_sum_to_zero takes a list of integers as an input. it returns true if there are two distinct elements in the list that sum to zero, and false otherwise.",
        "prompt_explain": "pairs_sum_to_zero takes a list of integers as an input.\nit returns true if there are two distinct elements in the list that\nsum to zero, and false otherwise.\n>>> pairs_sum_to_zero {1 3 5 0}\nfalse\n>>> pairs_sum_to_zero {1 3 -2 1}\nfalse\n>>> pairs_sum_to_zero {1 2 3 7}\nfalse\n>>> pairs_sum_to_zero {2 4 -5 3 5 7}\ntrue\n>>> pairs_sum_to_zero {1}\nfalse",
        "func_title": "proc pairs_sum_to_zero {l}"
    },
    {
        "prompt": "# Change numerical base of input number x to base. return string representation after the conversion. base numbers are less than 10.\n# >>> change_base 8 3\n# \"22\"\n# >>> change_base 8 2\n# \"1000\"\n# >>> change_base 7 2\n# \"111\"\nproc change_base {x base} {\n",
        "canonical_solution": "    set out \"\"\n    while {$x > 0} {\n        set out [expr {$x % $base}]$out\n        set x [expr {$x / $base}]\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[change_base 8 3] == \"22\"}\nassert {[change_base 9 3] == \"100\"}\nassert {[change_base 234 2] == \"11101010\"}\nassert {[change_base 16 2] == \"10000\"}\nassert {[change_base 8 2] == \"1000\"}\nassert {[change_base 7 2] == \"111\"}\nfor {set x 2} {$x < 8} {incr x} {\n    assert {[change_base $x [expr {$x + 1}]] == $x}\n}\n",
        "declaration": "proc change_base {x base} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[change_base 8 3] == \"22\"}\nassert {[change_base 8 2] == \"1000\"}\nassert {[change_base 7 2] == \"111\"}\n",
        "prompt_text": "Change numerical base of input number x to base. return string representation after the conversion. base numbers are less than 10.",
        "prompt_explain": "Change numerical base of input number x to base.\nreturn string representation after the conversion.\nbase numbers are less than 10.\n>>> change_base 8 3\n\"22\"\n>>> change_base 8 2\n\"1000\"\n>>> change_base 7 2\n\"111\"",
        "func_title": "proc change_base {x base}"
    },
    {
        "prompt": "# Given length of a side and high return area for a triangle.\n# >>> triangle_area 5 3\n# 7.5\nproc triangle_area {a h} {\n",
        "canonical_solution": "    return [expr {$a * $h * 0.5}]\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {abs([triangle_area 5 3] - 7.5) < 1e-4}\nassert {abs([triangle_area 2 2] - 2.0) < 1e-4}\nassert {abs([triangle_area 10 8] - 40.0) < 1e-4}\n",
        "declaration": "proc triangle_area {a h} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {abs([triangle_area 5 3] - 7.5) < 1e-4}\n",
        "prompt_text": "Given length of a side and high return area for a triangle.",
        "prompt_explain": "Given length of a side and high return area for a triangle.\n>>> triangle_area 5 3\n7.5",
        "func_title": "proc triangle_area {a h}"
    },
    {
        "prompt": "# The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n# fib4(0) -> 0\n# fib4(1) -> 0\n# fib4(2) -> 2\n# fib4(3) -> 0\n# fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n# Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n# >>> fib4 5\n# 4\n# >>> fib4 6\n# 8\n# >>> fib4 7\n# 14\nproc fib4 {n} {\n",
        "canonical_solution": "    set f [list 0 0 2 0]\n    for {set i 4} {$i <= $n} {incr i} {\n        lappend f [expr {[lindex $f [expr {$i - 1}]] + [lindex $f [expr {$i - 2}]] + [lindex $f [expr {$i - 3}]] + [lindex $f [expr {$i - 4}]]}]\n    }\n    return [lindex $f $n]\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[fib4 5] == 4}\nassert {[fib4 8] == 28}\nassert {[fib4 10] == 104}\nassert {[fib4 12] == 386}\n",
        "declaration": "proc fib4 {n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[fib4 5] == 4}\nassert {[fib4 6] == 8}\nassert {[fib4 7] == 14}\n",
        "prompt_text": "The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:",
        "prompt_explain": "The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\nfib4(0) -> 0\nfib4(1) -> 0\nfib4(2) -> 2\nfib4(3) -> 0\nfib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\nPlease write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n>>> fib4 5\n4\n>>> fib4 6\n8\n>>> fib4 7\n14",
        "func_title": "proc fib4 {n}"
    },
    {
        "prompt": "# Return median of elements in the list l.\n# >>> median {3 1 2 4 5}\n# 3\n# >>> median {-10 4 6 1000 10 20}\n# 15.0\nproc median {l} {\n",
        "canonical_solution": "    set l [lsort -real $l]\n    set len [llength $l]\n    if {$len % 2 == 1} {\n        return [lindex $l [expr {$len / 2}]]\n    } else {\n        return [expr {([lindex $l [expr {$len / 2}]] + [lindex $l [expr {$len / 2 - 1}]]) / 2.0}]\n    }\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {abs([median {3 1 2 4 5}] - 3) < 1e-4}\nassert {abs([median {-10 4 6 1000 10 20}] - 8.0) < 1e-4}\nassert {abs([median {5}] - 5) < 1e-4}\nassert {abs([median {6 5}] - 5.5) < 1e-4}\nassert {abs([median {8 1 3 9 9 2 7}] - 7) < 1e-4}\n",
        "declaration": "proc median {l} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {abs([median {3 1 2 4 5}] - 3) < 1e-4}\nassert {abs([median {-10 4 6 1000 10 20}] - 8.0) < 1e-4}\n",
        "prompt_text": "Return median of elements in the list l.",
        "prompt_explain": "Return median of elements in the list l.\n>>> median {3 1 2 4 5}\n3\n>>> median {-10 4 6 1000 10 20}\n15.0",
        "func_title": "proc median {l}"
    },
    {
        "prompt": "# Return 2^n modulo p (be aware of numerics).\n# >>> modp 3 5\n# 3\n# >>> modp 1101 101\n# 2\n# >>> modp 0 101\n# 1\n# >>> modp 3 11\n# 8\n# >>> modp 100 101\n# 1\nproc modp {n p} {\n",
        "canonical_solution": "    set out 1\n    for {set i 0} {$i < $n} {incr i} {\n        set out [expr {($out * 2) % $p}]\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[modp 3 5] == 3}\nassert {[modp 1101 101] == 2}\nassert {[modp 0 101] == 1}\nassert {[modp 3 11] == 8}\nassert {[modp 100 101] == 1}\nassert {[modp 30 5] == 4}\nassert {[modp 31 5] == 3}\n",
        "declaration": "proc modp {n p} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[modp 3 5] == 3}\nassert {[modp 1101 101] == 2}\nassert {[modp 0 101] == 1}\nassert {[modp 3 11] == 8}\nassert {[modp 100 101] == 1}\n",
        "prompt_text": "Return 2^n modulo p (be aware of numerics).",
        "prompt_explain": "Return 2^n modulo p (be aware of numerics).\n>>> modp 3 5\n3\n>>> modp 1101 101\n2\n>>> modp 0 101\n1\n>>> modp 3 11\n8\n>>> modp 100 101\n1",
        "func_title": "proc modp {n p}"
    },
    {
        "prompt": "# Insert a number \"delimeter\" between every two consecutive elements of input list `numbers\"\n# >>> intersperse {} 4\n# {}\n# >>> intersperse {1 2 3} 4\n# {1 4 2 4 3}\nproc intersperse {numbers delimeter} {\n",
        "canonical_solution": "    set out {}\n    if {[llength $numbers] > 0} {\n        lappend out [lindex $numbers 0]\n    }\n    for {set i 1} {$i < [llength $numbers]} {incr i} {\n        lappend out $delimeter\n        lappend out [lindex $numbers $i]\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [intersperse {} 7] {}]}\nassert {[issame [intersperse {5 6 3 2} 8] {5 8 6 8 3 8 2}]}\nassert {[issame [intersperse {2 2 2} 2] {2 2 2 2 2}]}\n",
        "declaration": "proc intersperse {numbers delimeter} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [intersperse {} 4] {}]}\nassert {[issame [intersperse {1 2 3} 4] {1 4 2 4 3}]}\n",
        "prompt_text": "Insert a number \"delimeter\" between every two consecutive elements of input list `numbers\"",
        "prompt_explain": "Insert a number \"delimeter\" between every two consecutive elements of input list `numbers\"\n>>> intersperse {} 4\n{}\n>>> intersperse {1 2 3} 4\n{1 4 2 4 3}",
        "func_title": "proc intersperse {numbers delimeter}"
    },
    {
        "prompt": "# takes as input string encoded with encode_shift function. Returns decoded string.\nproc decode_shift {s} {\n",
        "canonical_solution": "    set out \"\"\n    set length [string length $s]\n    for {set i 0} {$i < $length} {incr i} {\n        set char [string index $s $i]\n        set w [expr {([scan $char %c] + 21 - [scan \"a\" %c]) % 26 + [scan \"a\" %c]}]\n        append out [format %c $w]\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nfor {set i 0} {$i < 100} {incr i} {\n    set l [expr {10 + int(rand() * 11)}]\n    set str \"\"\n    for {set j 0} {$j < $l} {incr j} {\n        set chr [expr {97 + int(rand() * 26)}]\n        append str [format %c $chr]\n    }\n\n    set encoded_str [encode_shift $str]\n    assert {[decode_shift $encoded_str] == $str}\n}\n",
        "declaration": "proc decode_shift {s} {\n",
        "example_test": "",
        "prompt_text": " takes as input string encoded with encode_shift function. Returns decoded string.",
        "prompt_explain": " takes as input string encoded with encode_shift function. Returns decoded string.",
        "func_title": "proc decode_shift {s}"
    },
    {
        "prompt": "# Return true if all numbers in the list l are below threshold t.\n# >>> below_threshold {1 2 4 10} 100\n# true\n# >>> below_threshold {1 20 4 10} 5\n# false\nproc below_threshold {l t} {\n",
        "canonical_solution": "    foreach num $l {\n        if {$num >= $t} {\n            return false\n        }\n    }\n    return true\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[below_threshold {1 2 4 10} 100]}\nassert {![below_threshold {1 20 4 10} 5]}\nassert {[below_threshold {1 20 4 10} 21]}\nassert {[below_threshold {1 20 4 10} 22]}\nassert {[below_threshold {1 8 4 10} 11]}\nassert {![below_threshold {1 8 4 10} 10]}\n",
        "declaration": "proc below_threshold {l t} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[below_threshold {1 2 4 10} 100]}\nassert {![below_threshold {1 20 4 10} 5]}\n",
        "prompt_text": "Return true if all numbers in the list l are below threshold t.",
        "prompt_explain": "Return true if all numbers in the list l are below threshold t.\n>>> below_threshold {1 2 4 10} 100\ntrue\n>>> below_threshold {1 20 4 10} 5\nfalse",
        "func_title": "proc below_threshold {l t}"
    },
    {
        "prompt": "# Add two numbers x and y\n# >>> add 2 3\n# 5\n# >>> add 5 7\n# 12\nproc add {x y} {\n",
        "canonical_solution": "    return [expr {$x + $y}]\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[add 0 1] == 1}\nassert {[add 1 0] == 1}\nassert {[add 2 3] == 5}\nassert {[add 5 7] == 12}\nassert {[add 7 5] == 12}\nfor {set i 0} {$i < 100} {incr i} {\n    set x [expr {int(rand() * 1000)}]\n    set y [expr {int(rand() * 1000)}]\n    assert {[add $x $y] == [expr {$x + $y}]}\n}\n",
        "declaration": "proc add {x y} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[add 2 3] == 5}\nassert {[add 5 7] == 12}\n",
        "prompt_text": "Add two numbers x and y",
        "prompt_explain": "Add two numbers x and y\n>>> add 2 3\n5\n>>> add 5 7\n12",
        "func_title": "proc add {x y}"
    },
    {
        "prompt": "# Check if two words have the same characters.\n# >>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\"\n# true\n# >>> same_chars \"abcd\" \"dddddddabc\"\n# true\n# >>> same_chars \"dddddddabc\" \"abcd\"\n# true\n# >>> same_chars \"eabcd\" \"dddddddabc\"\n# false\n# >>> same_chars \"abcd\" \"dddddddabce\"\n# false\n# >>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddddabc\"\n# false\nproc same_chars {s0 s1} {\n",
        "canonical_solution": "    foreach char [split $s0 \"\"] {\n        if {[string first $char $s1] == -1} {\n            return false\n        }\n    }\n    foreach char [split $s1 \"\"] {\n        if {[string first $char $s0] == -1} {\n            return false\n        }\n    }\n    return true\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[same_chars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\"] == true}\nassert {[same_chars \"abcd\" \"dddddddabc\"] == true}\nassert {[same_chars \"dddddddabc\" \"abcd\"] == true}\nassert {[same_chars \"eabcd\" \"dddddddabc\"] == false}\nassert {[same_chars \"abcd\" \"dddddddabcf\"] == false}\nassert {[same_chars \"eabcdzzzz\" \"dddzzzzzzzddddabc\"] == false}\nassert {[same_chars \"aabb\" \"aaccc\"] == false}\n",
        "declaration": "proc same_chars {s0 s1} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[same_chars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\"] == true}\nassert {[same_chars \"abcd\" \"dddddddabc\"] == true}\nassert {[same_chars \"dddddddabc\" \"abcd\"] == true}\nassert {[same_chars \"eabcd\" \"dddddddabc\"] == false}\nassert {[same_chars \"abcd\" \"dddddddabcf\"] == false}\nassert {[same_chars \"eabcdzzzz\" \"dddzzzzzzzddddabc\"] == false}\n",
        "prompt_text": "Check if two words have the same characters.",
        "prompt_explain": "Check if two words have the same characters.\n>>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\"\ntrue\n>>> same_chars \"abcd\" \"dddddddabc\"\ntrue\n>>> same_chars \"dddddddabc\" \"abcd\"\ntrue\n>>> same_chars \"eabcd\" \"dddddddabc\"\nfalse\n>>> same_chars \"abcd\" \"dddddddabce\"\nfalse\n>>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddddabc\"\nfalse",
        "func_title": "proc same_chars {s0 s1}"
    },
    {
        "prompt": "# Return n-th Fibonacci number.\n# >>> fib 10\n# 55\n# >>> fib 1\n# 1\n# >>> fib 8\n# 21\nproc fib {n} {\n",
        "canonical_solution": "    set f [list 0 1]\n    for {set i 2} {$i <= $n} {incr i} {\n        lappend f [expr {[lindex $f [expr {$i - 1}]] + [lindex $f [expr {$i - 2}]]}]\n    }\n    return [lindex $f $n]\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[fib 10] == 55}\nassert {[fib 1] == 1}\nassert {[fib 8] == 21}\nassert {[fib 11] == 89}\nassert {[fib 12] == 144}\n",
        "declaration": "proc fib {n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[fib 10] == 55}\nassert {[fib 1] == 1}\nassert {[fib 8] == 21}\n",
        "prompt_text": "Return n-th Fibonacci number.",
        "prompt_explain": "Return n-th Fibonacci number.\n>>> fib 10\n55\n>>> fib 1\n1\n>>> fib 8\n21",
        "func_title": "proc fib {n}"
    },
    {
        "prompt": "# brackets is a string of '<' and '>'.\n# return true if every opening bracket has a corresponding closing bracket.\n# >>> correct_bracketing \"<\"\n# false\n# >>> correct_bracketing \"<>\"\n# true\n# >>> correct_bracketing \"<<><>>\"\n# true\n# >>> correct_bracketing \"><<>\"\n# false\nproc correct_bracketing {brackets} {\n",
        "canonical_solution": "    set level 0\n    set length [string length $brackets]\n    for {set i 0} {$i < $length} {incr i} {\n        set char [string index $brackets $i]\n        if {$char eq \"<\"} {\n            incr level\n        } elseif {$char eq \">\"} {\n            incr level -1\n        }\n        if {$level < 0} {\n            return false\n        }\n    }\n    if {$level != 0} {\n        return false\n    }\n    return true\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[correct_bracketing \"<>\"]}\nassert {[correct_bracketing \"<<><>>\"]}\nassert {[correct_bracketing \"<><><<><>><>\"]}\nassert {[correct_bracketing \"<><><<<><><>><>><<><><<>>>\"]}\nassert {![correct_bracketing \"<<<><>>>>\"]}\nassert {![correct_bracketing \"><<>\"]}\nassert {![correct_bracketing \"<\"]}\nassert {![correct_bracketing \"<<<<\"]}\nassert {![correct_bracketing \">\"]}\nassert {![correct_bracketing \"<<>\"]}\nassert {![correct_bracketing \"<><><<><>><>><<>\"]}\nassert {![correct_bracketing \"<><><<><>><>>><>\"]}\n",
        "declaration": "proc correct_bracketing {brackets} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[correct_bracketing \"<>\"]}\nassert {[correct_bracketing \"<<><>>\"]}\nassert {![correct_bracketing \"><<>\"]}\nassert {![correct_bracketing \"<\"]}\n",
        "prompt_text": "brackets is a string of '<' and '>'. return true if every opening bracket has a corresponding closing bracket.",
        "prompt_explain": "brackets is a string of '<' and '>'.\nreturn true if every opening bracket has a corresponding closing bracket.\n\n>>> correct_bracketing \"<\"\nfalse\n>>> correct_bracketing \"<>\"\ntrue\n>>> correct_bracketing \"<<><>>\"\ntrue\n>>> correct_bracketing \"><<>\"\nfalse",
        "func_title": "proc correct_bracketing {brackets}"
    },
    {
        "prompt": "# Return true is list elements are monotonically increasing or decreasing.\n# >>> monotonic {1 2 4 20}\n# true\n# >>> monotonic {1 20 4 10}\n# false\n# >>> monotonic {4 1 0 -10}\n# true\nproc monotonic {l} {\n",
        "canonical_solution": "    set incr 0\n    set decr 0\n    set length [llength $l]\n    for {set i 1} {$i < $length} {incr i} {\n        if {[lindex $l $i] > [lindex $l [expr {$i - 1}]]} {\n            set incr 1\n        }\n        if {[lindex $l $i] < [lindex $l [expr {$i - 1}]]} {\n            set decr 1\n        }\n    }\n    if {[expr {$incr + $decr}] == 2} {\n        return false\n    }\n    return true\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[monotonic {1 2 4 10}] == true}\nassert {[monotonic {1 2 4 20}] == true}\nassert {[monotonic {1 20 4 10}] == false}\nassert {[monotonic {4 1 0 -10}] == true}\nassert {[monotonic {4 1 1 0}] == true}\nassert {[monotonic {1 2 3 2 5 60}] == false}\nassert {[monotonic {1 2 3 4 5 60}] == true}\nassert {[monotonic {9 9 9 9}] == true}\n",
        "declaration": "proc monotonic {l} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[monotonic {1 2 4 10}] == true}\nassert {[monotonic {1 20 4 10}] == false}\nassert {[monotonic {4 1 0 -10}] == true}\n",
        "prompt_text": "Return true is list elements are monotonically increasing or decreasing.",
        "prompt_explain": "Return true is list elements are monotonically increasing or decreasing.\n>>> monotonic {1 2 4 20}\ntrue\n>>> monotonic {1 20 4 10}\nfalse\n>>> monotonic {4 1 0 -10}\ntrue",
        "func_title": "proc monotonic {l}"
    },
    {
        "prompt": "# Return sorted unique common elements for two lists.\n# >>> common {1 4 3 34 653 2 5} {5 7 1 5 9 653 121}\n# {1 5 653}\n# >>> common {5 3 2 8} {3 2}\n# {2 3}\nproc common {l1 l2} {\n",
        "canonical_solution": "    set out {}\n    foreach elem $l1 {\n        if {[lsearch -exact $out $elem] == -1 && [lsearch -exact $l2 $elem] != -1} {\n            lappend out $elem\n        }\n    }\n    set out [lsort -integer $out]\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [common {1 4 3 34 653 2 5} {5 7 1 5 9 653 121}] {1 5 653}]}\nassert {[issame [common {5 3 2 8} {3 2}] {2 3}]}\nassert {[issame [common {4 3 2 8} {3 2 4}] {2 3 4}]}\nassert {[issame [common {4 3 2 8} {}] {}]}\n",
        "declaration": "proc common {l1 l2} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [common {1 4 3 34 653 2 5} {5 7 1 5 9 653 121}] {1 5 653}]}\nassert {[issame [common {5 3 2 8} {3 2}] {2 3}]}\n",
        "prompt_text": "Return sorted unique common elements for two lists.",
        "prompt_explain": "Return sorted unique common elements for two lists.\n>>> common {1 4 3 34 653 2 5} {5 7 1 5 9 653 121}\n{1 5 653}\n>>> common {5 3 2 8} {3 2}\n{2 3}\n",
        "func_title": "proc common {l1 l2}"
    },
    {
        "prompt": "# Return the largest prime factor of n. Assume n > 1 and is not a prime.\n# >>> largest_prime_factor 13195\n# 29\n# >>> largest_prime_factor 2048\n# 2\nproc largest_prime_factor {n} {\n",
        "canonical_solution": "    for {set i 2} {$i * $i <= $n} {incr i} {\n        while {$n % $i == 0 && $n > $i} {\n            set n [expr {$n / $i}]\n        }\n    }\n    return $n\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[largest_prime_factor 15] == 5}\nassert {[largest_prime_factor 27] == 3}\nassert {[largest_prime_factor 63] == 7}\nassert {[largest_prime_factor 330] == 11}\nassert {[largest_prime_factor 13195] == 29}\n",
        "declaration": "proc largest_prime_factor {n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[largest_prime_factor 2048] == 2}\nassert {[largest_prime_factor 13195] == 29}\n",
        "prompt_text": "Return the largest prime factor of n. Assume n > 1 and is not a prime.",
        "prompt_explain": "Return the largest prime factor of n. Assume n > 1 and is not a prime.\n>>> largest_prime_factor 13195\n29\n>>> largest_prime_factor 2048\n2",
        "func_title": "proc largest_prime_factor {n}"
    },
    {
        "prompt": "# Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n# For each of the group, output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum two levels of nesting while ((())) has three.\n# >>> parse_nested_parens \"(()()) ((())) () ((())()())\"\n# {2 3 1 3}\nproc parse_nested_parens {paren_string} {\n",
        "canonical_solution": "    set all_levels {}\n    set current_paren \"\"\n    set level 0\n    set max_level 0\n    foreach chr [split $paren_string \"\"] {\n        if {$chr eq \"(\"} {\n            incr level\n            if {$level > $max_level} {set max_level $level}\n            append current_paren $chr\n        }\n        if {$chr eq \")\"} {\n            incr level -1\n            append current_paren $chr\n            if {$level == 0} {\n                lappend all_levels $max_level\n                set current_paren \"\"\n                set max_level 0\n            }\n        }\n    }\n    return $all_levels\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [parse_nested_parens \"(()()) ((())) () ((())()())\"] {2 3 1 3}]}\nassert {[issame [parse_nested_parens \"() (()) ((())) (((())))\"] {1 2 3 4}]}\nassert {[issame [parse_nested_parens \"(()(())((())))\"] {4}]}\n",
        "declaration": "proc parse_nested_parens {paren_string} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [parse_nested_parens \"(()()) ((())) () ((())()())\"] {2 3 1 3}]}\n",
        "prompt_text": "Input to this function is a string represented multiple groups for nested parentheses separated by spaces. For each of the group, output the deepest level of nesting of parentheses. E.g. (()()) has maximum two levels of nesting while ((())) has three.",
        "prompt_explain": "Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\nFor each of the group, output the deepest level of nesting of parentheses.\nE.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n>>> parse_nested_parens \"(()()) ((())) () ((())()())\"\n{2 3 1 3}",
        "func_title": "proc parse_nested_parens {paren_string}"
    },
    {
        "prompt": "# sum_to_n is a function that sums numbers from 1 to n.\n# >>> sum_to_n 30\n# 465\n# >>> sum_to_n 100\n# 5050\n# >>> sum_to_n 5\n# 15\n# >>> sum_to_n 10\n# 55\n# >>> sum_to_n 1\n# 1\nproc sum_to_n {n} {\n",
        "canonical_solution": "    return [expr {$n * ($n + 1) / 2}]\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_to_n 1] == 1}\nassert {[sum_to_n 6] == 21}\nassert {[sum_to_n 11] == 66}\nassert {[sum_to_n 30] == 465}\nassert {[sum_to_n 100] == 5050}\n",
        "declaration": "proc sum_to_n {n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_to_n 1] == 1}\nassert {[sum_to_n 5] == 15}\nassert {[sum_to_n 10] == 55}\nassert {[sum_to_n 30] == 465}\nassert {[sum_to_n 100] == 5050}\n",
        "prompt_text": "sum_to_n is a function that sums numbers from 1 to n.",
        "prompt_explain": "sum_to_n is a function that sums numbers from 1 to n.\n>>> sum_to_n 30\n465\n>>> sum_to_n 100\n5050\n>>> sum_to_n 5\n15\n>>> sum_to_n 10\n55\n>>> sum_to_n 1\n1",
        "func_title": "proc sum_to_n {n}"
    },
    {
        "prompt": "# brackets is a string of '(' and ')'. return true if every opening bracket has a corresponding closing bracket.\n# >>> correct_bracketing \"(\"\n# false\n# >>> correct_bracketing \"()\"\n# true\n# >>> correct_bracketing \"(()())\"\n# true\n# >>> correct_bracketing \")(()\"\n# false\nproc correct_bracketing {brackets} {\n",
        "canonical_solution": "    set level 0\n    set length [string length $brackets]\n    for {set i 0} {$i < $length} {incr i} {\n        set char [string index $brackets $i]\n        if {$char eq \"(\"} {\n            incr level\n        } elseif {$char eq \")\"} {\n            incr level -1\n        }\n        if {$level < 0} {\n            return false\n        }\n    }\n    if {$level != 0} {\n        return false\n    }\n    return true\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[correct_bracketing \"()\"]}\nassert {[correct_bracketing \"(()())\"]}\nassert {[correct_bracketing \"()()(()())()\"]}\nassert {[correct_bracketing \"()()((()()())())(()()(()))\"]}\nassert {![correct_bracketing \"((()())))\"]}\nassert {![correct_bracketing \")(()\"}\nassert {![correct_bracketing \"(\"]}\nassert {![correct_bracketing \"((((\"]}\nassert {![correct_bracketing \")\"]}\nassert {![correct_bracketing \"(()\"]}\nassert {![correct_bracketing \"()()(()())())(()\"]}\nassert {![correct_bracketing \"()()(()())()))()\"]}\n",
        "declaration": "proc correct_bracketing {brackets} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[correct_bracketing \"()\"]}\nassert {[correct_bracketing \"(()())\"]}\nassert {![correct_bracketing \")(()\"]}\nassert {![correct_bracketing \"(\"]}\n",
        "prompt_text": "brackets is a string of '(' and ')'. return true if every opening bracket has a corresponding closing bracket.",
        "prompt_explain": "brackets is a string of '(' and ')'.\nreturn true if every opening bracket has a corresponding closing bracket.\n\n>>> correct_bracketing \"(\"\nfalse\n>>> correct_bracketing \"()\"\ntrue\n>>> correct_bracketing \"(()())\"\ntrue\n>>> correct_bracketing \")(()\"\nfalse",
        "func_title": "proc correct_bracketing {brackets}"
    },
    {
        "prompt": "# xs represent coefficients of a polynomial. xs{0} + xs{1} * x + xs{2} * x^2 + .... Return derivative of this polynomial in the same form.\n# >>> derivative {3 1 2 4 5}\n# {1 4 12 20}\n# >>> derivative {1 2 3}\n# {2 6}\nproc derivative {xs} {\n",
        "canonical_solution": "    set out {}\n    set length [llength $xs]\n    for {set i 1} {$i < $length} {incr i} {\n        lappend out [expr {$i * [lindex $xs $i]}]\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {abs([lindex $a $i] - [lindex $b $i]) > 1e-4} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [derivative {3 1 2 4 5}] {1 4 12 20}]}\nassert {[issame [derivative {1 2 3}] {2 6}]}\nassert {[issame [derivative {3 2 1}] {2 2}]}\nassert {[issame [derivative {3 2 1 0 4}] {2 2 0 16}]}\nassert {[issame [derivative {1}] {}]}\n",
        "declaration": "proc derivative {xs} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {abs([lindex $a $i] - [lindex $b $i]) > 1e-4} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [derivative {3 1 2 4 5}] {1 4 12 20}]}\nassert {[issame [derivative {1 2 3}] {2 6}]}\n",
        "prompt_text": "xs represent coefficients of a polynomial. xs{0} + xs{1} * x + xs{2} * x^2 + .... Return derivative of this polynomial in the same form.",
        "prompt_explain": "xs represent coefficients of a polynomial.\nxs{0} + xs{1} * x + xs{2} * x^2 + ....\nReturn derivative of this polynomial in the same form.\n>>> derivative {3 1 2 4 5}\n{1 4 12 20}\n>>> derivative {1 2 3}\n{2 6}",
        "func_title": "proc derivative {xs}"
    },
    {
        "prompt": "# The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n# fibfib(0) == 0\n# fibfib(1) == 0\n# fibfib(2) == 1\n# fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n# Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n# >>> fibfib 1\n# 0\n# >>> fibfib 5\n# 4\n# >>> fibfib 8\n# 24\nproc fibfib {n} {\n",
        "canonical_solution": "    if {$n == 0 || $n == 1} {\n        return 0\n    } elseif {$n == 2} {\n        return 1\n    }\n    set ff [list 0 0 1]\n    for {set i 3} {$i <= $n} {incr i} {\n        lappend ff [expr {[lindex $ff [expr {$i - 1}]] + [lindex $ff [expr {$i - 2}]] + [lindex $ff [expr {$i - 3}]]}]\n    }\n    return [lindex $ff $n]\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[fibfib 2] == 1}\nassert {[fibfib 1] == 0}\nassert {[fibfib 5] == 4}\nassert {[fibfib 8] == 24}\nassert {[fibfib 10] == 81}\nassert {[fibfib 12] == 274}\nassert {[fibfib 14] == 927}\n",
        "declaration": "proc fibfib {n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[fibfib 1] == 0}\nassert {[fibfib 5] == 4}\nassert {[fibfib 8] == 24}\n",
        "prompt_text": "The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:",
        "prompt_explain": "The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\nfibfib(0) == 0\nfibfib(1) == 0\nfibfib(2) == 1\nfibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\nPlease write a function to efficiently compute the n-th element of the fibfib number sequence.\n>>> fibfib 1\n0\n>>> fibfib 5\n4\n>>> fibfib 8\n24",
        "func_title": "proc fibfib {n}"
    },
    {
        "prompt": "# Write a function vowels_count which takes a string representing a word as input and returns the number of vowels in the string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'. \n# Here, 'y' is also a vowel, but only when it is at the end of the given word.\n# Example: \n# >>> vowels_count \"abcde\" \n# 2 \n# >>> vowels_count \"ACEDY\" \n# 3\nproc vowels_count {s} {\n",
        "canonical_solution": "    set vowels \"aeiouAEIOU\"\n    set count 0\n    set length [string length $s]\n    for {set i 0} {$i < $length} {incr i} {\n        set char [string index $s $i]\n        if {[string first $char $vowels] != -1} {\n            incr count\n        }\n    }\n    set last_char [string index $s end]\n    if {$last_char == \"y\" || $last_char == \"Y\"} {\n        incr count\n    }\n    return $count\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[vowels_count \"abcde\"] == 2}\nassert {[vowels_count \"Alone\"] == 3}\nassert {[vowels_count \"key\"] == 2}\nassert {[vowels_count \"bye\"] == 1}\nassert {[vowels_count \"keY\"] == 2}\nassert {[vowels_count \"bYe\"] == 1}\nassert {[vowels_count \"ACEDY\"] == 3}\n",
        "declaration": "proc vowels_count {s} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[vowels_count \"abcde\"] == 2}\nassert {[vowels_count \"ACEDY\"] == 3}\n",
        "prompt_text": "Write a function vowels_count which takes a string representing a word as input and returns the number of vowels in the string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a vowel, but only when it is at the end of the given word.",
        "prompt_explain": "Write a function vowels_count which takes a string representing a word as input and returns the number of vowels in the string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'.\nHere, 'y' is also a vowel, but only when it is at the end of the given word.\nExample:\n>>> vowels_count \"abcde\"\n2\n>>> vowels_count \"ACEDY\"\n3",
        "func_title": "proc vowels_count {s}"
    },
    {
        "prompt": "# Task\n# Write a function that takes a string as input and returns the sum of the upper characters only's ASCII codes.\n#\n# Examples:\n# digitSum \"\" => 0\n# digitSum \"abAB\" => 131\n# digitSum \"abcCd\" => 67\n# digitSum \"helloE\" => 69\n# digitSum \"woArBld\" => 131\n# digitSum \"aAaaaXa\" => 153\nproc digitSum {s} {\n",
        "canonical_solution": "    set sum 0\n    foreach char [split $s \"\"] {\n        if {[string is upper $char]} {\n            incr sum [scan $char %c]\n        }\n    }\n    return $sum\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[digitSum \"\"] == 0}\nassert {[digitSum \"abAB\"] == 131}\nassert {[digitSum \"abcCd\"] == 67}\nassert {[digitSum \"helloE\"] == 69}\nassert {[digitSum \"woArBld\"] == 131}\nassert {[digitSum \"aAaaaXa\"] == 153}\nassert {[digitSum \" How are yOu?\"] == 151}\nassert {[digitSum \"You arE Very Smart\"] == 327}\n",
        "declaration": "proc digitSum {s} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[digitSum \"\"] == 0}\nassert {[digitSum \"abAB\"] == 131}\nassert {[digitSum \"abcCd\"] == 67}\nassert {[digitSum \"helloE\"] == 69}\nassert {[digitSum \"woArBld\"] == 131}\nassert {[digitSum \"aAaaaXa\"] == 153}\n",
        "prompt_text": "Task Write a function that takes a string as input and returns the sum of the upper characters only's ASCII codes. Examples: digitSum \"\" => 0 digitSum \"abAB\" => 131 digitSum \"abcCd\" => 67 digitSum \"helloE\" => 69 digitSum \"woArBld\" => 131 digitSum \"aAaaaXa\" => 153",
        "prompt_explain": "Task\nWrite a function that takes a string as input and returns the sum of the upper characters only's\nASCII codes.\n\nExamples:\ndigitSum \"\" => 0\ndigitSum \"abAB\" => 131\ndigitSum \"abcCd\" => 67\ndigitSum \"helloE\" => 69\ndigitSum \"woArBld\" => 131\ndigitSum \"aAaaaXa\" => 153",
        "func_title": "proc digitSum {s}"
    },
    {
        "prompt": "# In this task, you will be given a string that represents a number of apples and oranges that are distributed in a basket of fruit this basket contains apples, oranges, and mango fruits. Given the string that represents the total number of the oranges and apples and an integer that represent the total number of the fruits in the basket return the number of the mango fruits in the basket.\n# for example:\n# fruit_distribution \"5 apples and 6 oranges\" 19 ->19 - 5 - 6 = 8\n# fruit_distribution \"0 apples and 1 oranges\" 3 -> 3 - 0 - 1 = 2\n# fruit_distribution \"2 apples and 3 oranges\" 100 -> 100 - 2 - 3 = 95\n# fruit_distribution \"100 apples and 1 oranges\" 120 -> 120 - 100 - 1 = 19\nproc fruit_distribution {s n} {\n",
        "canonical_solution": "    set num1 \"\"\n    set num2 \"\"\n    set is12 0\n    for {set i 0} {$i < [string length $s]} {incr i} {\n        set char [string index $s $i]\n        if {[string is digit $char]} {\n            if {$is12 == 0} {\n                append num1 $char\n            } else {\n                append num2 $char\n            }\n        } else {\n            if {$is12 == 0 && [string length $num1] > 0} {\n                set is12 1\n            }\n        }\n    }\n    return [expr {$n - $num1 - $num2}]\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[fruit_distribution \"5 apples and 6 oranges\" 19] == 8}\nassert {[fruit_distribution \"5 apples and 6 oranges\" 21] == 10}\nassert {[fruit_distribution \"0 apples and 1 oranges\" 3] == 2}\nassert {[fruit_distribution \"1 apples and 0 oranges\" 3] == 2}\nassert {[fruit_distribution \"2 apples and 3 oranges\" 100] == 95}\nassert {[fruit_distribution \"2 apples and 3 oranges\" 5] == 0}\nassert {[fruit_distribution \"1 apples and 100 oranges\" 120] == 19}\n",
        "declaration": "proc fruit_distribution {s n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[fruit_distribution \"5 apples and 6 oranges\" 19] == 8}\nassert {[fruit_distribution \"0 apples and 1 oranges\" 3] == 2}\nassert {[fruit_distribution \"2 apples and 3 oranges\" 100] == 95}\nassert {[fruit_distribution \"1 apples and 100 oranges\" 120] == 19}\n",
        "prompt_text": "In this task, you will be given a string that represents a number of apples and oranges that are distributed in a basket of fruit this basket contains apples, oranges, and mango fruits. Given the string that represents the total number of the oranges and apples and an integer that represent the total number of the fruits in the basket return the number of the mango fruits in the basket.",
        "prompt_explain": "In this task, you will be given a string that represents a number of apples and oranges\nthat are distributed in a basket of fruit this basket contains\napples, oranges, and mango fruits. Given the string that represents the total number of\nthe oranges and apples and an integer that represent the total number of the fruits\nin the basket return the number of the mango fruits in the basket.\nfor example:\nfruit_distribution \"5 apples and 6 oranges\" 19 ->19 - 5 - 6 = 8\nfruit_distribution \"0 apples and 1 oranges\" 3 -> 3 - 0 - 1 = 2\nfruit_distribution \"2 apples and 3 oranges\" 100 -> 100 - 2 - 3 = 95\nfruit_distribution \"100 apples and 1 oranges\" 120 -> 120 - 100 - 1 = 19",
        "func_title": "proc fruit_distribution {s n}"
    },
    {
        "prompt": "# You are given a non-empty list of positive integers. Return the greatest integer that is greater than zero, and has a frequency greater than or equal to the value of the integer itself. The frequency of an integer is the number of times it appears in the list. If no such a value exist, return -1.\n# Examples:\n# search {4 1 2 2 3 1} == 2\n# search {1 2 2 3 3 3 4 4 4} == 3\n# search {5 5 4 4 4} == -1\nproc search {lst} {\n",
        "canonical_solution": "    array set freq {}\n    set max -1\n    foreach num $lst {\n        if {[info exists freq($num)]} {\n            incr freq($num)\n        } else {\n            set freq($num) 1\n        }\n        if {$freq($num) >= $num && $num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[search {5 5 5 5 1}] == 1}\nassert {[search {4 1 4 1 4 4}] == 4}\nassert {[search {3 3}] == -1}\nassert {[search {8 8 8 8 8 8 8 8}] == 8}\nassert {[search {2 3 3 2 2}] == 2}\nassert {[search {2 7 8 8 4 8 7 3 9 6 5 10 4 3 6 7 1 7 4 10 8 1}] == 1}\nassert {[search {3 2 8 2}] == 2}\nassert {[search {6 7 1 8 8 10 5 8 5 3 10}] == 1}\nassert {[search {8 8 3 6 5 6 4}] == -1}\nassert {[search {6 9 6 7 1 4 7 1 8 8 9 8 10 10 8 4 10 4 10 1 2 9 5 7 9}] == 1}\nassert {[search {1 9 10 1 3}] == 1}\nassert {[search {6 9 7 5 8 7 5 3 7 5 10 10 3 6 10 2 8 6 5 4 9 5 3 10}] == 5}\nassert {[search {1}] == 1}\nassert {[search {8 8 10 6 4 3 5 8 2 4 2 8 4 6 10 4 2 1 10 2 1 1 5}] == 4}\nassert {[search {2 10 4 8 2 10 5 1 2 9 5 5 6 3 8 6 4 10}] == 2}\nassert {[search {1 6 10 1 6 9 10 8 6 8 7 3}] == 1}\nassert {[search {9 2 4 1 5 1 5 2 5 7 7 7 3 10 1 5 4 2 8 4 1 9 10 7 10 2 8 10 9 4}] == 4}\nassert {[search {2 6 4 2 8 7 5 6 4 10 4 6 3 7 8 8 3 1 4 2 2 10 7}] == 4}\nassert {[search {9 8 6 10 2 6 10 2 7 8 10 3 8 2 6 2 3 1}] == 2}\nassert {[search {5 5 3 9 5 6 3 2 8 5 6 10 10 6 8 4 10 7 7 10 8}] == -1}\nassert {[search {10}] == -1}\nassert {[search {9 7 7 2 4 7 2 10 9 7 5 7 2}] == 2}\nassert {[search {5 4 10 2 1 1 10 3 6 1 8}] == 1}\nassert {[search {7 9 9 9 3 4 1 5 9 1 2 1 1 10 7 5 6 7 6 7 7 6}] == 1}\nassert {[search {3 10 10 9 2}] == -1}\n",
        "declaration": "proc search {lst} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[search {4 1 2 2 3 1}] == 2}\nassert {[search {1 2 2 3 3 3 4 4 4}] == 3}\nassert {[search {5 5 4 4 4}] == -1}\n",
        "prompt_text": "You are given a non-empty list of positive integers. Return the greatest integer that is greater than zero, and has a frequency greater than or equal to the value of the integer itself. The frequency of an integer is the number of times it appears in the list. If no such a value exist, return -1.",
        "prompt_explain": "You are given a non-empty list of positive integers. Return the greatest integer that is greater than zero, and has a frequency greater than or equal to the value of the integer itself. The frequency of an integer is the number of times it appears in the list. If no such a value exist, return -1.\nExamples:\nsearch {4 1 2 2 3 1} == 2\nsearch {1 2 2 3 3 3 4 4 4} == 3\nsearch {5 5 4 4 4} == -1",
        "func_title": "proc search {lst}"
    },
    {
        "prompt": "# Filter an input list of strings only for ones that contain given substring\n# >>> filter_by_substring {} \"a\"\n# {}\n# >>> filter_by_substring {\"abc\" \"bacd\" \"cde\" \"vector\"} \"a\"\n# {\"abc\" \"bacd\" \"vector\"}\nproc filter_by_substring {strings substring} {\n",
        "canonical_solution": "    set out {}\n    foreach str $strings {\n        if {[string first $substring $str] != -1} {\n            lappend out $str\n        }\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] ne [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [filter_by_substring {} \"john\"] {}]}\nassert {[issame [filter_by_substring {\"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\"} \"xxx\"] {\"xxx\" \"xxxAAA\" \"xxx\"}]}\nassert {[issame [filter_by_substring {\"xxx\" \"asd\" \"aaaxxy\" \"john doe\" \"xxxAAA\" \"xxx\"} \"xx\"] {\"xxx\" \"aaaxxy\" \"xxxAAA\" \"xxx\"}]}\nassert {[issame [filter_by_substring {\"grunt\" \"trumpet\" \"prune\" \"gruesome\"} \"run\"] {\"grunt\" \"prune\"}]}\n",
        "declaration": "proc filter_by_substring {strings substring} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] ne [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [filter_by_substring {} \"a\"] {}]}\nassert {[issame [filter_by_substring {\"abc\" \"bacd\" \"cde\" \"array\"} \"a\"] {\"abc\" \"bacd\" \"array\"}]}\n",
        "prompt_text": "Filter an input list of strings only for ones that contain given substring",
        "prompt_explain": "Filter an input list of strings only for ones that contain given substring\n>>> filter_by_substring {} \"a\"\n{}\n>>> filter_by_substring {\"abc\" \"bacd\" \"cde\" \"vector\"} \"a\"\n{\"abc\" \"bacd\" \"vector\"}",
        "func_title": "proc filter_by_substring {strings substring}"
    },
    {
        "prompt": "# Given list of integers, return list in strange order.\n# Strange sorting, is when you start with the minimum value,\n# then maximum of the remaining integers, then minimum and so on.\n#\n# Examples:\n# strange_sort_list {1 2 3 4} == {1 4 2 3}\n# strange_sort_list {5 5 5 5} == {5 5 5 5}\n# strange_sort_list {} == {}\nproc strange_sort_list {lst} {\n",
        "canonical_solution": "    set out {}\n    set lst [lsort -integer $lst]\n    set l 0\n    set r [expr {[llength $lst] - 1}]\n    while {$l < $r} {\n        lappend out [lindex $lst $l]\n        incr l\n        lappend out [lindex $lst $r]\n        incr r -1\n    }\n    if {$l == $r} {\n        lappend out [lindex $lst $l]\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [strange_sort_list {1 2 3 4}] {1 4 2 3}]}\nassert {[issame [strange_sort_list {5 6 7 8 9}] {5 9 6 8 7}]}\nassert {[issame [strange_sort_list {1 2 3 4 5}] {1 5 2 4 3}]}\nassert {[issame [strange_sort_list {5 6 7 8 9 1}] {1 9 5 8 6 7}]}\nassert {[issame [strange_sort_list {5 5 5 5}] {5 5 5 5}]}\nassert {[issame [strange_sort_list {}] {}]}\nassert {[issame [strange_sort_list {1 2 3 4 5 6 7 8}] {1 8 2 7 3 6 4 5}]}\nassert {[issame [strange_sort_list {0 2 2 2 5 5 -5 -5}] {-5 5 -5 5 0 2 2 2}]}\nassert {[issame [strange_sort_list {111111}] {111111}]}\n",
        "declaration": "proc strange_sort_list {lst} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {\n            return false\n        }\n    }\n    return true\n}\n\nassert {[issame [strange_sort_list {1 2 3 4}] {1 4 2 3}]}\nassert {[issame [strange_sort_list {5 5 5 5}] {5 5 5 5}]}\nassert {[issame [strange_sort_list {}] {}]}\n",
        "prompt_text": "Given list of integers, return list in strange order. Strange sorting, is when you start with the minimum value, then maximum of the remaining integers, then minimum and so on. Examples: strange_sort_list {1 2 3 4} == {1 4 2 3} strange_sort_list {5 5 5 5} == {5 5 5 5} strange_sort_list {} == {}",
        "prompt_explain": "Given list of integers, return list in strange order.\nStrange sorting, is when you start with the minimum value,\nthen maximum of the remaining integers, then minimum and so on.\n\nExamples:\nstrange_sort_list {1 2 3 4} == {1 4 2 3}\nstrange_sort_list {5 5 5 5} == {5 5 5 5}\nstrange_sort_list {} == {}",
        "func_title": "proc strange_sort_list {lst}"
    },
    {
        "prompt": "# Given the lengths of the three sides of a triangle. Return the area of the triangle rounded to 2 decimal points if the three sides form a valid triangle. Otherwise return -1 Three sides make a valid triangle when the sum of any two sides is greater than the third side.\n# Example:\n# triangle_area 3 4 5 == 6.00\n# triangle_area 1 2 10 == -1\nproc triangle_area {a b c} {\n",
        "canonical_solution": "    if {$a+$b<=$c || $a+$c<=$b || $b+$c<=$a} {return -1}\n    set h [expr {($a+$b+$c)/2.0}]\n    set area [expr {sqrt($h*($h-$a)*($h-$b)*($h-$c))}]\n    return [expr {round($area*100)/100}]\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {abs([triangle_area 3 4 5] - 6.00) < 0.01}\nassert {abs([triangle_area 1 2 10] + 1) < 0.01}\nassert {abs([triangle_area 4 8 5] - 8.18) < 0.01}\nassert {abs([triangle_area 2 2 2] - 1.73) < 0.01}\nassert {abs([triangle_area 1 2 3] + 1) < 0.01}\nassert {abs([triangle_area 10 5 7] - 16.25) < 0.01}\nassert {abs([triangle_area 2 6 3] + 1) < 0.01}\nassert {abs([triangle_area 1 1 1] - 0.43) < 0.01}\nassert {abs([triangle_area 2 2 10] + 1) < 0.01}\n",
        "declaration": "proc triangle_area {a b c} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {abs([triangle_area 3 4 5] - 6.00) < 0.01}\nassert {abs([triangle_area 1 2 10] + 1) < 0.01}\n",
        "prompt_text": "Given the lengths of the three sides of a triangle. Return the area of the triangle rounded to 2 decimal points if the three sides form a valid triangle. Otherwise return -1 Three sides make a valid triangle when the sum of any two sides is greater than the third side.",
        "prompt_explain": "Given the lengths of the three sides of a triangle. Return the area of the triangle rounded to 2 decimal points if the three sides form a valid triangle. Otherwise return -1 Three sides make a valid triangle when the sum of any two sides is greater than the third side.\nExample:\ntriangle_area 3 4 5 == 6.00\ntriangle_area 1 2 10 == -1",
        "func_title": "proc triangle_area {a b c}"
    },
    {
        "prompt": "# Write a function that returns true if the object q will fly, and false otherwise. The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n# Example:\n# will_it_fly {1 2} 5  false\n# // 1+2 is less than the maximum possible weight, but it's unbalanced.\n#\n# will_it_fly {3 2 3} 1  false\n# // it's balanced, but 3+2+3 is more than the maximum possible weight.\n#\n# will_it_fly {3 2 3} 9  true\n# // 3+2+3 is less than the maximum possible weight, and it's balanced.\n#\n# will_it_fly {3} 5  true\n# // 3 is less than the maximum possible weight, and it's balanced.\nproc will_it_fly {q w} {\n",
        "canonical_solution": "    set sum 0\n    set length [llength $q]\n    for {set i 0} {$i < $length} {incr i} {\n        if {[lindex $q $i] != [lindex $q [expr {$length - 1 - $i}]]} {\n            return false\n        }\n        set sum [expr {$sum + [lindex $q $i]}]\n    }\n    if {$sum > $w} {\n        return false\n    }\n    return true\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[will_it_fly {3 2 3} 9] == true}\nassert {[will_it_fly {1 2} 5] == false}\nassert {[will_it_fly {3} 5] == true}\nassert {[will_it_fly {3 2 3} 1] == false}\nassert {[will_it_fly {1 2 3} 6] == false}\nassert {[will_it_fly {5} 5] == true}\n",
        "declaration": "proc will_it_fly {q w} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[will_it_fly {3 2 3} 9] == true}\nassert {[will_it_fly {1 2} 5] == false}\nassert {[will_it_fly {3} 5] == true}\nassert {[will_it_fly {3 2 3} 1] == false}\n",
        "prompt_text": "Write a function that returns true if the object q will fly, and false otherwise. The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.",
        "prompt_explain": "Write a function that returns true if the object q will fly, and false otherwise.\nThe object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\nExample:\nwill_it_fly {1 2} 5  false\n// 1+2 is less than the maximum possible weight, but it's unbalanced.\n\nwill_it_fly {3 2 3} 1  false\n// it's balanced, but 3+2+3 is more than the maximum possible weight.\n\nwill_it_fly {3 2 3} 9  true\n// 3+2+3 is less than the maximum possible weight, and it's balanced.\n\nwill_it_fly {3} 5  true\n// 3 is less than the maximum possible weight, and it's balanced.",
        "func_title": "proc will_it_fly {q w}"
    },
    {
        "prompt": "# Given a list arr of integers, find the minimum number of elements that need to be changed to make the list palindromic. A palindromic list is a list that is read the same backwards and forwards. In one change, you can change one element to any other element.\n#\n# For example:\n# smallest_change {1 2 3 5 4 7 9 6} == 4\n# smallest_change {1 2 3 4 3 2 2} == 1\n# smallest_change {1 2 3 2 1} == 0\nproc smallest_change {arr} {\n",
        "canonical_solution": "    set out 0\n    set length [llength $arr]\n    for {set i 0} {$i < $length / 2} {incr i} {\n        if {[lindex $arr $i] != [lindex $arr [expr {$length - 1 - $i}]]} {\n            incr out\n        }\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smallest_change {1 2 3 5 4 7 9 6}] == 4}\nassert {[smallest_change {1 2 3 4 3 2 2}] == 1}\nassert {[smallest_change {1 4 2}] == 1}\nassert {[smallest_change {1 4 4 2}] == 1}\nassert {[smallest_change {1 2 3 2 1}] == 0}\nassert {[smallest_change {3 1 1 3}] == 0}\nassert {[smallest_change {1}] == 0}\nassert {[smallest_change {0 1}] == 1}\n",
        "declaration": "proc smallest_change {arr} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smallest_change {1 2 3 5 4 7 9 6}] == 4}\nassert {[smallest_change {1 2 3 4 3 2 2}] == 1}\nassert {[smallest_change {1 2 3 2 1}] == 0}\nassert {[smallest_change {3 1 1 3}] == 0}\n",
        "prompt_text": "Given a list arr of integers, find the minimum number of elements that need to be changed to make the list palindromic. A palindromic list is a list that is read the same backwards and forwards. In one change, you can change one element to any other element.",
        "prompt_explain": "Given a list arr of integers, find the minimum number of elements that\nneed to be changed to make the list palindromic. A palindromic list is a list that\nis read the same backwards and forwards. In one change, you can change one element to any other element.\n\nFor example:\nsmallest_change {1 2 3 5 4 7 9 6} == 4\nsmallest_change {1 2 3 4 3 2 2} == 1\nsmallest_change {1 2 3 2 1} == 0",
        "func_title": "proc smallest_change {arr}"
    },
    {
        "prompt": "# Write a function that returns true if the given number is the multiplication of 3 prime numbers and false otherwise.\n# Knowing that (a) is less then 100.\n# Example:\n# is_multiply_prime 30 == true\n# 30 = 2 * 3 * 5\nproc is_multiply_prime {a} {\n",
        "canonical_solution": "    set num 0\n    for {set i 2} {$i * $i <= $a} {incr i} {\n        while {$a % $i == 0 && $a > $i} {\n            set a [expr {$a / $i}]\n            incr num\n        }\n    }\n    if {$num == 2} {\n        return true\n    }\n    return false\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_multiply_prime 5] == false}\nassert {[is_multiply_prime 30] == true}\nassert {[is_multiply_prime 8] == true}\nassert {[is_multiply_prime 10] == false}\nassert {[is_multiply_prime 125] == true}\nassert {[is_multiply_prime [expr {3 * 5 * 7}]] == true}\nassert {[is_multiply_prime [expr {3 * 6 * 7}]] == false}\nassert {[is_multiply_prime [expr {9 * 9 * 9}]] == false}\nassert {[is_multiply_prime [expr {11 * 9 * 9}]] == false}\nassert {[is_multiply_prime [expr {11 * 13 * 7}]] == true}\n",
        "declaration": "proc is_multiply_prime {a} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_multiply_prime 30] == true}\n",
        "prompt_text": "Write a function that returns true if the given number is the multiplication of 3 prime numbers and false otherwise. Knowing that (a) is less then 100.",
        "prompt_explain": "Write a function that returns true if the given number is the multiplication of 3 prime numbers\nand false otherwise.\nKnowing that (a) is less then 100.\nExample:\nis_multiply_prime 30 == true\n30 = 2 * 3 * 5",
        "func_title": "proc is_multiply_prime {a}"
    },
    {
        "prompt": "# Your task is to write a function that returns true if a number x is a simple power of n and false in other cases. x is a simple power of n if n**int=x\n# For example:\n# is_simple_power 1 4 => true\n# is_simple_power 2 2 => true\n# is_simple_power 8 2 => true\n# is_simple_power 3 2 => false\n# is_simple_power 3 1 => false\n# is_simple_power 5 3 => false\nproc is_simple_power {x n} {\n",
        "canonical_solution": "    set p 1\n    set count 0\n    while {$p <= $x && $count < 100} {\n        if {$p == $x} {\n            return true\n        }\n        set p [expr {$p * $n}]\n        incr count\n    }\n    return false\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_simple_power 1 4] == true}\nassert {[is_simple_power 2 2] == true}\nassert {[is_simple_power 8 2] == true}\nassert {[is_simple_power 3 2] == false}\nassert {[is_simple_power 3 1] == false}\nassert {[is_simple_power 5 3] == false}\nassert {[is_simple_power 16 2] == true}\nassert {[is_simple_power 143214 16] == false}\nassert {[is_simple_power 4 2] == true}\nassert {[is_simple_power 9 3] == true}\nassert {[is_simple_power 16 4] == true}\nassert {[is_simple_power 24 2] == false}\nassert {[is_simple_power 128 4] == false}\nassert {[is_simple_power 12 6] == false}\nassert {[is_simple_power 1 1] == true}\nassert {[is_simple_power 1 12] == true}\n",
        "declaration": "proc is_simple_power {x n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_simple_power 1 4] == true}\nassert {[is_simple_power 2 2] == true}\nassert {[is_simple_power 8 2] == true}\nassert {[is_simple_power 3 2] == false}\nassert {[is_simple_power 3 1] == false}\nassert {[is_simple_power 5 3] == false}\n",
        "prompt_text": "Your task is to write a function that returns true if a number x is a simple power of n and false in other cases. x is a simple power of n if n**int=x",
        "prompt_explain": "Your task is to write a function that returns true if a number x is a simple\npower of n and false in other cases.\nx is a simple power of n if n**int=x\nFor example:\nis_simple_power 1 4 => true\nis_simple_power 2 2 => true\nis_simple_power 8 2 => true\nis_simple_power 3 2 => false\nis_simple_power 3 1 => false\nis_simple_power 5 3 => false",
        "func_title": "proc is_simple_power {x n}"
    },
    {
        "prompt": "# Write a function that takes an integer a and returns true if this integer is a cube of some integer number.\n# Note: you may assume the input is always valid.\n# Examples:\n# iscube 1 ==> true\n# iscube 2 ==> false\n# iscube -1 ==> true\n# iscube 64 ==> true\n# iscube 0 ==> true\n# iscube 180 ==> false\nproc iscube {a} {\n",
        "canonical_solution": "    set a [expr {abs($a)}]\n    for {set i 0} {[expr {$i * $i * $i}] <= $a} {incr i} {\n        if {[expr {$i * $i * $i}] == $a} {\n            return true\n        }\n    }\n    return false\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[iscube 1] == true}\nassert {[iscube 2] == false}\nassert {[iscube -1] == true}\nassert {[iscube 64] == true}\nassert {[iscube 180] == false}\nassert {[iscube 1000] == true}\nassert {[iscube 0] == true}\nassert {[iscube 1729] == false}\n",
        "declaration": "proc iscube {a} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[iscube 1] == true}\nassert {[iscube 2] == false}\nassert {[iscube -1] == true}\nassert {[iscube 64] == true}\nassert {[iscube 180] == false}\nassert {[iscube 0] == true}\n",
        "prompt_text": "Write a function that takes an integer a and returns true if this integer is a cube of some integer number. Note: you may assume the input is always valid. Examples: iscube 1 ==> true iscube 2 ==> false iscube -1 ==> true iscube 64 ==> true iscube 0 ==> true iscube 180 ==> false",
        "prompt_explain": "Write a function that takes an integer a and returns true if this integer is a cube of some integer number.\nNote: you may assume the input is always valid.\nExamples:\niscube 1 ==> true\niscube 2 ==> false\niscube -1 ==> true\niscube 64 ==> true\niscube 0 ==> true\niscube 180 ==> false",
        "func_title": "proc iscube {a}"
    },
    {
        "prompt": "# You have been tasked to write a function that receives a hexadecimal number as a string and counts the number of hexadecimal digits that are primes (prime number, or a prime, is a natural number greater than 1 that is not a product of two smaller natural numbers). Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Prime numbers are 2, 3, 5, 7, 11, 13, 17,... So you have to determine a number of the following digits: 2, 3, 5, 7, B (=decimal 11), D (=decimal 13). Note: you may assume the input is always correct or empty string, and symbols A,B,C,D,E,F are always uppercase. Examples: For num = \"AB\" the output should be 1. For num = \"1077E\" the output should be 2. For num = \"ABED1A33\" the output should be 4. For num = \"123456789ABCDEF0\" the output should be 6. For num = \"2020\" the output should be 2.\nproc hex_key {num} {\n",
        "canonical_solution": "    set key \"2357BD\"\n    set out 0\n    set length [string length $num]\n    for {set i 0} {$i < $length} {incr i} {\n        set char [string index $num $i]\n        if {[string first $char $key] != -1} {\n            incr out\n        }\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[hex_key \"AB\"] == 1}\nassert {[hex_key \"1077E\"] == 2}\nassert {[hex_key \"ABED1A33\"] == 4}\nassert {[hex_key \"2020\"] == 2}\nassert {[hex_key \"123456789ABCDEF0\"] == 6}\nassert {[hex_key \"112233445566778899AABBCCDDEEFF00\"] == 12}\nassert {[hex_key \"\"] == 0}\n",
        "declaration": "proc hex_key {num} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[hex_key \"AB\"] == 1}\nassert {[hex_key \"1077E\"] == 2}\nassert {[hex_key \"ABED1A33\"] == 4}\nassert {[hex_key \"2020\"] == 2}\nassert {[hex_key \"123456789ABCDEF0\"] == 6}\n",
        "prompt_text": "You have been tasked to write a function that receives a hexadecimal number as a string and counts the number of hexadecimal digits that are primes (prime number, or a prime, is a natural number greater than 1 that is not a product of two smaller natural numbers). Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Prime numbers are 2, 3, 5, 7, 11, 13, 17,... So you have to determine a number of the following digits: 2, 3, 5, 7, B (=decimal 11), D (=decimal 13). Note: you may assume the input is always correct or empty string, and symbols A,B,C,D,E,F are always uppercase. Examples: For num = \"AB\" the output should be 1. For num = \"1077E\" the output should be 2. For num = \"ABED1A33\" the output should be 4. For num = \"123456789ABCDEF0\" the output should be 6. For num = \"2020\" the output should be 2.",
        "prompt_explain": "You have been tasked to write a function that receives a hexadecimal number as a string and counts the number of hexadecimal digits that are primes (prime number, or a prime, is a natural number greater than 1 that is not a product of two smaller natural numbers). Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Prime numbers are 2, 3, 5, 7, 11, 13, 17,... So you have to determine a number of the following digits: 2, 3, 5, 7, B (=decimal 11), D (=decimal 13). Note: you may assume the input is always correct or empty string, and symbols A,B,C,D,E,F are always uppercase. Examples: For num = \"AB\" the output should be 1. For num = \"1077E\" the output should be 2. For num = \"ABED1A33\" the output should be 4. For num = \"123456789ABCDEF0\" the output should be 6. For num = \"2020\" the output should be 2.",
        "func_title": "proc hex_key {num}"
    },
    {
        "prompt": "# You are given a string s.\n# Your task is to check if the string is happy or not.\n# A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n# For example:\n# is_happy \"a\" => false\n# is_happy \"aa\" => false\n# is_happy \"abcd\" => true\n# is_happy \"aabb\" => false\n# is_happy \"adb\" => true\n# is_happy \"xyy\" => false\nproc is_happy {s} {\n",
        "canonical_solution": "    if {[string length $s] < 3} {return false}\n    for {set i 2} {$i < [string length $s]} {incr i} {\n        if {[string index $s $i] == [string index $s [expr {$i - 1}]] || [string index $s $i] == [string index $s [expr {$i - 2}]]} {\n            return false\n        }\n    }\n    return true\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_happy \"a\"] == false}\nassert {[is_happy \"aa\"] == false}\nassert {[is_happy \"abcd\"] == true}\nassert {[is_happy \"aabb\"] == false}\nassert {[is_happy \"adb\"] == true}\nassert {[is_happy \"xyy\"] == false}\nassert {[is_happy \"iopaxpoi\"] == true}\nassert {[is_happy \"iopaxioi\"] == false}\n",
        "declaration": "proc is_happy {s} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_happy \"a\"] == false}\nassert {[is_happy \"aa\"] == false}\nassert {[is_happy \"abcd\"] == true}\nassert {[is_happy \"aabb\"] == false}\nassert {[is_happy \"adb\"] == true}\nassert {[is_happy \"xyy\"] == false}\n",
        "prompt_text": "You are given a string s. Your task is to check if the string is happy or not. A string is happy if its length is at least 3 and every 3 consecutive letters are distinct",
        "prompt_explain": "You are given a string s.\nYour task is to check if the string is happy or not.\nA string is happy if its length is at least 3 and every 3 consecutive letters are distinct\nFor example:\nis_happy \"a\" => false\nis_happy \"aa\" => false\nis_happy \"abcd\" => true\nis_happy \"aabb\" => false\nis_happy \"adb\" => true\nis_happy \"xyy\" => false",
        "func_title": "proc is_happy {s}"
    },
    {
        "prompt": "# Write a function that takes a string and returns true if the string length is a prime number or false otherwise\n# Examples\n# prime_length \"Hello\" == true\n# prime_length \"abcdcba\" == true\n# prime_length \"kittens\" == true\n# prime_length \"orange\" == false\nproc prime_length {str} {\n",
        "canonical_solution": "    set l [string length $str]\n    if {$l < 2} {return false}\n    for {set i 2} {$i * $i <= $l} {incr i} {\n        if {$l % $i == 0} {return false}\n    }\n    return true\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[prime_length \"Hello\"] == true}\nassert {[prime_length \"abcdcba\"] == true}\nassert {[prime_length \"kittens\"] == true}\nassert {[prime_length \"orange\"] == false}\nassert {[prime_length \"wow\"] == true}\nassert {[prime_length \"world\"] == true}\nassert {[prime_length \"MadaM\"] == true}\nassert {[prime_length \"Wow\"] == true}\nassert {[prime_length \"\"] == false}\nassert {[prime_length \"HI\"] == true}\nassert {[prime_length \"go\"] == true}\nassert {[prime_length \"gogo\"] == false}\nassert {[prime_length \"aaaaaaaaaaaaaaa\"] == false}\nassert {[prime_length \"Madam\"] == true}\nassert {[prime_length \"M\"] == false}\nassert {[prime_length \"0\"] == false}\n",
        "declaration": "proc prime_length {str} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[prime_length \"Hello\"] == true}\nassert {[prime_length \"abcdcba\"] == true}\nassert {[prime_length \"kittens\"] == true}\nassert {[prime_length \"orange\"] == false}\n",
        "prompt_text": "Write a function that takes a string and returns true if the string length is a prime number or false otherwise",
        "prompt_explain": "Write a function that takes a string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprime_length \"Hello\" == true\nprime_length \"abcdcba\" == true\nprime_length \"kittens\" == true\nprime_length \"orange\" == false",
        "func_title": "proc prime_length {str}"
    },
    {
        "prompt": "# Given a positive integer n, return the count of the numbers of n-digit positive integers that start or end with 1.\nproc starts_one_ends {n} {\n",
        "canonical_solution": "    if {$n < 1} {return 0}\n    if {$n == 1} {return 1}\n    set out 18\n    for {set i 2} {$i < $n} {incr i} {\n        set out [expr {$out * 10}]\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[starts_one_ends 1] == 1}\nassert {[starts_one_ends 2] == 18}\nassert {[starts_one_ends 3] == 180}\nassert {[starts_one_ends 4] == 1800}\nassert {[starts_one_ends 5] == 18000}\n",
        "declaration": "proc starts_one_ends {n} {\n",
        "example_test": "",
        "prompt_text": "Given a positive integer n, return the count of the numbers of n-digit positive integers that start or end with 1.",
        "prompt_explain": "Given a positive integer n, return the count of the numbers of n-digit positive integers that start or end with 1.",
        "func_title": "proc starts_one_ends {n}"
    },
    {
        "prompt": "# Given a positive integer N, return the total sum of its digits in binary.\n# Example\n# For N = 1000, the sum of digits will be 1 the output should be \"1\".\n# For N = 150, the sum of digits will be 6 the output should be \"110\".\n# For N = 147, the sum of digits will be 12 the output should be \"1100\".\n# Variables:\n# @N integer\n# Constraints: 0  N  10000.\n# Output:\n# a string of binary number\nproc solve {N} {\n",
        "canonical_solution": "    set sum 0\n    foreach digit [split $N {}] {\n        incr sum $digit\n    }\n    set bi \"\"\n    while {$sum > 0} {\n        set bi [expr {$sum % 2}]$bi\n        set sum [expr {$sum / 2}]\n    }\n    return $bi\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[solve 1000] == \"1\"}\nassert {[solve 150] == \"110\"}\nassert {[solve 147] == \"1100\"}\nassert {[solve 333] == \"1001\"}\nassert {[solve 963] == \"10010\"}\n",
        "declaration": "proc solve {N} {\n",
        "example_test": "",
        "prompt_text": "Given a positive integer N, return the total sum of its digits in binary.  Example For N = 1000, the sum of digits will be 1 the output should be \"1\". For N = 150, the sum of digits will be 6 the output should be \"110\". For N = 147, the sum of digits will be 12 the output should be \"1100\".  Variables: @N integer Constraints: 0  N  10000. Output: a string of binary number",
        "prompt_explain": "Given a positive integer N, return the total sum of its digits in binary.\n\nExample\nFor N = 1000, the sum of digits will be 1 the output should be \"1\".\nFor N = 150, the sum of digits will be 6 the output should be \"110\".\nFor N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n@N integer\nConstraints: 0  N  10000.\nOutput:\na string of binary number",
        "func_title": "proc solve {N}"
    },
    {
        "prompt": "# Given a non-empty list of integers lst. add the even elements that are at odd indices..\n#\n# Examples:\n# add {4 2 6 7} ==> 2\nproc add {lst} {\n",
        "canonical_solution": "    set sum 0\n    set length [llength $lst]\n    for {set i 0} {$i < $length} {incr i 2} {\n        set index [expr {$i + 1}]\n        if {$index < $length && [lindex $lst $index] % 2 == 0} {\n            incr sum [lindex $lst $index]\n        }\n    }\n    return $sum\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[add {4 88}] == 88}\nassert {[add {4 5 6 7 2 122}] == 122}\nassert {[add {4 0 6 7}] == 0}\nassert {[add {4 4 6 8}] == 12}\n",
        "declaration": "proc add {lst} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[add {4 2 6 7}] == 2}\n",
        "prompt_text": "Given a non-empty list of integers lst. add the even elements that are at odd indices..",
        "prompt_explain": "Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\nExamples:\nadd {4 2 6 7} ==> 2",
        "func_title": "proc add {lst}"
    },
    {
        "prompt": "# You are given a 2 dimensional data, as a nested lists,\n# which is similar to matrix, however, unlike matrices,\n# each row may contain a different number of columns.\n# Given lst, and integer x, find integers x in the list,\n# and return list of lists, {{x1, y1}, {x2, y2} ...} such that\n# each list is a coordinate - {row, columns}, starting with 0.\n# Sort coordinates initially by rows in ascending order.\n# Also, sort coordinates of the row by columns in descending order.\n#\n# Examples:\n# get_row {\n#   {1 2 3 4 5 6}\n#   {1 2 3 4 1 6}\n#   {1 2 3 4 5 1}\n# } 1 == {{0 0} {1 4} {1 0} {2 5} {2 0}}\n# get_row {} 1 == {}\n# get_row {{} {1} {1 2 3}} 3 == {{2 2}}\nproc get_row {lst x} {\n",
        "canonical_solution": "    set out {}\n    set row_index 0\n    foreach row $lst {\n        set col_index [expr {[llength $row] - 1}]\n        while {$col_index >= 0} {\n            if {[lindex $row $col_index] == $x} {\n                lappend out [list $row_index $col_index]\n            }\n            incr col_index -1\n        }\n        incr row_index\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[llength [lindex $a $i]] != [llength [lindex $b $i]]} {\n            return false\n        }\n        for {set j 0} {$j < [llength [lindex $a $i]]} {incr j} {\n            if {[lindex [lindex $a $i] $j] != [lindex [lindex $b $i] $j]} {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nassert {[issame [get_row {\n    {1 2 3 4 5 6}\n    {1 2 3 4 1 6}\n    {1 2 3 4 5 1}\n} 1] {{0 0} {1 4} {1 0} {2 5} {2 0}}]}\nassert {[issame [get_row {\n    {1 2 3 4 5 6}\n    {1 2 3 4 5 6}\n    {1 2 3 4 5 6}\n    {1 2 3 4 5 6}\n    {1 2 3 4 5 6}\n    {1 2 3 4 5 6}\n} 2] {{0 1} {1 1} {2 1} {3 1} {4 1} {5 1}}]}\nassert {[issame [get_row {\n    {1 2 3 4 5 6}\n    {1 2 3 4 5 6}\n    {1 1 3 4 5 6}\n    {1 2 1 4 5 6}\n    {1 2 3 1 5 6}\n    {1 2 3 4 1 6}\n    {1 2 3 4 5 1}\n} 1] {{0 0} {1 0} {2 1} {2 0} {3 2} {3 0} {4 3} {4 0} {5 4} {5 0} {6 5} {6 0}}]}\nassert {[issame [get_row {} 1] {}]}\nassert {[issame [get_row {{1}} 2] {}]}\nassert {[issame [get_row {{} {1} {1 2 3}} 3] {{2 2}}]}\n",
        "declaration": "proc get_row {lst x} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {\n        return false\n    }\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[llength [lindex $a $i]] != [llength [lindex $b $i]]} {\n            return false\n        }\n        for {set j 0} {$j < [llength [lindex $a $i]]} {incr j} {\n            if {[lindex [lindex $a $i] $j] != [lindex [lindex $b $i] $j]} {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nassert {[issame [get_row {\n    {1 2 3 4 5 6}\n    {1 2 3 4 1 6}\n    {1 2 3 4 5 1}\n} 1] {{0 0} {1 4} {1 0} {2 5} {2 0}}]}\nassert {[issame [get_row {} 1] {}]}\nassert {[issame [get_row {{} {1} {1 2 3}} 3] {{2 2}}]}\n",
        "prompt_text": "You are given a 2 dimensional data, as a nested lists, which is similar to matrix, however, unlike matrices, each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of lists, {{x1, y1}, {x2, y2} ...} such that each list is a coordinate - {row, columns}, starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order. ",
        "prompt_explain": "You are given a 2 dimensional data, as a nested lists,\nwhich is similar to matrix, however, unlike matrices,\neach row may contain a different number of columns.\nGiven lst, and integer x, find integers x in the list,\nand return list of lists, {{x1, y1}, {x2, y2} ...} such that\neach list is a coordinate - {row, columns}, starting with 0.\nSort coordinates initially by rows in ascending order.\nAlso, sort coordinates of the row by columns in descending order.\n\nExamples:\nget_row {\n{1 2 3 4 5 6}\n{1 2 3 4 1 6}\n{1 2 3 4 5 1}\n} 1 == {{0 0} {1 4} {1 0} {2 5} {2 0}}\nget_row {} 1 == {}\nget_row {{} {1} {1 2 3}} 3 == {{2 2}}",
        "func_title": "proc get_row {lst x}"
    },
    {
        "prompt": "# From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\n# >>> rolling_max {1 2 3 2 3 4 2}\n# {1 2 3 3 3 4 4}\nproc rolling_max {numbers} {\n",
        "canonical_solution": "    set out {}\n    set max 0\n    foreach num $numbers {\n        if {$num > $max} {set max $num}\n        lappend out $max\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [rolling_max {}] {}]}\nassert {[issame [rolling_max {1 2 3 4}] {1 2 3 4}]}\nassert {[issame [rolling_max {4 3 2 1}] {4 4 4 4}]}\nassert {[issame [rolling_max {3 2 3 100 3}] {3 3 3 100 100}]}\n",
        "declaration": "proc rolling_max {numbers} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [rolling_max {1 2 3 2 3 4 2}] {1 2 3 3 3 4 4}]}\n",
        "prompt_text": "From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.",
        "prompt_explain": "From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\n>>> rolling_max {1 2 3 2 3 4 2}\n{1 2 3 3 3 4 4}",
        "func_title": "proc rolling_max {numbers}"
    },
    {
        "prompt": "# You'll be given a string of words, and your task is to count the number of boredoms. A boredom is a sentence that starts with the word \"I\". Sentences are delimited by '.', '?' or '!'.\n# For example:\n# >>> is_bored \"Hello world\"\n# 0\n# >>> is_bored \"The sky is blue. The sun is shining. I love this weather\"\n# 1\nproc is_bored {S} {\n",
        "canonical_solution": "    set isstart true\n    set isi false\n    set sum 0\n    for {set i 0} {$i < [string length $S]} {incr i} {\n        set char [string index $S $i]\n        if {$char eq \" \" && $isi} {set isi false; incr sum}\n        if {$char eq \"I\" && $isstart} {set isi true}\n        if {$char ne \"I\"} {set isi false}\n        if {$char ne \" \"} {set isstart false}\n        if {$char eq \".\" || $char eq \"?\" || $char eq \"!\"} {set isstart true}\n    }\n    return $sum\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_bored \"Hello world\"] == 0}\nassert {[is_bored \"Is the sky blue?\"] == 0}\nassert {[is_bored \"I love It !\"] == 1}\nassert {[is_bored \"bIt\"] == 0}\nassert {[is_bored \"I feel good today. I will be productive. will kill It\"] == 2}\nassert {[is_bored \"You and I are going for a walk\"] == 0}\n",
        "declaration": "proc is_bored {S} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_bored \"Hello world\"] == 0}\nassert {[is_bored \"The sky is blue. The sun is shining. I love this weather\"] == 1}\n",
        "prompt_text": "You'll be given a string of words, and your task is to count the number of boredoms. A boredom is a sentence that starts with the word \"I\". Sentences are delimited by '.', '?' or '!'.",
        "prompt_explain": "You'll be given a string of words, and your task is to count the number\nof boredoms. A boredom is a sentence that starts with the word \"I\".\nSentences are delimited by '.', '?' or '!'.\n\nFor example:\n>>> is_bored \"Hello world\"\n0\n>>> is_bored \"The sky is blue. The sun is shining. I love this weather\"\n1",
        "func_title": "proc is_bored {S}"
    },
    {
        "prompt": "# Create a function that takes 3 numbers. Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers. Returns false in any other cases.\n# Examples\n# any_int 5 2 7  true\n# any_int 3 2 2  false\n# any_int 3 -2 1  true\n# any_int 3.6 -2.2 2  false\nproc any_int {a b c} {\n",
        "canonical_solution": "    if {[expr {round($a) != $a}]} {return false}\n    if {[expr {round($b) != $b}]} {return false}\n    if {[expr {round($c) != $c}]} {return false}\n    if {[expr {$a + $b == $c || $a + $c == $b || $b + $c == $a}]} {return true}\n    return false\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[any_int 2 3 1] == true}\nassert {[any_int 2.5 2 3] == false}\nassert {[any_int 1.5 5 3.5] == false}\nassert {[any_int 2 6 2] == false}\nassert {[any_int 4 2 2] == true}\nassert {[any_int 2.2 2.2 2.2] == false}\nassert {[any_int -4 6 2] == true}\nassert {[any_int 2 1 1] == true}\nassert {[any_int 3 4 7] == true}\nassert {[any_int 3.01 4 7] == false}\n",
        "declaration": "proc any_int {a b c} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[any_int 5 2 7] == true}\nassert {[any_int 3 2 2] == false}\nassert {[any_int 3 -2 1] == true}\nassert {[any_int 3.6 -2.2 2] == false}\n",
        "prompt_text": "Create a function that takes 3 numbers. Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers. Returns false in any other cases.",
        "prompt_explain": "Create a function that takes 3 numbers.\nReturns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\nReturns false in any other cases.\n\nExamples\nany_int 5 2 7  true\n\nany_int 3 2 2  false\n\nany_int 3 -2 1  true\n\nany_int 3.6 -2.2 2  false\n\n",
        "func_title": "proc any_int {a b c}"
    },
    {
        "prompt": "# You are given a list of integers.\n# You need to find the largest prime value and return the sum of its digits.\n#\n# Examples:\n# For lst = {0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3} the output should be 10\n# For lst = {1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1} the output should be 25\n# For lst = {1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3} the output should be 13\n# For lst = {0 724 32 71 99 32 6 0 5 91 83 0 5 6} the output should be 11\n# For lst = {0 81 12 3 1 21} the output should be 3\n# For lst = {0 8 1 2 1 7} the output should be 7\nproc skjkasdkd {lst} {\n",
        "canonical_solution": "    set largest 0\n    foreach num $lst {\n        if {$num > $largest} {\n            set prime true\n            for {set j 2} {$j * $j <= $num} {incr j} {\n                if {$num % $j == 0} {\n                    set prime false\n                    break\n                }\n            }\n            if {$prime} {\n                set largest $num\n            }\n        }\n    }\n    set sum 0\n    foreach digit [split $largest {}] {\n        incr sum $digit\n    }\n    return $sum\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[skjkasdkd {0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3}] == 10}\nassert {[skjkasdkd {1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1}] == 25}\nassert {[skjkasdkd {1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3}] == 13}\nassert {[skjkasdkd {0 724 32 71 99 32 6 0 5 91 83 0 5 6}] == 11}\nassert {[skjkasdkd {0 81 12 3 1 21}] == 3}\nassert {[skjkasdkd {0 8 1 2 1 7}] == 7}\nassert {[skjkasdkd {8191}] == 19}\nassert {[skjkasdkd {8191 123456 127 7}] == 19}\nassert {[skjkasdkd {127 97 8192}] == 10}\n",
        "declaration": "proc skjkasdkd {lst} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[skjkasdkd {0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3}] == 10}\nassert {[skjkasdkd {1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1}] == 25}\nassert {[skjkasdkd {1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3}] == 13}\nassert {[skjkasdkd {0 724 32 71 99 32 6 0 5 91 83 0 5 6}] == 11}\nassert {[skjkasdkd {0 81 12 3 1 21}] == 3}\nassert {[skjkasdkd {0 8 1 2 1 7}] == 7}\n",
        "prompt_text": "You are given a list of integers. You need to find the largest prime value and return the sum of its digits. Examples: For lst = {0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3} the output should be 10 For lst = {1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1} the output should be 25 For lst = {1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3} the output should be 13 For lst = {0 724 32 71 99 32 6 0 5 91 83 0 5 6} the output should be 11 For lst = {0 81 12 3 1 21} the output should be 3 For lst = {0 8 1 2 1 7} the output should be 7",
        "prompt_explain": "You are given a list of integers.\nYou need to find the largest prime value and return the sum of its digits.\n\nExamples:\nFor lst = {0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3} the output should be 10\nFor lst = {1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1} the output should be 25\nFor lst = {1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3} the output should be 13\nFor lst = {0 724 32 71 99 32 6 0 5 91 83 0 5 6} the output should be 11\nFor lst = {0 81 12 3 1 21} the output should be 3\nFor lst = {0 8 1 2 1 7} the output should be 7",
        "func_title": "proc skjkasdkd {lst}"
    },
    {
        "prompt": "# Implement a function that takes a non-negative integer and returns a list of the first n integers that are prime numbers and less than n.\n# for example:\n# count_up_to 5 => {2 3}\n# count_up_to 11 => {2 3 5 7}\n# count_up_to 0 => {}\n# count_up_to 20 => {2 3 5 7 11 13 17 19}\n# count_up_to 1 => {}\n# count_up_to 18 => {2 3 5 7 11 13 17}\nproc count_up_to {n} {\n",
        "canonical_solution": "    set out {}\n    for {set i 2} {$i < $n} {incr i} {\n        if {[llength $out] == 0} {\n            lappend out $i\n        } else {\n            set isp true\n            foreach j $out {\n                if {$j * $j > $i} break\n                if {$i % $j == 0} {\n                    set isp false\n                    break\n                }\n            }\n            if {$isp} {lappend out $i}\n        }\n    }\n    return $out\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [count_up_to 5] {2 3}]}\nassert {[issame [count_up_to 6] {2 3 5}]}\nassert {[issame [count_up_to 7] {2 3 5}]}\nassert {[issame [count_up_to 10] {2 3 5 7}]}\nassert {[issame [count_up_to 0] {}]}\nassert {[issame [count_up_to 22] {2 3 5 7 11 13 17 19}]}\nassert {[issame [count_up_to 1] {}]}\nassert {[issame [count_up_to 18] {2 3 5 7 11 13 17}]}\nassert {[issame [count_up_to 47] {2 3 5 7 11 13 17 19 23 29 31 37 41 43}]}\nassert {[issame [count_up_to 101] {2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97}]}\n",
        "declaration": "proc count_up_to {n} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nproc issame {a b} {\n    if {[llength $a] != [llength $b]} {return false}\n    for {set i 0} {$i < [llength $a]} {incr i} {\n        if {[lindex $a $i] != [lindex $b $i]} {return false}\n    }\n    return true\n}\n\nassert {[issame [count_up_to 5] {2 3}]}\nassert {[issame [count_up_to 11] {2 3 5 7}]}\nassert {[issame [count_up_to 0] {}]}\nassert {[issame [count_up_to 20] {2 3 5 7 11 13 17 19}]}\nassert {[issame [count_up_to 1] {}]}\nassert {[issame [count_up_to 18] {2 3 5 7 11 13 17}]}\n",
        "prompt_text": "Implement a function that takes a non-negative integer and returns a list of the first n integers that are prime numbers and less than n.",
        "prompt_explain": "Implement a function that takes a non-negative integer and returns a list of the first n integers that are prime numbers and less than n.\nfor example:\ncount_up_to 5 => {2 3}\ncount_up_to 11 => {2 3 5 7}\ncount_up_to 0 => {}\ncount_up_to 20 => {2 3 5 7 11 13 17 19}\ncount_up_to 1 => {}\ncount_up_to 18 => {2 3 5 7 11 13 17}",
        "func_title": "proc count_up_to {n}"
    },
    {
        "prompt": "# Given a string s, count the number of uppercase vowels in even indices.\n#\n# For example:\n# count_upper \"aBCdEf\" returns 1\n# count_upper \"abcdefg\" returns 0\n# count_upper \"dBBE\" returns 0\nproc count_upper {s} {\n",
        "canonical_solution": "    set uvowel \"AEIOU\"\n    set count 0\n    set length [string length $s]\n    for {set i 0} {$i < $length} {incr i 2} {\n        set char [string index $s $i]\n        if {[string first $char $uvowel] != -1} {\n            incr count\n        }\n    }\n    return $count\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_upper \"aBCdEf\"] == 1}\nassert {[count_upper \"abcdefg\"] == 0}\nassert {[count_upper \"dBBE\"] == 0}\nassert {[count_upper \"B\"] == 0}\nassert {[count_upper \"U\"] == 1}\nassert {[count_upper \"\"] == 0}\nassert {[count_upper \"EEEE\"] == 2}\n",
        "declaration": "proc count_upper {s} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_upper \"aBCdEf\"] == 1}\nassert {[count_upper \"abcdefg\"] == 0}\nassert {[count_upper \"dBBE\"] == 0}\n",
        "prompt_text": "Given a string s, count the number of uppercase vowels in even indices.",
        "prompt_explain": "Given a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper \"aBCdEf\" returns 1\ncount_upper \"abcdefg\" returns 0\ncount_upper \"dBBE\" returns 0",
        "func_title": "proc count_upper {s}"
    },
    {
        "prompt": "# Create a function that takes a value (string) representing a number and returns the closest integer to it. If the number is equidistant from two integers, round it away from zero.\n# Examples\n# >>> closest_integer \"10\"\n# 10\n# >>> closest_integer \"15.3\"\n# 15\n# Note:\n# Rounding away from zero means that if the given number is equidistant from two integers, the one you should return is the one that is the farthest from zero. For example closest_integer \"14.5\" should return 15 and closest_integer \"-14.5\" should return -15.\nproc closest_integer {value} {\n",
        "canonical_solution": "    set w [expr {double($value)}]\n    return [expr {round($w)}]\n}\n",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[closest_integer \"10\"] == 10}\nassert {[closest_integer \"14.5\"] == 15}\nassert {[closest_integer \"-15.5\"] == -16}\nassert {[closest_integer \"15.3\"] == 15}\nassert {[closest_integer \"0\"] == 0}\n",
        "declaration": "proc closest_integer {value} {\n",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[closest_integer \"10\"] == 10}\nassert {[closest_integer \"15.3\"] == 15}\n",
        "prompt_text": "Create a function that takes a value (string) representing a number and returns the closest integer to it. If the number is equidistant from two integers, round it away from zero.",
        "prompt_explain": "Create a function that takes a value (string) representing a number and returns the closest integer to it. If the number is equidistant from two integers, round it away from zero.\nExamples\n>>> closest_integer \"10\"\n10\n>>> closest_integer \"15.3\"\n15\nNote:\nRounding away from zero means that if the given number is equidistant from two integers, the one you should return is the one that is the farthest from zero. For example closest_integer \"14.5\" should return 15 and closest_integer \"-14.5\" should return -15.",
        "func_title": "proc closest_integer {value}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world, this is a test.\"\n# 6\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world, this is a test.\"] == 6}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world, this is a test.\"] == 6}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world, this is a test.\"\n6",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 5 3 9 2}\n# 9\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 5 3 9 2}] == 9}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -5 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 5 3 9 2}\n9",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value.\n# >>> min_value {1 5 3 9 2}\n# 1\nproc min_value {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 5 3 9 2}] == 1}\nassert {[min_value {10 20 30}] == 10}\nassert {[min_value {-1 -5 -3}] == -5}",
        "declaration": "proc min_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 5 3 9 2}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value.",
        "prompt_explain": "Given a list of integers, return the minimum value.\n>>> min_value {1 5 3 9 2}\n1",
        "func_title": "proc min_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World!\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World!\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all elements.\n# >>> product_list {1 2 3 4 5}\n# 120\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {0 1 2}] == 0}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all elements.",
        "prompt_explain": "Given a list of integers, return the product of all elements.\n>>> product_list {1 2 3 4 5}\n120",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a powerful scripting language\"\n# 6\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a powerful scripting language\"\n6",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> max_list {1 2 3 4 5}\n# 5\nproc max_list {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}\nassert {[max_list {10 20 30}] == 30}\nassert {[max_list {0}] == 0}",
        "declaration": "proc max_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> max_list {1 2 3 4 5}\n5",
        "func_title": "proc max_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_list {1 2 3 4 5}\n# 5\nproc max_list {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}\nassert {[max_list {10 20 30}] == 30}\nassert {[max_list {-1 -2 -3}] == -1}",
        "declaration": "proc max_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_list {1 2 3 4 5}\n5",
        "func_title": "proc max_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 20 30}] == 60}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_list {1 2 3 4}\n# 24\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4}] == 24}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {0 1 2 3}] == 0}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_list {1 2 3 4}\n24",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a powerful scripting language\"\n# 6\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a powerful scripting language\"\n6",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all elements.\n# >>> product_list {1 2 3 4 5}\n# 120\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {0 1 2}] == 0}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all elements.",
        "prompt_explain": "Given a list of integers, return the product of all elements.\n>>> product_list {1 2 3 4 5}\n120",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements in the list.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all elements in the list.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> max_list {1 2 3 4 5}\n# 5\nproc max_list {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}\nassert {[max_list {10 20 30}] == 30}\nassert {[max_list {-1 -2 -3}] == -1}",
        "declaration": "proc max_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> max_list {1 2 3 4 5}\n5",
        "func_title": "proc max_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value in the list.\n# >>> min_list {1 2 3 4 5}\n# 1\nproc min_list {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_list {1 2 3 4 5}] == 1}\nassert {[min_list {10 20 30}] == 10}\nassert {[min_list {-1 -2 -3}] == -3}",
        "declaration": "proc min_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_list {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value in the list.",
        "prompt_explain": "Given a list of integers, return the minimum value in the list.\n>>> min_list {1 2 3 4 5}\n1",
        "func_title": "proc min_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"One Two Three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 11 12 13 14}] == 36}\nassert {[sum_even_numbers {1 3 5 7 9}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30 40 50}] == 50}\nassert {[find_max {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_list {1 2 3 4 5}\n# 5\nproc max_list {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}\nassert {[max_list {10 20 30}] == 30}\nassert {[max_list {-1 -2 -3}] == -1}",
        "declaration": "proc max_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_list {1 2 3 4 5}\n5",
        "func_title": "proc max_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value.\n# >>> min_list {1 2 3 4 5}\n# 1\nproc min_list {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_list {1 2 3 4 5}] == 1}\nassert {[min_list {10 20 30}] == 10}\nassert {[min_list {-1 -2 -3}] == -3}",
        "declaration": "proc min_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_list {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value.",
        "prompt_explain": "Given a list of integers, return the minimum value.\n>>> min_list {1 2 3 4 5}\n1",
        "func_title": "proc min_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"hello world\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world\"] == 2}\nassert {[count_words \"one two three four\"] == 4}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"hello world\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_list {1 2 3 4 5}\n# 5\nproc max_list {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}\nassert {[max_list {10 20 30}] == 30}\nassert {[max_list {-1 -2 -3}] == -1}",
        "declaration": "proc max_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_list {1 2 3 4 5}\n5",
        "func_title": "proc max_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all elements.\n# >>> product_list {1 2 3 4 5}\n# 120\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {0 1 2}] == 0}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all elements.",
        "prompt_explain": "Given a list of integers, return the product of all elements.\n>>> product_list {1 2 3 4 5}\n120",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 15 20 25}] == 30}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string. Words are separated by whitespace.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string. Words are separated by whitespace.",
        "prompt_explain": "Given a string, return the number of words in the string. Words are separated by whitespace.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the largest number in the list. Do not use the built-in max command.\n# >>> find_max {3 1 4 1 5 9}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {3 1 4 1 5 9}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {3 1 4 1 5 9}] == 9}",
        "prompt_text": "Given a list of integers, return the largest number in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the largest number in the list. Do not use the built-in max command.\n>>> find_max {3 1 4 1 5 9}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all elements.\n# >>> product_list {1 2 3 4 5}\n# 120\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {0 1 2}] == 0}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all elements.",
        "prompt_explain": "Given a list of integers, return the product of all elements.\n>>> product_list {1 2 3 4 5}\n120",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 20 30}] == 60}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product {1 2 3 4}\n# 24\nproc product {numbers} {",
        "canonical_solution": "    set result 1\n    foreach num $numbers {\n        set result [expr {$result * $num}]\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product {1 2 3 4}] == 24}\nassert {[product {10 20 30}] == 6000}\nassert {[product {5}] == 5}",
        "declaration": "proc product {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product {1 2 3 4}\n24",
        "func_title": "proc product {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value in the list. Do not use the built-in min command.\n# >>> find_min {1 2 3 4 5}\n# 1\nproc find_min {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_min {1 2 3 4 5}] == 1}\nassert {[find_min {10 20 30}] == 10}\nassert {[find_min {-1 -2 -3}] == -3}",
        "declaration": "proc find_min {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_min {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value in the list. Do not use the built-in min command.",
        "prompt_explain": "Given a list of integers, return the minimum value in the list. Do not use the built-in min command.\n>>> find_min {1 2 3 4 5}\n1",
        "func_title": "proc find_min {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a scripting language\"\n# 5\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}\nassert {[count_words \"\"] == 0}\nassert {[count_words \"OneWord\"] == 1}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a scripting language\"\n5",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 3 2 8 5}\n# 8\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 3 2 8 5}] == 8}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 3 2 8 5}] == 8}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 3 2 8 5}\n8",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {-1 -2 -3 -4 -5}] == -15}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World Tcl\"\n# 3\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World Tcl\"] == 3}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World Tcl\"] == 3}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World Tcl\"\n3",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_list {1 2 3 4 5}\n# 5\nproc max_list {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}\nassert {[max_list {10 20 30}] == 30}\nassert {[max_list {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc max_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_list {1 2 3 4 5}\n5",
        "func_title": "proc max_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value.\n# >>> min_list {1 2 3 4 5}\n# 1\nproc min_list {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_list {1 2 3 4 5}] == 1}\nassert {[min_list {10 20 30}] == 10}\nassert {[min_list {-1 -2 -3 -4 -5}] == -5}",
        "declaration": "proc min_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_list {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value.",
        "prompt_explain": "Given a list of integers, return the minimum value.\n>>> min_list {1 2 3 4 5}\n1",
        "func_title": "proc min_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 20 30}] == 60}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product {1 2 3 4 5}\n# 120\nproc product {numbers} {",
        "canonical_solution": "    set prod 1\n    foreach num $numbers {\n        set prod [expr {$prod * $num}]\n    }\n    return $prod\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product {1 2 3 4 5}] == 120}\nassert {[product {10 20 30}] == 6000}\nassert {[product {0 1 2 3}] == 0}",
        "declaration": "proc product {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product {1 2 3 4 5}\n120",
        "func_title": "proc product {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {-1 -2 -3 -4 -5}] == -15}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"hello world\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world\"] == 2}\nassert {[count_words \"tcl programming is fun\"] == 4}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"hello world\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all elements.\n# >>> product_list {1 2 3 4 5}\n# 120\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {-1 -2 -3 -4 -5}] == -120}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all elements.",
        "prompt_explain": "Given a list of integers, return the product of all elements.\n>>> product_list {1 2 3 4 5}\n120",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world, this is Tcl.\"\n# 5\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world, this is Tcl.\"] == 5}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world, this is Tcl.\"] == 5}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world, this is Tcl.\"\n5",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 20 30}] == 60}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World!\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}\nassert {[count_words \"This is a test\"] == 4}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World!\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product {1 2 3 4 5}\n# 120\nproc product {numbers} {",
        "canonical_solution": "    set result 1\n    foreach num $numbers {\n        set result [expr {$result * $num}]\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product {1 2 3 4 5}] == 120}\nassert {[product {10 20 30}] == 6000}\nassert {[product {1 1 1 1 1}] == 1}",
        "declaration": "proc product {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product {1 2 3 4 5}\n120",
        "func_title": "proc product {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> find_max {1 3 2 8 5}\n# 8\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 8 5}] == 8}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 3 2 8 5}] == 8}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> find_max {1 3 2 8 5}\n8",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the average value.\n# >>> average {1 2 3 4 5}\n# 3.0\nproc average {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return [expr {double($sum) / [llength $numbers]}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average {1 2 3 4 5}] == 3.0}\nassert {[average {10 20 30}] == 20.0}\nassert {[average {0}] == 0.0}",
        "declaration": "proc average {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average {1 2 3 4 5}] == 3.0}",
        "prompt_text": "Given a list of integers, return the average value.",
        "prompt_explain": "Given a list of integers, return the average value.\n>>> average {1 2 3 4 5}\n3.0",
        "func_title": "proc average {numbers}"
    },
    {
        "prompt": "# Given a list of numbers, return the sum of all numbers.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        set sum [expr {$sum + $num}]\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of numbers, return the sum of all numbers.",
        "prompt_explain": "Given a list of numbers, return the sum of all numbers.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a scripting language\"\n# 5\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}\nassert {[count_words \"OneWord\"] == 1}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a scripting language\"\n5",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a string, return true if the string is a palindrome, otherwise return false.\n# >>> is_palindrome \"racecar\"\n# 1\nproc is_palindrome {str} {",
        "canonical_solution": "    return [expr {$str eq [string reverse $str]}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_palindrome \"racecar\"] == 1}\nassert {[is_palindrome \"hello\"] == 0}\nassert {[is_palindrome \"\"] == 1}",
        "declaration": "proc is_palindrome {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_palindrome \"racecar\"] == 1}",
        "prompt_text": "Given a string, return true if the string is a palindrome, otherwise return false.",
        "prompt_explain": "Given a string, return true if the string is a palindrome, otherwise return false.\n>>> is_palindrome \"racecar\"\n1",
        "func_title": "proc is_palindrome {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {1 3 5 7}] == 0}\nassert {[sum_even_numbers {2 4 6 8 10}] == 30}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World!\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}\nassert {[count_words \"This is a test\"] == 4}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World!\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4 5}\n# 120\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4 5}] == 120}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {}] == 1}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4 5}\n120",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even {1 2 3 4 5 6}\n# 12\nproc sum_even {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}\nassert {[sum_even {10 15 20 25}] == 30}\nassert {[sum_even {1 3 5 7}] == 0}",
        "declaration": "proc sum_even {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string. Words are separated by spaces.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string. Words are separated by spaces.",
        "prompt_explain": "Given a string, return the number of words in the string. Words are separated by spaces.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {1 5 3 9 2}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -5 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {1 5 3 9 2}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a powerful scripting language\"\n# 6\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}\nassert {[count_words \"\"] == 0}\nassert {[count_words \"OneWord\"] == 1}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a powerful scripting language\"\n6",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {}] == 1}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value without using the built-in max command.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value without using the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value without using the built-in max command.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"hello world\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world\"] == 2}\nassert {[count_words \"tcl programming is fun\"] == 4}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"hello world\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {5}] == 5}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of numbers, return the sum of all numbers.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        set sum [expr {$sum + $num}]\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of numbers, return the sum of all numbers.",
        "prompt_explain": "Given a list of numbers, return the sum of all numbers.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {3 1 4 1 5 9}\n# 9\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {3 1 4 1 5 9}] == 9}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {3 1 4 1 5 9}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {3 1 4 1 5 9}\n9",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value.\n# >>> min_value {3 1 4 1 5 9}\n# 1\nproc min_value {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {3 1 4 1 5 9}] == 1}\nassert {[min_value {10 20 30}] == 10}\nassert {[min_value {-1 -2 -3}] == -3}",
        "declaration": "proc min_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {3 1 4 1 5 9}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value.",
        "prompt_explain": "Given a list of integers, return the minimum value.\n>>> min_value {3 1 4 1 5 9}\n1",
        "func_title": "proc min_value {numbers}"
    },
    {
        "prompt": "# Given a list of numbers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of numbers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of numbers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a powerful scripting language\"\n# 6\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}\nassert {[count_words \"\"] == 0}\nassert {[count_words \"OneWord\"] == 1}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a powerful scripting language\"\n6",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {3 1 4 1 5 9}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {3 1 4 1 5 9}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {3 1 4 1 5 9}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {3 1 4 1 5 9}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One\"] == 1}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the average value.\n# >>> average {1 2 3 4 5}\n# 3\nproc average {numbers} {",
        "canonical_solution": "    set sum 0\n    set count [llength $numbers]\n    foreach num $numbers {\n        incr sum $num\n    }\n    return [expr {$sum / $count}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average {1 2 3 4 5}] == 3}\nassert {[average {10 20 30}] == 20}\nassert {[average {0}] == 0}",
        "declaration": "proc average {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average {1 2 3 4 5}] == 3}",
        "prompt_text": "Given a list of integers, return the average value.",
        "prompt_explain": "Given a list of integers, return the average value.\n>>> average {1 2 3 4 5}\n3",
        "func_title": "proc average {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> max_list {1 2 3 4 5}\n# 5\nproc max_list {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}\nassert {[max_list {10 20 30}] == 30}\nassert {[max_list {-1 -2 -3}] == -1}",
        "declaration": "proc max_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> max_list {1 2 3 4 5}\n5",
        "func_title": "proc max_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world, this is Tcl.\"\n# 5\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world, this is Tcl.\"] == 5}\nassert {[count_words \"One two three\"] == 3}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world, this is Tcl.\"] == 5}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world, this is Tcl.\"\n5",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all elements.\n# >>> product_list {1 2 3 4}\n# 24\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4}] == 24}\nassert {[product_list {5 2 3}] == 30}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all elements.",
        "prompt_explain": "Given a list of integers, return the product of all elements.\n>>> product_list {1 2 3 4}\n24",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"hello world\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"hello world\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the average value.\n# >>> average_value {1 2 3 4 5}\n# 3.0\nproc average_value {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return [expr {$sum / double([llength $numbers])}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average_value {1 2 3 4 5}] == 3.0}\nassert {[average_value {10 20 30}] == 20.0}\nassert {[average_value {0 0 0}] == 0.0}",
        "declaration": "proc average_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average_value {1 2 3 4 5}] == 3.0}",
        "prompt_text": "Given a list of integers, return the average value.",
        "prompt_explain": "Given a list of integers, return the average value.\n>>> average_value {1 2 3 4 5}\n3.0",
        "func_title": "proc average_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string. Words are separated by whitespace.\n# >>> count_words \"Tcl is a scripting language\"\n# 5\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}\nassert {[count_words \"Hello World!\"] == 2}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}",
        "prompt_text": "Given a string, return the number of words in the string. Words are separated by whitespace.",
        "prompt_explain": "Given a string, return the number of words in the string. Words are separated by whitespace.\n>>> count_words \"Tcl is a scripting language\"\n5",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value.\n# >>> min_value {1 2 3 4 5}\n# 1\nproc min_value {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}\nassert {[min_value {10 20 30}] == 10}\nassert {[min_value {-1 -2 -3}] == -3}",
        "declaration": "proc min_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value.",
        "prompt_explain": "Given a list of integers, return the minimum value.\n>>> min_value {1 2 3 4 5}\n1",
        "func_title": "proc min_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 15 20 25}] == 30}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30 40 50}] == 50}\nassert {[find_max {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a powerful scripting language\"\n# 6\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a powerful scripting language\"\n6",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 11 12 13 14}] == 36}\nassert {[sum_even_numbers {1 3 5 7 9}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30 40 50}] == 50}\nassert {[find_max {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4 5}\n# 120\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4 5}] == 120}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4 5}\n120",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World!\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}\nassert {[count_words \"Tcl is a scripting language\"] == 5}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World!\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World!\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_list {1 2 3 4 5}\n# 5\nproc max_list {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}\nassert {[max_list {10 20 30}] == 30}\nassert {[max_list {0 -1 -2}] == 0}",
        "declaration": "proc max_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_list {1 2 3 4 5}\n5",
        "func_title": "proc max_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"OneWord\"] == 1}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_list {1 2 3 4 5}\n# 5\nproc max_list {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}\nassert {[max_list {10 20 30}] == 30}\nassert {[max_list {-1 -2 -3}] == -1}",
        "declaration": "proc max_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_list {1 2 3 4 5}\n5",
        "func_title": "proc max_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list without using the built-in max command.\n# >>> find_max {1 5 3 9 2}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list without using the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list without using the built-in max command.\n>>> find_max {1 5 3 9 2}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {5 10 2}] == 100}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"hello world\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world\"] == 2}\nassert {[count_words \"tcl programming is fun\"] == 4}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"hello world\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"hello world\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a powerful scripting language\"\n# 6\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a powerful scripting language\"\n6",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {0 -1 -2}] == 0}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value.\n# >>> min_value {1 2 3 4 5}\n# 1\nproc min_value {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}\nassert {[min_value {10 20 30}] == 10}\nassert {[min_value {0 -1 -2}] == -2}",
        "declaration": "proc min_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value.",
        "prompt_explain": "Given a list of integers, return the minimum value.\n>>> min_value {1 2 3 4 5}\n1",
        "func_title": "proc min_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a scripting language\"\n# 5\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}\nassert {[count_words \"One two three\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a scripting language\"\n5",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {0 -1 -2}] == 0}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value.\n# >>> min_value {1 2 3 4 5}\n# 1\nproc min_value {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}\nassert {[min_value {10 20 30}] == 10}\nassert {[min_value {0 -1 -2}] == -2}",
        "declaration": "proc min_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_value {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value.",
        "prompt_explain": "Given a list of integers, return the minimum value.\n>>> min_value {1 2 3 4 5}\n1",
        "func_title": "proc min_value {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of times a specified character appears in the string.\n# >>> count_char \"hello world\" \"l\"\n# 3\nproc count_char {str char} {",
        "canonical_solution": "    set count 0\n    foreach chr [split $str \"\"] {\n        if {$chr eq $char} {\n            incr count\n        }\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_char \"hello world\" \"l\"] == 3}\nassert {[count_char \"hello world\" \"o\"] == 2}\nassert {[count_char \"hello world\" \"z\"] == 0}",
        "declaration": "proc count_char {str char} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_char \"hello world\" \"l\"] == 3}",
        "prompt_text": "Given a string, return the number of times a specified character appears in the string.",
        "prompt_explain": "Given a string, return the number of times a specified character appears in the string.\n>>> count_char \"hello world\" \"l\"\n3",
        "func_title": "proc count_char {str char}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 20 30}] == 60}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_list {1 2 3 4}\n# 24\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4}] == 24}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {0 1 2 3}] == 0}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_list {1 2 3 4}\n24",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum number in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum number in the list.",
        "prompt_explain": "Given a list of integers, return the maximum number in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 20 30}] == 60}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list. Do not use the built-in max command.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World\"\n# 2\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"Tcl is fun\"] == 3}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World\"] == 2}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World\"\n2",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_list {1 2 3 4}\n# 24\nproc product_of_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_list {1 2 3 4}] == 24}\nassert {[product_of_list {10 20 30}] == 6000}\nassert {[product_of_list {0 1 2 3}] == 0}",
        "declaration": "proc product_of_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_list {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_list {1 2 3 4}\n24",
        "func_title": "proc product_of_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 5 3 9 2}\n# 9\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 5 3 9 2}] == 9}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 5 3 9 2}\n9",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a powerful scripting language\"\n# 6\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}\nassert {[count_words \"\"] == 0}\nassert {[count_words \"OneWord\"] == 1}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a powerful scripting language\"] == 6}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a powerful scripting language\"\n6",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return true if the string is a palindrome, otherwise return false.\n# >>> is_palindrome \"racecar\"\n# true\nproc is_palindrome {str} {",
        "canonical_solution": "    return [expr {$str eq [string reverse $str]}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_palindrome \"racecar\"] == 1}\nassert {[is_palindrome \"hello\"] == 0}\nassert {[is_palindrome \"\"] == 1}",
        "declaration": "proc is_palindrome {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_palindrome \"racecar\"] == 1}",
        "prompt_text": "Given a string, return true if the string is a palindrome, otherwise return false.",
        "prompt_explain": "Given a string, return true if the string is a palindrome, otherwise return false.\n>>> is_palindrome \"racecar\"\ntrue",
        "func_title": "proc is_palindrome {str}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 20 30}] == 60}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3 -4 -5}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_list {1 2 3 4 5}\n# 120\nproc product_list {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}\nassert {[product_list {10 20 30}] == 6000}\nassert {[product_list {1 3 5 7}] == 105}",
        "declaration": "proc product_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_list {1 2 3 4 5}] == 120}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_list {1 2 3 4 5}\n120",
        "func_title": "proc product_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the minimum value in the list.\n# >>> find_min {1 2 3 4 5}\n# 1\nproc find_min {numbers} {",
        "canonical_solution": "    set min [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num < $min} {\n            set min $num\n        }\n    }\n    return $min\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_min {1 2 3 4 5}] == 1}\nassert {[find_min {10 20 30}] == 10}\nassert {[find_min {-1 -2 -3 -4 -5}] == -5}",
        "declaration": "proc find_min {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_min {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, return the minimum value in the list.",
        "prompt_explain": "Given a list of integers, return the minimum value in the list.\n>>> find_min {1 2 3 4 5}\n1",
        "func_title": "proc find_min {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string. Words are separated by spaces.\n# >>> count_words \"Hello world from Tcl\"\n# 4\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}\nassert {[count_words \"One\"] == 1}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello world from Tcl\"] == 4}",
        "prompt_text": "Given a string, return the number of words in the string. Words are separated by spaces.",
        "prompt_explain": "Given a string, return the number of words in the string. Words are separated by spaces.\n>>> count_words \"Hello world from Tcl\"\n4",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> max_list {1 2 3 4 5}\n# 5\nproc max_list {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}\nassert {[max_list {10 20 30}] == 30}\nassert {[max_list {-1 -2 -3}] == -1}",
        "declaration": "proc max_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_list {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> max_list {1 2 3 4 5}\n5",
        "func_title": "proc max_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the average value of the list.\n# >>> average_list {1 2 3 4 5}\n# 3\nproc average_list {numbers} {",
        "canonical_solution": "    set sum 0\n    set count [llength $numbers]\n    foreach num $numbers {\n        incr sum $num\n    }\n    return [expr {$sum / double($count)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average_list {1 2 3 4 5}] == 3}\nassert {[average_list {10 20 30}] == 20}\nassert {[average_list {}] == 0}",
        "declaration": "proc average_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average_list {1 2 3 4 5}] == 3}",
        "prompt_text": "Given a list of integers, return the average value of the list.",
        "prompt_explain": "Given a list of integers, return the average value of the list.\n>>> average_list {1 2 3 4 5}\n3",
        "func_title": "proc average_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_evens {1 2 3 4 5 6}\n# 12\nproc sum_evens {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}\nassert {[sum_evens {10 20 30}] == 60}\nassert {[sum_evens {1 3 5 7}] == 0}",
        "declaration": "proc sum_evens {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_evens {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_evens {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_evens {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product {1 2 3 4}\n# 24\nproc product {numbers} {",
        "canonical_solution": "    set prod 1\n    foreach num $numbers {\n        set prod [expr {$prod * $num}]\n    }\n    return $prod\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product {1 2 3 4}] == 24}\nassert {[product {10 20 30}] == 6000}\nassert {[product {5}] == 5}",
        "declaration": "proc product {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product {1 2 3 4}\n24",
        "func_title": "proc product {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World Tcl\"\n# 3\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World Tcl\"] == 3}\nassert {[count_words \"One\"] == 1}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World Tcl\"] == 3}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World Tcl\"\n3",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements.\n# >>> sum_list {1 2 3 4 5}\n# 15\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        incr sum $num\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}\nassert {[sum_list {10 20 30}] == 60}\nassert {[sum_list {0 0 0}] == 0}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3 4 5}] == 15}",
        "prompt_text": "Given a list of integers, return the sum of all elements.",
        "prompt_explain": "Given a list of integers, return the sum of all elements.\n>>> sum_list {1 2 3 4 5}\n15",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Hello World Tcl\"\n# 3\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World Tcl\"] == 3}\nassert {[count_words \"One two three four\"] == 4}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Hello World Tcl\"] == 3}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Hello World Tcl\"\n3",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value.\n# >>> max_value {1 2 3 4 5}\n# 5\nproc max_value {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}\nassert {[max_value {10 20 30}] == 30}\nassert {[max_value {-1 -2 -3}] == -1}",
        "declaration": "proc max_value {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_value {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value.",
        "prompt_explain": "Given a list of integers, return the maximum value.\n>>> max_value {1 2 3 4 5}\n5",
        "func_title": "proc max_value {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all even numbers in the list.\n# >>> sum_even_numbers {1 2 3 4 5 6}\n# 12\nproc sum_even_numbers {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        if {$num % 2 == 0} {\n            incr sum $num\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}\nassert {[sum_even_numbers {10 20 30}] == 60}\nassert {[sum_even_numbers {1 3 5 7}] == 0}",
        "declaration": "proc sum_even_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_even_numbers {1 2 3 4 5 6}] == 12}",
        "prompt_text": "Given a list of integers, return the sum of all even numbers in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all even numbers in the list.\n>>> sum_even_numbers {1 2 3 4 5 6}\n12",
        "func_title": "proc sum_even_numbers {numbers}"
    },
    {
        "prompt": "# Given a string, return the number of words in the string.\n# >>> count_words \"Tcl is a scripting language\"\n# 5\nproc count_words {str} {",
        "canonical_solution": "    return [llength [split $str \" \"]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}\nassert {[count_words \"Hello World\"] == 2}\nassert {[count_words \"\"] == 0}",
        "declaration": "proc count_words {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_words \"Tcl is a scripting language\"] == 5}",
        "prompt_text": "Given a string, return the number of words in the string.",
        "prompt_explain": "Given a string, return the number of words in the string.\n>>> count_words \"Tcl is a scripting language\"\n5",
        "func_title": "proc count_words {str}"
    },
    {
        "prompt": "# Given a list of integers, return the maximum value in the list.\n# >>> find_max {1 2 3 4 5}\n# 5\nproc find_max {numbers} {",
        "canonical_solution": "    set max [lindex $numbers 0]\n    foreach num $numbers {\n        if {$num > $max} {\n            set max $num\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}\nassert {[find_max {10 20 30}] == 30}\nassert {[find_max {-1 -2 -3}] == -1}",
        "declaration": "proc find_max {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {1 2 3 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the maximum value in the list.",
        "prompt_explain": "Given a list of integers, return the maximum value in the list.\n>>> find_max {1 2 3 4 5}\n5",
        "func_title": "proc find_max {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all numbers in the list.\n# >>> product_of_numbers {1 2 3 4}\n# 24\nproc product_of_numbers {numbers} {",
        "canonical_solution": "    set product 1\n    foreach num $numbers {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}\nassert {[product_of_numbers {10 20 30}] == 6000}\nassert {[product_of_numbers {0 1 2 3}] == 0}",
        "declaration": "proc product_of_numbers {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[product_of_numbers {1 2 3 4}] == 24}",
        "prompt_text": "Given a list of integers, return the product of all numbers in the list.",
        "prompt_explain": "Given a list of integers, return the product of all numbers in the list.\n>>> product_of_numbers {1 2 3 4}\n24",
        "func_title": "proc product_of_numbers {numbers}"
    },
    {
        "prompt": "# Given a cost matrix and a position (m, n), find the minimum cost path to reach (m, n) from (0, 0).\n# >>> min_cost {{1 2 3} {4 8 2} {1 5 3}} 2 2\n# 8\nproc min_cost {cost m n} {",
        "canonical_solution": "    set R [llength $cost]\n    set C [llength [lindex $cost 0]]\n    set tc [lrepeat $R [lrepeat $C 0]]\n    lset tc 0 0 [lindex $cost 0 0]\n    for {set i 1} {$i <= $m} {incr i} {\n        lset tc $i 0 [expr {[lindex $tc [expr {$i - 1}] 0] + [lindex $cost $i 0]}]\n    }\n    for {set j 1} {$j <= $n} {incr j} {\n        lset tc 0 $j [expr {[lindex $tc 0 [expr {$j - 1}]] + [lindex $cost 0 $j]}]\n    }\n    for {set i 1} {$i <= $m} {incr i} {\n        for {set j 1} {$j <= $n} {incr j} {\n            set min_val [expr {min([lindex $tc [expr {$i - 1}] [expr {$j - 1}]], [lindex $tc [expr {$i - 1}] $j], [lindex $tc $i [expr {$j - 1}]])}]\n            lset tc $i $j [expr {$min_val + [lindex $cost $i $j]}]\n        }\n    }\n    return [lindex $tc $m $n]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_cost {{1 2 3} {4 8 2} {1 5 3}} 2 2] == 8}\nassert {[min_cost {{2 3 4} {5 9 3} {2 6 4}} 2 2] == 12}\nassert {[min_cost {{3 4 5} {6 10 4} {3 7 5}} 2 2] == 16}",
        "declaration": "proc min_cost {cost m n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_cost {{1 2 3} {4 8 2} {1 5 3}} 2 2] == 8}",
        "prompt_text": "Given a cost matrix and a position (m, n), find the minimum cost path to reach (m, n) from (0, 0).",
        "prompt_explain": "Given a cost matrix and a position (m, n), find the minimum cost path to reach (m, n) from (0, 0).\n>>> min_cost {{1 2 3} {4 8 2} {1 5 3}} 2 2\n8",
        "func_title": "proc min_cost {cost m n}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the two numbers differ at one bit position only or not.\n# >>> differ_At_One_Bit_Pos 13 9\n# 1\nproc differ_At_One_Bit_Pos {a b} {",
        "canonical_solution": "    set xor_result [expr {$a ^ $b}]\n    if {$xor_result == 0} {\n        return 0\n    }\n    while {[expr {$xor_result % 2}] == 0} {\n        set xor_result [expr {$xor_result / 2}]\n    }\n    if {[expr {$xor_result == 1}]} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[differ_At_One_Bit_Pos 13 9] == 1}\nassert {[differ_At_One_Bit_Pos 15 8] == 0}\nassert {[differ_At_One_Bit_Pos 2 4] == 0}",
        "declaration": "proc differ_At_One_Bit_Pos {a b} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[differ_At_One_Bit_Pos 13 9] == 1}",
        "prompt_text": "Write a Tcl function to check whether the two numbers differ at one bit position only or not.",
        "prompt_explain": "Write a Tcl function to check whether the two numbers differ at one bit position only or not.\n>>> differ_At_One_Bit_Pos 13 9\n1",
        "func_title": "proc differ_At_One_Bit_Pos {a b}"
    },
    {
        "prompt": "# Write a function to find the perimeter of a square.\n# >>> square_perimeter 10\n# 40\nproc square_perimeter {a} {",
        "canonical_solution": "    set perimeter [expr {4 * $a}]\n    return $perimeter\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[square_perimeter 10] == 40}\nassert {[square_perimeter 5] == 20}\nassert {[square_perimeter 4] == 16}",
        "declaration": "proc square_perimeter {a} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[square_perimeter 10] == 40}",
        "prompt_text": "Write a function to find the perimeter of a square.",
        "prompt_explain": "Write a function to find the perimeter of a square.\n>>> square_perimeter 10\n40",
        "func_title": "proc square_perimeter {a}"
    },
    {
        "prompt": "# Write a function to check if the given number is woodball or not.\n# >>> is_woodall 383\n# 1\n# >>> is_woodall 254\n# 0\nproc is_woodall {x} {",
        "canonical_solution": "    if {$x % 2 == 0} {\n        return 0\n    }\n    if {$x == 1} {\n        return 1\n    }\n    set x [expr {$x + 1}]\n    set p 0\n    while {$x % 2 == 0} {\n        set x [expr {$x / 2}]\n        incr p\n        if {$p == $x} {\n            return 1\n        }\n    }\n    return 0\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_woodall 383] == 1}\nassert {[is_woodall 254] == 0}\nassert {[is_woodall 200] == 0}",
        "declaration": "proc is_woodall {x} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_woodall 383] == 1}",
        "prompt_text": "Write a function to check if the given number is woodball or not.",
        "prompt_explain": "Write a function to check if the given number is woodball or not.\n>>> is_woodall 383\n1\n>>> is_woodall 254\n0",
        "func_title": "proc is_woodall {x}",
        "challenge_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_woodall 32212254719] == 1}\nassert {[is_woodall 32212254718] == 0}\nassert {[is_woodall 159] == 1}"
    },
    {
        "prompt": "# Given a list of lists, find the maximum sum of elements of any list.\n# >>> maximum_Sum {{1 2 3} {4 5 6} {10 11 12} {7 8 9}}\n# 33\nproc maximum_Sum {list1} {",
        "canonical_solution": "    set maxi -100000\n    foreach x $list1 {\n        set sum 0\n        foreach y $x {\n            incr sum $y\n        }\n        if {$sum > $maxi} {\n            set maxi $sum\n        }\n    }\n    return $maxi\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[maximum_Sum {{1 2 3} {4 5 6} {10 11 12} {7 8 9}}] == 33}\nassert {[maximum_Sum {{0 1 1} {1 1 2} {3 2 1}}] == 6}\nassert {[maximum_Sum {{0 1 3} {1 2 1} {9 8 2} {0 1 0} {6 4 8}}] == 19}",
        "declaration": "proc maximum_Sum {list1} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[maximum_Sum {{1 2 3} {4 5 6} {10 11 12} {7 8 9}}] == 33}",
        "prompt_text": "Given a list of lists, find the maximum sum of elements of any list.",
        "prompt_explain": "Given a list of lists, find the maximum sum of elements of any list.\n>>> maximum_Sum {{1 2 3} {4 5 6} {10 11 12} {7 8 9}}\n33",
        "func_title": "proc maximum_Sum {list1}",
        "challenge_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[maximum_Sum {{0 -1 -1} {-1 -1 -2} {-3 -2 -1}}] == -2}"
    },
    {
        "prompt": "# Given a list of integers, find the product of non-repeated elements in the list.\n# >>> find_Product {1 1 2 3}\n# 6\nproc find_Product {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set arr [lsort -integer $arr]\n    set prod 1\n    for {set i 0} {$i < $n} {incr i} {\n        if {$i == 0 || [lindex $arr [expr {$i - 1}]] != [lindex $arr $i]} {\n            set prod [expr {$prod * [lindex $arr $i]}]\n        }\n    }\n    return $prod\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Product {1 1 2 3}] == 6}\nassert {[find_Product {1 2 3 1 1}] == 6}\nassert {[find_Product {1 1 4 5 6}] == 120}",
        "declaration": "proc find_Product {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Product {1 1 2 3}] == 6}",
        "prompt_text": "Given a list of integers, find the product of non-repeated elements in the list.",
        "prompt_explain": "Given a list of integers, find the product of non-repeated elements in the list.\n>>> find_Product {1 1 2 3}\n6",
        "func_title": "proc find_Product {arr}"
    },
    {
        "prompt": "# Given a list of integers, find the element that occurs an odd number of times.\n# >>> get_Odd_Occurrence {1 2 3 1 2 3 1}\n# 1\nproc get_Odd_Occurrence {arr} {",
        "canonical_solution": "    set arr_size [llength $arr]\n    for {set i 0} {$i < $arr_size} {incr i} {\n        set count 0\n        for {set j 0} {$j < $arr_size} {incr j} {\n            if {[lindex $arr $i] == [lindex $arr $j]} {\n                incr count\n            }\n        }\n        if {$count % 2 != 0} {\n            return [lindex $arr $i]\n        }\n    }\n    return -1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Odd_Occurrence {1 2 3 1 2 3 1}] == 1}\nassert {[get_Odd_Occurrence {1 2 3 2 3 1 3}] == 3}\nassert {[get_Odd_Occurrence {2 3 5 4 5 2 4 3 5 2 4 4 2}] == 5}",
        "declaration": "proc get_Odd_Occurrence {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Odd_Occurrence {1 2 3 1 2 3 1}] == 1}",
        "prompt_text": "Given a list of integers, find the element that occurs an odd number of times.",
        "prompt_explain": "Given a list of integers, find the element that occurs an odd number of times.\n>>> get_Odd_Occurrence {1 2 3 1 2 3 1}\n1",
        "func_title": "proc get_Odd_Occurrence {arr}"
    },
    {
        "prompt": "# Given a string, count all the substrings starting and ending with same characters.\n# >>> count_Substring_With_Equal_Ends \"abc\"\n# 3\nproc count_Substring_With_Equal_Ends {s} {",
        "canonical_solution": "    set result 0\n    set n [string length $s]\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j 1} {$j <= [expr {$n - $i}]} {incr j} {\n            set substring [string range $s $i [expr {$i + $j - 1}]]\n            if {[string index $substring 0] eq [string index $substring end]} {\n                incr result\n            }\n        }\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Substring_With_Equal_Ends \"abc\"] == 3}\nassert {[count_Substring_With_Equal_Ends \"abcda\"] == 6}\nassert {[count_Substring_With_Equal_Ends \"ab\"] == 2}",
        "declaration": "proc count_Substring_With_Equal_Ends {s} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Substring_With_Equal_Ends \"abc\"] == 3}",
        "prompt_text": "Given a string, count all the substrings starting and ending with same characters.",
        "prompt_explain": "Given a string, count all the substrings starting and ending with same characters.\n>>> count_Substring_With_Equal_Ends \"abc\"\n3",
        "func_title": "proc count_Substring_With_Equal_Ends {s}"
    },
    {
        "prompt": "# Write a Tcl function to convert a decimal number to a binary number.\n# >>> decimal_To_Binary 10\n# 1010\nproc decimal_To_Binary {N} {",
        "canonical_solution": "    set B_Number 0\n    set cnt 0\n    while {$N != 0} {\n        set rem [expr {$N % 2}]\n        set c [expr {pow(10, $cnt)}]\n        set B_Number [expr {$B_Number + $rem * $c}]\n        set N [expr {$N / 2}]\n        incr cnt\n    }\n    return $B_Number\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[decimal_To_Binary 10] == 1010}\nassert {[decimal_To_Binary 1] == 1}\nassert {[decimal_To_Binary 20] == 10100}",
        "declaration": "proc decimal_To_Binary {N} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[decimal_To_Binary 10] == 1010}",
        "prompt_text": "Write a Tcl function to convert a decimal number to a binary number.",
        "prompt_explain": "Write a Tcl function to convert a decimal number to a binary number.\n>>> decimal_To_Binary 10\n1010",
        "func_title": "proc decimal_To_Binary {N}"
    },
    {
        "prompt": "# Given a sorted array of integers with one missing number, find the missing number.\n# >>> find_missing {1 2 3 5} 4\n# 4\nproc find_missing {ar N} {",
        "canonical_solution": "    set l 0\n    set r [expr {$N - 1}]\n    while {$l <= $r} {\n        set mid [expr {($l + $r) / 2}]\n        set mid [expr {int($mid)}]\n        if {[lindex $ar $mid] != [expr {$mid + 1}] && [lindex $ar [expr {$mid - 1}]] == $mid} {\n            return [expr {$mid + 1}]\n        } elseif {[lindex $ar $mid] != [expr {$mid + 1}]} {\n            set r [expr {$mid - 1}]\n        } else {\n            set l [expr {$mid + 1}]\n        }\n    }\n    return -1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_missing {1 2 3 5} 4] == 4}\nassert {[find_missing {1 3 4 5} 4] == 2}\nassert {[find_missing {1 2 3 5 6 7} 5] == 4}",
        "declaration": "proc find_missing {ar N} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_missing {1 2 3 5} 4] == 4}",
        "prompt_text": "Given a sorted array of integers with one missing number, find the missing number.",
        "prompt_explain": "Given a sorted array of integers with one missing number, find the missing number.\n>>> find_missing {1 2 3 5} 4\n4",
        "func_title": "proc find_missing {ar N}"
    },
    {
        "prompt": "# Write a function to find the n-th rectangular number.\n# >>> find_rect_num 4\n# 20\nproc find_rect_num {n} {",
        "canonical_solution": "    return [expr {$n * ($n + 1)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_rect_num 4] == 20}\nassert {[find_rect_num 5] == 30}\nassert {[find_rect_num 6] == 42}",
        "declaration": "proc find_rect_num {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_rect_num 4] == 20}",
        "prompt_text": "Write a function to find the n-th rectangular number.",
        "prompt_explain": "Write a function to find the n-th rectangular number.\n>>> find_rect_num 4\n20",
        "func_title": "proc find_rect_num {n}"
    },
    {
        "prompt": "# Given two numbers p and q, find the nth digit in the proper fraction of p/q.\n# >>> find_Nth_Digit 1 2 1\n# 5\nproc find_Nth_Digit {p q N} {",
        "canonical_solution": "    while {$N > 0} {\n        incr N -1\n        set p [expr {$p * 10}]\n        set res [expr {$p / $q}]\n        set p [expr {$p % $q}]\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Nth_Digit 1 2 1] == 5}\nassert {[find_Nth_Digit 3 5 1] == 6}\nassert {[find_Nth_Digit 5 6 5] == 3}",
        "declaration": "proc find_Nth_Digit {p q N} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Nth_Digit 1 2 1] == 5}",
        "prompt_text": "Given two numbers p and q, find the nth digit in the proper fraction of p/q.",
        "prompt_explain": "Given two numbers p and q, find the nth digit in the proper fraction of p/q.\n>>> find_Nth_Digit 1 2 1\n5",
        "func_title": "proc find_Nth_Digit {p q N}"
    },
    {
        "prompt": "# Given a list of integers, find the sum of repeated elements.\n# >>> find_Sum {1 2 3 1 1 4 5 6}\n# 3\nproc find_Sum {arr} {",
        "canonical_solution": "    set sum 0\n    foreach x $arr {\n        if {[llength [lsearch -all $arr $x]] > 1} {\n            incr sum $x\n        }\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Sum {1 2 3 1 1 4 5 6}] == 3}\nassert {[find_Sum {1 2 3 1 1}] == 3}\nassert {[find_Sum {1 1 2}] == 2}",
        "declaration": "proc find_Sum {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Sum {1 2 3 1 1 4 5 6}] == 3}",
        "prompt_text": "Given a list of integers, find the sum of repeated elements.",
        "prompt_explain": "Given a list of integers, find the sum of repeated elements.\n>>> find_Sum {1 2 3 1 1 4 5 6}\n3",
        "func_title": "proc find_Sum {arr}",
        "challenge_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Sum {1 1 2 3 4 5 6 3 5}] == 18}"
    },
    {
        "prompt": "# Given a list of integers, determine whether all the numbers are different from each other or not.\n# >>> test_distinct {1 5 7 9}\n# 1\n# >>> test_distinct {2 4 5 5 7 9}\n# 0\nproc test_distinct {data} {",
        "canonical_solution": "    if {[llength $data] == [llength [lsort -unique $data]]} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[test_distinct {1 5 7 9}] == 1}\nassert {[test_distinct {2 4 5 5 7 9}] == 0}\nassert {[test_distinct {1 2 3}] == 1}",
        "declaration": "proc test_distinct {data} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[test_distinct {1 5 7 9}] == 1}",
        "prompt_text": "Given a list of integers, determine whether all the numbers are different from each other or not.",
        "prompt_explain": "Given a list of integers, determine whether all the numbers are different from each other or not.\n>>> test_distinct {1 5 7 9}\n1\n>>> test_distinct {2 4 5 5 7 9}\n0",
        "func_title": "proc test_distinct {data}"
    },
    {
        "prompt": "# Write a Tcl function to find the last digit when factorial of a divides factorial of b.\n# >>> compute_Last_Digit 2 4\n# 2\nproc compute_Last_Digit {A B} {",
        "canonical_solution": "    set variable 1\n    if {$A == $B} {\n        return 1\n    } elseif {($B - $A) >= 5} {\n        return 0\n    } else {\n        for {set i [expr {$A + 1}]} {$i <= $B} {incr i} {\n            set variable [expr {($variable * ($i % 10)) % 10}]\n        }\n        return [expr {$variable % 10}]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[compute_Last_Digit 2 4] == 2}\nassert {[compute_Last_Digit 6 8] == 6}\nassert {[compute_Last_Digit 1 2] == 2}",
        "declaration": "proc compute_Last_Digit {A B} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[compute_Last_Digit 2 4] == 2}",
        "prompt_text": "Write a Tcl function to find the last digit when factorial of a divides factorial of b.",
        "prompt_explain": "Write a Tcl function to find the last digit when factorial of a divides factorial of b.\n>>> compute_Last_Digit 2 4\n2",
        "func_title": "proc compute_Last_Digit {A B}",
        "challenge_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[compute_Last_Digit 3 7] == 0}\nassert {[compute_Last_Digit 20 23] == 6}\nassert {[compute_Last_Digit 1021 1024] == 4}"
    },
    {
        "prompt": "# Write a function to check if the triangle is equilateral or not.\n# >>> check_equilateral 6 6 6\n# True\n# >>> check_equilateral 6 8 12\n# False\nproc check_equilateral {x y z} {",
        "canonical_solution": "    if {$x == $y && $y == $z} {\n        return True\n    } else {\n        return False\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_equilateral 6 8 12] == False}\nassert {[check_equilateral 6 6 12] == False}\nassert {[check_equilateral 6 6 6] == True}",
        "declaration": "proc check_equilateral {x y z} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_equilateral 6 6 6] == True}",
        "prompt_text": "Write a function to check if the triangle is equilateral or not.",
        "prompt_explain": "Write a function to check if the triangle is equilateral or not.\n>>> check_equilateral 6 6 6\nTrue\n>>> check_equilateral 6 8 12\nFalse",
        "func_title": "proc check_equilateral {x y z}"
    },
    {
        "prompt": "# Write a function to calculate the area of a parallelogram.\n# >>> parallelogram_area 10 20\n# 200\nproc parallelogram_area {b h} {",
        "canonical_solution": "    set area [expr {$b * $h}]\n    return $area\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[parallelogram_area 10 20] == 200}\nassert {[parallelogram_area 15 20] == 300}\nassert {[parallelogram_area 8 9] == 72}",
        "declaration": "proc parallelogram_area {b h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[parallelogram_area 10 20] == 200}",
        "prompt_text": "Write a function to calculate the area of a parallelogram.",
        "prompt_explain": "Write a function to calculate the area of a parallelogram.\n>>> parallelogram_area 10 20\n200",
        "func_title": "proc parallelogram_area {b h}"
    },
    {
        "prompt": "# Given the first term 'a', term number 'n', and common ratio 'r' of a geometric series, return the nth term.\n# >>> tn_gp 1 5 2\n# 16\nproc tn_gp {a n r} {",
        "canonical_solution": "    set tn [expr {$a * pow($r, $n - 1)}]\n    return $tn\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[tn_gp 1 5 2] == 16}\nassert {[tn_gp 1 5 4] == 256}\nassert {[tn_gp 2 6 3] == 486}",
        "declaration": "proc tn_gp {a n r} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[tn_gp 1 5 2] == 16}",
        "prompt_text": "Given the first term 'a', term number 'n', and common ratio 'r' of a geometric series, return the nth term.",
        "prompt_explain": "Given the first term 'a', term number 'n', and common ratio 'r' of a geometric series, return the nth term.\n>>> tn_gp 1 5 2\n16",
        "func_title": "proc tn_gp {a n r}"
    },
    {
        "prompt": "# Given a number, check if it is one less than twice its reverse.\n# >>> check 70\n# 0\n# >>> check 23\n# 0\n# >>> check 73\n# 1\nproc check {n} {",
        "canonical_solution": "    proc rev {num} {\n        set rev_num 0\n        while {$num > 0} {\n            set rev_num [expr {$rev_num * 10 + $num % 10}]\n            set num [expr {$num / 10}]\n        }\n        return $rev_num\n    }\n    return [expr {2 * [rev $n] == $n + 1}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check 70] == 0}\nassert {[check 23] == 0}\nassert {[check 73] == 1}",
        "declaration": "proc check {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check 70] == 0}",
        "prompt_text": "Given a number, check if it is one less than twice its reverse.",
        "prompt_explain": "Given a number, check if it is one less than twice its reverse.\n>>> check 70\n0\n>>> check 23\n0\n>>> check 73\n1",
        "func_title": "proc check {n}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the given two integers have opposite sign or not.\n# >>> opposite_Signs 1 -2\n# 1\n# >>> opposite_Signs 3 2\n# 0\n# >>> opposite_Signs -10 -10\n# 0\nproc opposite_Signs {x y} {",
        "canonical_solution": "    return [expr {($x ^ $y) < 0}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[opposite_Signs 1 -2] == 1}\nassert {[opposite_Signs 3 2] == 0}\nassert {[opposite_Signs -10 -10] == 0}",
        "declaration": "proc opposite_Signs {x y} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[opposite_Signs 1 -2] == 1}",
        "prompt_text": "Write a Tcl function to check whether the given two integers have opposite sign or not.",
        "prompt_explain": "Write a Tcl function to check whether the given two integers have opposite sign or not.\n>>> opposite_Signs 1 -2\n1\n>>> opposite_Signs 3 2\n0\n>>> opposite_Signs -10 -10\n0",
        "func_title": "proc opposite_Signs {x y}"
    },
    {
        "prompt": "# Given an array of integers, find the maximum length of the subsequence with difference between adjacent elements not more than 1.\n# >>> max_len_sub {2 5 6 3 7 6 5 8}\n# 5\nproc max_len_sub {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set mls {}\n    set max 0\n    for {set i 0} {$i < $n} {incr i} {\n        lappend mls 1\n    }\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j 0} {$j < $i} {incr j} {\n            if {abs([lindex $arr $i] - [lindex $arr $j]) <= 1 && [lindex $mls $i] < [expr {[lindex $mls $j] + 1}]} {\n                lset mls $i [expr {[lindex $mls $j] + 1}]\n            }\n        }\n    }\n    for {set i 0} {$i < $n} {incr i} {\n        if {$max < [lindex $mls $i]} {\n            set max [lindex $mls $i]\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_len_sub {2 5 6 3 7 6 5 8}] == 5}\nassert {[max_len_sub {-2 -1 5 -1 4 0 3}] == 4}\nassert {[max_len_sub {9 11 13 15 18}] == 1}",
        "declaration": "proc max_len_sub {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_len_sub {2 5 6 3 7 6 5 8}] == 5}",
        "prompt_text": "Given an array of integers, find the maximum length of the subsequence with difference between adjacent elements not more than 1.",
        "prompt_explain": "Given an array of integers, find the maximum length of the subsequence with difference between adjacent elements not more than 1.\n>>> max_len_sub {2 5 6 3 7 6 5 8}\n5",
        "func_title": "proc max_len_sub {arr}"
    },
    {
        "prompt": "# Given a list of integers, return the smallest number in the list.\n# >>> smallest_num {10 20 1 45 99}\n# 1\nproc smallest_num {xs} {",
        "canonical_solution": "    set smallest [lindex $xs 0]\n    foreach x $xs {\n        if {$x < $smallest} {\n            set smallest $x\n        }\n    }\n    return $smallest\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smallest_num {10 20 1 45 99}] == 1}\nassert {[smallest_num {1 2 3}] == 1}\nassert {[smallest_num {45 46 50 60}] == 45}",
        "declaration": "proc smallest_num {xs} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smallest_num {10 20 1 45 99}] == 1}",
        "prompt_text": "Given a list of integers, return the smallest number in the list.",
        "prompt_explain": "Given a list of integers, return the smallest number in the list.\n>>> smallest_num {10 20 1 45 99}\n1",
        "func_title": "proc smallest_num {xs}"
    },
    {
        "prompt": "# Given a list of integers, possibly containing nested lists, return the sum of all integers in the list. Use recursion to handle nested lists.\n# >>> recursive_list_sum {1 2 {3 4} {5 6}}\n# 21\nproc recursive_list_sum {data_list} {",
        "canonical_solution": "    set total 0\n    foreach element $data_list {\n        if {[llength $element] > 1} {\n            set total [expr {$total + [recursive_list_sum $element]}]\n        } else {\n            set total [expr {$total + $element}]\n        }\n    }\n    return $total\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[recursive_list_sum {1 2 {3 4} {5 6}}] == 21}\nassert {[recursive_list_sum {7 10 {15 14} {19 41}}] == 106}\nassert {[recursive_list_sum {10 20 {30 40} {50 60}}] == 210}",
        "declaration": "proc recursive_list_sum {data_list} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[recursive_list_sum {1 2 {3 4} {5 6}}] == 21}",
        "prompt_text": "Given a list of integers, possibly containing nested lists, return the sum of all integers in the list. Use recursion to handle nested lists.",
        "prompt_explain": "Given a list of integers, possibly containing nested lists, return the sum of all integers in the list. Use recursion to handle nested lists.\n>>> recursive_list_sum {1 2 {3 4} {5 6}}\n21",
        "func_title": "proc recursive_list_sum {data_list}"
    },
    {
        "prompt": "# Write a function to find the number of ways to partition a set of bell numbers.\n# >>> bell_number 2\n# 2\nproc bell_number {n} {",
        "canonical_solution": "    set bell [lrepeat [expr {$n + 1}] [lrepeat [expr {$n + 1}] 0]]\n    lset bell 0 0 1\n    for {set i 1} {$i <= $n} {incr i} {\n        lset bell $i 0 [lindex $bell [expr {$i - 1}] [expr {$i - 1}]]\n        for {set j 1} {$j <= $i} {incr j} {\n            lset bell $i $j [expr {[lindex $bell [expr {$i - 1}] [expr {$j - 1}]] + [lindex $bell $i [expr {$j - 1}]]}]\n        }\n    }\n    return [lindex $bell $n 0]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[bell_number 2] == 2}\nassert {[bell_number 10] == 115975}\nassert {[bell_number 56] == 6775685320645824322581483068371419745979053216268760300}",
        "declaration": "proc bell_number {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[bell_number 2] == 2}",
        "prompt_text": "Write a function to find the number of ways to partition a set of bell numbers.",
        "prompt_explain": "Write a function to find the number of ways to partition a set of bell numbers.\n>>> bell_number 2\n2",
        "func_title": "proc bell_number {n}"
    },
    {
        "prompt": "# Given a list, check whether it contains the given sublist or not.\n# >>> is_sublist {2 4 3 5 7} {3 7}\n# 0\n# >>> is_sublist {2 4 3 5 7} {4 3}\n# 1\nproc is_sublist {l s} {",
        "canonical_solution": "    set sub_set 0\n    if {$s eq {}} {\n        set sub_set 1\n    } elseif {$s eq $l} {\n        set sub_set 1\n    } elseif {[llength $s] > [llength $l]} {\n        set sub_set 0\n    } else {\n        for {set i 0} {$i < [llength $l]} {incr i} {\n            if {[lindex $l $i] == [lindex $s 0]} {\n                set n 1\n                while {$n < [llength $s] && [lindex $l [expr {$i + $n}]] == [lindex $s $n]} {\n                    incr n\n                }\n                if {$n == [llength $s]} {\n                    set sub_set 1\n                }\n            }\n        }\n    }\n    return $sub_set\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_sublist {2 4 3 5 7} {3 7}] == 0}\nassert {[is_sublist {2 4 3 5 7} {4 3}] == 1}\nassert {[is_sublist {2 4 3 5 7} {1 6}] == 0}",
        "declaration": "proc is_sublist {l s} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_sublist {2 4 3 5 7} {3 7}] == 0}",
        "prompt_text": "Given a list, check whether it contains the given sublist or not.",
        "prompt_explain": "Given a list, check whether it contains the given sublist or not.\n>>> is_sublist {2 4 3 5 7} {3 7}\n0\n>>> is_sublist {2 4 3 5 7} {4 3}\n1",
        "func_title": "proc is_sublist {l s}"
    },
    {
        "prompt": "# Given two lists, one of colors and one of patterns, check if the colors follow the sequence given in the patterns array.\n# >>> is_samepatterns {red green green} {a b b}\n# 1\nproc is_samepatterns {colors patterns} {",
        "canonical_solution": "    if {[llength $colors] != [llength $patterns]} {\n        return 0\n    }\n    array set sdict {}\n    set pset {}\n    set sset {}\n    for {set i 0} {$i < [llength $patterns]} {incr i} {\n        lappend pset [lindex $patterns $i]\n        lappend sset [lindex $colors $i]\n        if {![info exists sdict([lindex $patterns $i])]} {\n            set sdict([lindex $patterns $i]) {}\n        }\n        lappend sdict([lindex $patterns $i]) [lindex $colors $i]\n    }\n    if {[llength [lsort -unique $pset]] != [llength [lsort -unique $sset]]} {\n        return 0\n    }\n    foreach {key values} [array get sdict] {\n        for {set i 0} {$i < [expr {[llength $values] - 1}]} {incr i} {\n            if {[lindex $values $i] != [lindex $values [expr {$i + 1}]]} {\n                return 0\n            }\n        }\n    }\n    return 1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_samepatterns {red green green} {a b b}] == 1}\nassert {[is_samepatterns {red green greenn} {a b b}] == 0}\nassert {[is_samepatterns {red green greenn} {a b}] == 0}",
        "declaration": "proc is_samepatterns {colors patterns} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_samepatterns {red green green} {a b b}] == 1}",
        "prompt_text": "Given two lists, one of colors and one of patterns, check if the colors follow the sequence given in the patterns array.",
        "prompt_explain": "Given two lists, one of colors and one of patterns, check if the colors follow the sequence given in the patterns array.\n>>> is_samepatterns {red green green} {a b b}\n1",
        "func_title": "proc is_samepatterns {colors patterns}"
    },
    {
        "prompt": "# Given a rectangle of size m x n, count the number of squares in it.\n# >>> count_Squares 4 3\n# 20\nproc count_Squares {m n} {",
        "canonical_solution": "    if {$n < $m} {\n        set temp $m\n        set m $n\n        set n $temp\n    }\n    return [expr {($m * ($m + 1) * (2 * $m + 1) / 6 + ($n - $m) * $m * ($m + 1) / 2)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Squares 4 3] == 20}\nassert {[count_Squares 2 2] == 5}\nassert {[count_Squares 1 1] == 1}",
        "declaration": "proc count_Squares {m n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Squares 4 3] == 20}",
        "prompt_text": "Given a rectangle of size m x n, count the number of squares in it.",
        "prompt_explain": "Given a rectangle of size m x n, count the number of squares in it.\n>>> count_Squares 4 3\n20",
        "func_title": "proc count_Squares {m n}"
    },
    {
        "prompt": "# Given a word, check whether the length of the word is odd or not.\n# >>> word_len \"Hadoop\"\n# 0\n# >>> word_len \"great\"\n# 1\nproc word_len {s} {",
        "canonical_solution": "    set words [split $s \" \"]\n    foreach word $words {\n        if {[expr {[string length $word] % 2}] != 0} {\n            return 1\n        } else {\n            return 0\n        }\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[word_len \"Hadoop\"] == 0}\nassert {[word_len \"great\"] == 1}\nassert {[word_len \"structure\"] == 1}",
        "declaration": "proc word_len {s} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[word_len \"Hadoop\"] == 0}",
        "prompt_text": "Given a word, check whether the length of the word is odd or not.",
        "prompt_explain": "Given a word, check whether the length of the word is odd or not.\n>>> word_len \"Hadoop\"\n0\n>>> word_len \"great\"\n1",
        "func_title": "proc word_len {s}"
    },
    {
        "prompt": "# Write a function to find the volume of a sphere.\n# >>> volume_sphere 10\n# 4188.790204786391\nproc volume_sphere {r} {",
        "canonical_solution": "    set pi [expr {acos(-1)}]\n    set volume [expr {(4.0/3.0) * $pi * $r * $r * $r}]\n    return $volume\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_sphere 10] == 4188.790204786391}\nassert {[volume_sphere 25] == 65449.84694978735}\nassert {[volume_sphere 20] == 33510.32163829113}",
        "declaration": "proc volume_sphere {r} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_sphere 10] == 4188.790204786391}",
        "prompt_text": "Write a function to find the volume of a sphere.",
        "prompt_explain": "Write a function to find the volume of a sphere.\n>>> volume_sphere 10\n4188.790204786391",
        "func_title": "proc volume_sphere {r}"
    },
    {
        "prompt": "# Given a string, find the character made by adding all the characters of the given string.\n# >>> get_Char \"abc\"\n# f\nproc get_Char {strr} {",
        "canonical_solution": "    set summ 0\n    for {set i 0} {$i < [string length $strr]} {incr i} {\n        set char [string index $strr $i]\n        set summ [expr {$summ + ([scan $char %c] - [scan \"a\" %c] + 1)}]\n    }\n    if {$summ % 26 == 0} {\n        return [format %c [scan \"z\" %c]]\n    } else {\n        set summ [expr {$summ % 26}]\n        return [format %c [expr {[scan \"a\" %c] + $summ - 1}]]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Char \"abc\"] eq \"f\"}\nassert {[get_Char \"gfg\"] eq \"t\"}\nassert {[get_Char \"ab\"] eq \"c\"}",
        "declaration": "proc get_Char {strr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Char \"abc\"] eq \"f\"}",
        "prompt_text": "Given a string, find the character made by adding all the characters of the given string.",
        "prompt_explain": "Given a string, find the character made by adding all the characters of the given string.\n>>> get_Char \"abc\"\nf",
        "func_title": "proc get_Char {strr}"
    },
    {
        "prompt": "# Write a function to find the n-th number in the Newman-Conway sequence.\n# >>> sequence 10\n# 6\nproc sequence {n} {",
        "canonical_solution": "    if {$n == 1 || $n == 2} {\n        return 1\n    } else {\n        return [expr {[sequence [sequence [expr {$n - 1}]]] + [sequence [expr {$n - [sequence [expr {$n - 1}]]}]]}]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sequence 10] == 6}\nassert {[sequence 2] == 1}\nassert {[sequence 3] == 2}",
        "declaration": "proc sequence {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sequence 10] == 6}",
        "prompt_text": "Write a function to find the n-th number in the Newman-Conway sequence.",
        "prompt_explain": "Write a function to find the n-th number in the Newman-Conway sequence.\n>>> sequence 10\n6",
        "func_title": "proc sequence {n}"
    },
    {
        "prompt": "# Write a function to find the surface area of a sphere.\n# >>> surfacearea_sphere 10\n# 1256.6370614359173\nproc surfacearea_sphere {r} {",
        "canonical_solution": "    set pi 3.141592653589793\n    set surfacearea [expr {4 * $pi * $r * $r}]\n    return $surfacearea\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surfacearea_sphere 10] == 1256.6370614359173}\nassert {[surfacearea_sphere 15] == 2827.4333882308138}\nassert {[surfacearea_sphere 20] == 5026.548245743669}",
        "declaration": "proc surfacearea_sphere {r} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surfacearea_sphere 10] == 1256.6370614359173}",
        "prompt_text": "Write a function to find the surface area of a sphere.",
        "prompt_explain": "Write a function to find the surface area of a sphere.\n>>> surfacearea_sphere 10\n1256.6370614359173",
        "func_title": "proc surfacearea_sphere {r}"
    },
    {
        "prompt": "# Write a function to find the closest smaller number than n.\n# >>> closest_num 11\n# 10\nproc closest_num {n} {",
        "canonical_solution": "    return [expr {$n - 1}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[closest_num 11] == 10}\nassert {[closest_num 7] == 6}\nassert {[closest_num 12] == 11}",
        "declaration": "proc closest_num {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[closest_num 11] == 10}",
        "prompt_text": "Write a function to find the closest smaller number than n.",
        "prompt_explain": "Write a function to find the closest smaller number than n.\n>>> closest_num 11\n10",
        "func_title": "proc closest_num {n}"
    },
    {
        "prompt": "# Given a list of words, return the length of the longest word.\n# >>> len_log {python PHP bigdata}\n# 7\nproc len_log {list1} {",
        "canonical_solution": "    set max [string length [lindex $list1 0]]\n    foreach i $list1 {\n        if {[string length $i] > $max} {\n            set max [string length $i]\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[len_log {python PHP bigdata}] == 7}\nassert {[len_log {a ab abc}] == 3}\nassert {[len_log {small big tall}] == 5}",
        "declaration": "proc len_log {list1} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[len_log {python PHP bigdata}] == 7}",
        "prompt_text": "Given a list of words, return the length of the longest word.",
        "prompt_explain": "Given a list of words, return the length of the longest word.\n>>> len_log {python PHP bigdata}\n7",
        "func_title": "proc len_log {list1}"
    },
    {
        "prompt": "# Given a list of strings, check if a substring is present in any of the strings in the list.\n# >>> find_substring {\"red\" \"black\" \"white\" \"green\" \"orange\"} \"ack\"\n# true\nproc find_substring {str1 sub_str} {",
        "canonical_solution": "    foreach s $str1 {\n        if {[string first $sub_str $s] != -1} {\n            return true\n        }\n    }\n    return false\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_substring {\"red\" \"black\" \"white\" \"green\" \"orange\"} \"ack\"] == true}\nassert {[find_substring {\"red\" \"black\" \"white\" \"green\" \"orange\"} \"abc\"] == false}\nassert {[find_substring {\"red\" \"black\" \"white\" \"green\" \"orange\"} \"ange\"] == true}",
        "declaration": "proc find_substring {str1 sub_str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_substring {\"red\" \"black\" \"white\" \"green\" \"orange\"} \"ack\"] == true}",
        "prompt_text": "Given a list of strings, check if a substring is present in any of the strings in the list.",
        "prompt_explain": "Given a list of strings, check if a substring is present in any of the strings in the list.\n>>> find_substring {\"red\" \"black\" \"white\" \"green\" \"orange\"} \"ack\"\ntrue",
        "func_title": "proc find_substring {str1 sub_str}"
    },
    {
        "prompt": "# Write a function to check whether the given number is undulating or not.\n# >>> is_undulating \"1212121\"\n# 1\n# >>> is_undulating \"1991\"\n# 0\n# >>> is_undulating \"121\"\n# 1\nproc is_undulating {n} {",
        "canonical_solution": "    if {[string length $n] <= 2} {\n        return 0\n    }\n    for {set i 2} {$i < [string length $n]} {incr i} {\n        if {[string index $n [expr {$i - 2}]] != [string index $n $i]} {\n            return 0\n        }\n    }\n    return 1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_undulating \"1212121\"] == 1}\nassert {[is_undulating \"1991\"] == 0}\nassert {[is_undulating \"121\"] == 1}",
        "declaration": "proc is_undulating {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_undulating \"1212121\"] == 1}",
        "prompt_text": "Write a function to check whether the given number is undulating or not.",
        "prompt_explain": "Write a function to check whether the given number is undulating or not.\n>>> is_undulating \"1212121\"\n1\n>>> is_undulating \"1991\"\n0\n>>> is_undulating \"121\"\n1",
        "func_title": "proc is_undulating {n}"
    },
    {
        "prompt": "# Write a function to calculate the value of 'a' to the power 'b'.\n# >>> power 3 4\n# 81\nproc power {a b} {",
        "canonical_solution": "    if {$b == 0} {\n        return 1\n    } elseif {$a == 0} {\n        return 0\n    } elseif {$b == 1} {\n        return $a\n    } else {\n        return [expr {$a * [power $a [expr {$b - 1}]]}]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[power 3 4] == 81}\nassert {[power 2 3] == 8}\nassert {[power 5 5] == 3125}",
        "declaration": "proc power {a b} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[power 3 4] == 81}",
        "prompt_text": "Write a function to calculate the value of 'a' to the power 'b'.",
        "prompt_explain": "Write a function to calculate the value of 'a' to the power 'b'.\n>>> power 3 4\n81",
        "func_title": "proc power {a b}"
    },
    {
        "prompt": "# Given a list of sublists, find the minimum length of the sublists.\n# >>> Find_Min_Length {{1} {1 2}}\n# 1\nproc Find_Min_Length {lst} {",
        "canonical_solution": "    set minLength [lindex [lsort -integer [lmap x $lst {llength $x}]] 0]\n    return $minLength\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Find_Min_Length {{1} {1 2}}] == 1}\nassert {[Find_Min_Length {{1 2} {1 2 3} {1 2 3 4}}] == 2}\nassert {[Find_Min_Length {{3 3 3} {4 4 4 4}}] == 3}",
        "declaration": "proc Find_Min_Length {lst} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Find_Min_Length {{1} {1 2}}] == 1}",
        "prompt_text": "Given a list of sublists, find the minimum length of the sublists.",
        "prompt_explain": "Given a list of sublists, find the minimum length of the sublists.\n>>> Find_Min_Length {{1} {1 2}}\n1",
        "func_title": "proc Find_Min_Length {lst}"
    },
    {
        "prompt": "# Given a number, find the next smallest palindrome.\n# >>> next_smallest_palindrome 99\n# 101\nproc next_smallest_palindrome {num} {",
        "canonical_solution": "    while {1} {\n        incr num\n        set numstr [string reverse $num]\n        if {$num == $numstr} {\n            return $num\n        }\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[next_smallest_palindrome 99] == 101}\nassert {[next_smallest_palindrome 1221] == 1331}\nassert {[next_smallest_palindrome 120] == 121}",
        "declaration": "proc next_smallest_palindrome {num} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[next_smallest_palindrome 99] == 101}",
        "prompt_text": "Given a number, find the next smallest palindrome.",
        "prompt_explain": "Given a number, find the next smallest palindrome.\n>>> next_smallest_palindrome 99\n101",
        "func_title": "proc next_smallest_palindrome {num}"
    },
    {
        "prompt": "# Given a list of integers, find the kth smallest element in the list. Do not use the built-in sort command.\n# >>> kth_element {12 3 5 7 19} 5 2\n# 5\nproc kth_element {arr n k} {",
        "canonical_solution": "    for {set i 0} {$i < $n} {incr i} {\n        for {set j 0} {$j < [expr {$n - $i - 1}]} {incr j} {\n            if {[lindex $arr $j] > [lindex $arr [expr {$j + 1}]]} {\n                set temp [lindex $arr $j]\n                lset arr $j [lindex $arr [expr {$j + 1}]]\n                lset arr [expr {$j + 1}] $temp\n            }\n        }\n    }\n    return [lindex $arr [expr {$k - 1}]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[kth_element {12 3 5 7 19} 5 2] == 5}\nassert {[kth_element {17 24 8 23} 4 3] == 8}\nassert {[kth_element {16 21 25 36 4} 5 4] == 36}",
        "declaration": "proc kth_element {arr n k} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[kth_element {12 3 5 7 19} 5 2] == 5}",
        "prompt_text": "Given a list of integers, find the kth smallest element in the list. Do not use the built-in sort command.",
        "prompt_explain": "Given a list of integers, find the kth smallest element in the list. Do not use the built-in sort command.\n>>> kth_element {12 3 5 7 19} 5 2\n5",
        "func_title": "proc kth_element {arr n k}"
    },
    {
        "prompt": "# Write a Tcl function to count hexadecimal numbers for a given range.\n# >>> count_Hexadecimal 10 15\n# 6\nproc count_Hexadecimal {L R} {",
        "canonical_solution": "    set count 0\n    for {set i $L} {$i <= $R} {incr i} {\n        if {$i >= 10 && $i <= 15} {\n            incr count\n        } elseif {$i > 15} {\n            set k $i\n            while {$k != 0} {\n                if {[expr {$k % 16}] >= 10} {\n                    incr count\n                }\n                set k [expr {$k / 16}]\n            }\n        }\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Hexadecimal 10 15] == 6}\nassert {[count_Hexadecimal 2 4] == 0}\nassert {[count_Hexadecimal 15 16] == 1}",
        "declaration": "proc count_Hexadecimal {L R} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Hexadecimal 10 15] == 6}",
        "prompt_text": "Write a Tcl function to count hexadecimal numbers for a given range.",
        "prompt_explain": "Write a Tcl function to count hexadecimal numbers for a given range.\n>>> count_Hexadecimal 10 15\n6",
        "func_title": "proc count_Hexadecimal {L R}"
    },
    {
        "prompt": "# Write a Tcl function to find the perimeter of a cylinder.\n# >>> perimeter 2 4\n# 12\nproc perimeter {diameter height} {",
        "canonical_solution": "    return [expr {2 * ($diameter + $height)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[perimeter 2 4] == 12}\nassert {[perimeter 1 2] == 6}\nassert {[perimeter 3 1] == 8}",
        "declaration": "proc perimeter {diameter height} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[perimeter 2 4] == 12}",
        "prompt_text": "Write a Tcl function to find the perimeter of a cylinder.",
        "prompt_explain": "Write a Tcl function to find the perimeter of a cylinder.\n>>> perimeter 2 4\n12",
        "func_title": "proc perimeter {diameter height}"
    },
    {
        "prompt": "# Write a function to check if a string represents an integer or not.\n# >>> check_integer \"python\"\n# 0\n# >>> check_integer \"1\"\n# 1\n# >>> check_integer \"12345\"\n# 1\nproc check_integer {text} {",
        "canonical_solution": "    set text [string trim $text]\n    if {[string length $text] < 1} {\n        return 0\n    } else {\n        if {[regexp {^[+-]?\\d+$} $text]} {\n            return 1\n        } else {\n            return 0\n        }\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_integer \"python\"] == 0}\nassert {[check_integer \"1\"] == 1}\nassert {[check_integer \"12345\"] == 1}",
        "declaration": "proc check_integer {text} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_integer \"python\"] == 0}",
        "prompt_text": "Write a function to check if a string represents an integer or not.",
        "prompt_explain": "Write a function to check if a string represents an integer or not.\n>>> check_integer \"python\"\n0\n>>> check_integer \"1\"\n1\n>>> check_integer \"12345\"\n1",
        "func_title": "proc check_integer {text}"
    },
    {
        "prompt": "# Given a tuple of positive integers, convert it into an integer.\n# >>> tuple_to_int {1 2 3}\n# 123\nproc tuple_to_int {nums} {",
        "canonical_solution": "    set result \"\"\n    foreach num $nums {\n        append result $num\n    }\n    return [expr {$result + 0}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[tuple_to_int {1 2 3}] == 123}\nassert {[tuple_to_int {4 5 6}] == 456}\nassert {[tuple_to_int {5 6 7}] == 567}",
        "declaration": "proc tuple_to_int {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[tuple_to_int {1 2 3}] == 123}",
        "prompt_text": "Given a tuple of positive integers, convert it into an integer.",
        "prompt_explain": "Given a tuple of positive integers, convert it into an integer.\n>>> tuple_to_int {1 2 3}\n123",
        "func_title": "proc tuple_to_int {nums}"
    },
    {
        "prompt": "# Given a sorted list of integers where all elements appear twice except for one, find the element that appears only once.\n# >>> search {1 1 2 2 3}\n# 3\nproc search {arr} {",
        "canonical_solution": "    set XOR 0\n    foreach num $arr {\n        set XOR [expr {$XOR ^ $num}]\n    }\n    return $XOR\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[search {1 1 2 2 3}] == 3}\nassert {[search {1 1 3 3 4 4 5 5 7 7 8}] == 8}\nassert {[search {1 2 2 3 3 4 4}] == 1}",
        "declaration": "proc search {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[search {1 1 2 2 3}] == 3}",
        "prompt_text": "Given a sorted list of integers where all elements appear twice except for one, find the element that appears only once.",
        "prompt_explain": "Given a sorted list of integers where all elements appear twice except for one, find the element that appears only once.\n>>> search {1 1 2 2 3}\n3",
        "func_title": "proc search {arr}"
    },
    {
        "prompt": "# Write a function to find nth smart number.\n# >>> smartNumber 1\n# 30\n# >>> smartNumber 50\n# 273\n# >>> smartNumber 1000\n# 2664\nproc smartNumber {n} {",
        "canonical_solution": "    set MAX 3000\n    set primes [lrepeat $MAX 0]\n    set result {}\n    for {set i 2} {$i < $MAX} {incr i} {\n        if {[lindex $primes $i] == 0} {\n            lset primes $i 1\n            set j [expr {$i * 2}]\n            while {$j < $MAX} {\n                lset primes $j [expr {[lindex $primes $j] - 1}]\n                if {[expr {[lindex $primes $j] + 3}] == 0} {\n                    lappend result $j\n                }\n                set j [expr {$j + $i}]\n            }\n        }\n    }\n    set result [lsort -integer $result]\n    return [lindex $result [expr {$n - 1}]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smartNumber 1] == 30}\nassert {[smartNumber 50] == 273}\nassert {[smartNumber 1000] == 2664}",
        "declaration": "proc smartNumber {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smartNumber 1] == 30}",
        "prompt_text": "Write a function to find nth smart number.",
        "prompt_explain": "Write a function to find nth smart number.\n>>> smartNumber 1\n30\n>>> smartNumber 50\n273\n>>> smartNumber 1000\n2664",
        "func_title": "proc smartNumber {n}"
    },
    {
        "prompt": "# Write a function to find the nth hexagonal number.\n# >>> hexagonal_num 10\n# 190\nproc hexagonal_num {n} {",
        "canonical_solution": "    return [expr {$n * (2 * $n - 1)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[hexagonal_num 10] == 190}\nassert {[hexagonal_num 5] == 45}\nassert {[hexagonal_num 7] == 91}",
        "declaration": "proc hexagonal_num {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[hexagonal_num 10] == 190}",
        "prompt_text": "Write a function to find the nth hexagonal number.",
        "prompt_explain": "Write a function to find the nth hexagonal number.\n>>> hexagonal_num 10\n190",
        "func_title": "proc hexagonal_num {n}"
    },
    {
        "prompt": "# Write a function to calculate electricity bill.\n# >>> cal_electbill 75\n# 246.25\nproc cal_electbill {units} {",
        "canonical_solution": "    if {$units < 50} {\n        set amount [expr {$units * 2.60}]\n        set surcharge 25\n    } elseif {$units <= 100} {\n        set amount [expr {130 + (($units - 50) * 3.25)}]\n        set surcharge 35\n    } elseif {$units <= 200} {\n        set amount [expr {130 + 162.50 + (($units - 100) * 5.26)}]\n        set surcharge 45\n    } else {\n        set amount [expr {130 + 162.50 + 526 + (($units - 200) * 8.45)}]\n        set surcharge 75\n    }\n    set total [expr {$amount + $surcharge}]\n    return $total\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[cal_electbill 75] == 246.25}\nassert {[cal_electbill 265] == 1442.75}\nassert {[cal_electbill 100] == 327.5}",
        "declaration": "proc cal_electbill {units} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[cal_electbill 75] == 246.25}",
        "prompt_text": "Write a function to calculate electricity bill.",
        "prompt_explain": "Write a function to calculate electricity bill.\n>>> cal_electbill 75\n246.25",
        "func_title": "proc cal_electbill {units}"
    },
    {
        "prompt": "# Given a list of integers, return the ratio of zeroes in the list.\n# >>> zero_count {0 1 2 -1 -5 6 0 -3 -2 3 4 6 8}\n# 0.15\nproc zero_count {nums} {",
        "canonical_solution": "    set n [llength $nums]\n    set n1 0\n    foreach x $nums {\n        if {$x == 0} {\n            incr n1\n        }\n    }\n    return [expr {round(double($n1)/$n*100)/100.0}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[zero_count {0 1 2 -1 -5 6 0 -3 -2 3 4 6 8}] == 0.15}\nassert {[zero_count {2 1 2 -1 -5 6 4 -3 -2 3 4 6 8}] == 0.00}\nassert {[zero_count {2 4 -6 -9 11 -12 14 -5 17}] == 0.00}",
        "declaration": "proc zero_count {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[zero_count {0 1 2 -1 -5 6 0 -3 -2 3 4 6 8}] == 0.15}",
        "prompt_text": "Given a list of integers, return the ratio of zeroes in the list.",
        "prompt_explain": "Given a list of integers, return the ratio of zeroes in the list.\n>>> zero_count {0 1 2 -1 -5 6 0 -3 -2 3 4 6 8}\n0.15",
        "func_title": "proc zero_count {nums}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\n# >>> is_Sum_Of_Powers_Of_Two 10\n# 1\n# >>> is_Sum_Of_Powers_Of_Two 7\n# 0\nproc is_Sum_Of_Powers_Of_Two {n} {",
        "canonical_solution": "    if {$n % 2 == 1} {\n        return 0\n    } else {\n        return 1\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Sum_Of_Powers_Of_Two 10] == 1}\nassert {[is_Sum_Of_Powers_Of_Two 7] == 0}\nassert {[is_Sum_Of_Powers_Of_Two 14] == 1}",
        "declaration": "proc is_Sum_Of_Powers_Of_Two {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Sum_Of_Powers_Of_Two 10] == 1}",
        "prompt_text": "Write a Tcl function to check whether the given number can be represented as sum of non-zero powers of 2 or not.",
        "prompt_explain": "Write a Tcl function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\n>>> is_Sum_Of_Powers_Of_Two 10\n1\n>>> is_Sum_Of_Powers_Of_Two 7\n0",
        "func_title": "proc is_Sum_Of_Powers_Of_Two {n}"
    },
    {
        "prompt": "# Write a function to find the circumference of a circle.\n# >>> circle_circumference 10\n# 62.830000000000005\nproc circle_circumference {r} {",
        "canonical_solution": "    set perimeter [expr {2 * 3.1415 * $r}]\n    return $perimeter\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[circle_circumference 10] == 62.830000000000005}\nassert {[circle_circumference 5] == 31.415000000000003}\nassert {[circle_circumference 4] == 25.132}",
        "declaration": "proc circle_circumference {r} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[circle_circumference 10] == 62.830000000000005}",
        "prompt_text": "Write a function to find the circumference of a circle.",
        "prompt_explain": "Write a function to find the circumference of a circle.\n>>> circle_circumference 10\n62.830000000000005",
        "func_title": "proc circle_circumference {r}"
    },
    {
        "prompt": "# Given three lists of integers, return the count of positions where all three lists have the same element.\n# >>> count_samepair {1 2 3 4 5 6 7 8} {2 2 3 1 2 6 7 9} {2 1 3 1 2 6 7 9}\n# 3\nproc count_samepair {list1 list2 list3} {",
        "canonical_solution": "    set count 0\n    foreach m $list1 n $list2 o $list3 {\n        if {$m == $n && $n == $o} {\n            incr count\n        }\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_samepair {1 2 3 4 5 6 7 8} {2 2 3 1 2 6 7 9} {2 1 3 1 2 6 7 9}] == 3}\nassert {[count_samepair {1 2 3 4 5 6 7 8} {2 2 3 1 2 6 7 8} {2 1 3 1 2 6 7 8}] == 4}\nassert {[count_samepair {1 2 3 4 2 6 7 8} {2 2 3 1 2 6 7 8} {2 1 3 1 2 6 7 8}] == 5}",
        "declaration": "proc count_samepair {list1 list2 list3} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_samepair {1 2 3 4 5 6 7 8} {2 2 3 1 2 6 7 9} {2 1 3 1 2 6 7 9}] == 3}",
        "prompt_text": "Given three lists of integers, return the count of positions where all three lists have the same element.",
        "prompt_explain": "Given three lists of integers, return the count of positions where all three lists have the same element.\n>>> count_samepair {1 2 3 4 5 6 7 8} {2 2 3 1 2 6 7 9} {2 1 3 1 2 6 7 9}\n3",
        "func_title": "proc count_samepair {list1 list2 list3}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of absolute differences in all pairs of the given array.\n# >>> sum_Pairs {1 8 9 15 16}\n# 74\nproc sum_Pairs {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set sum 0\n    for {set i [expr {$n - 1}]} {$i >= 0} {incr i -1} {\n        set sum [expr {$sum + $i * [lindex $arr $i] - ($n - 1 - $i) * [lindex $arr $i]}]\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_Pairs {1 8 9 15 16}] == 74}\nassert {[sum_Pairs {1 2 3 4}] == 10}\nassert {[sum_Pairs {1 2 3 4 5 7 9 11 14}] == 188}",
        "declaration": "proc sum_Pairs {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_Pairs {1 8 9 15 16}] == 74}",
        "prompt_text": "Given a list of integers, return the sum of absolute differences in all pairs of the given array.",
        "prompt_explain": "Given a list of integers, return the sum of absolute differences in all pairs of the given array.\n>>> sum_Pairs {1 8 9 15 16}\n74",
        "func_title": "proc sum_Pairs {arr}"
    },
    {
        "prompt": "# Given a list of integers, find the maximum difference between any two elements in the list.\n# >>> max_Abs_Diff {2 1 5 3}\n# 4\nproc max_Abs_Diff {arr} {",
        "canonical_solution": "    set minEle [lindex $arr 0]\n    set maxEle [lindex $arr 0]\n    set n [llength $arr]\n    for {set i 1} {$i < $n} {incr i} {\n        set current [lindex $arr $i]\n        if {$current < $minEle} {\n            set minEle $current\n        }\n        if {$current > $maxEle} {\n            set maxEle $current\n        }\n    }\n    return [expr {$maxEle - $minEle}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_Abs_Diff {2 1 5 3}] == 4}\nassert {[max_Abs_Diff {9 3 2 5 1}] == 8}\nassert {[max_Abs_Diff {3 2 1}] == 2}",
        "declaration": "proc max_Abs_Diff {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_Abs_Diff {2 1 5 3}] == 4}",
        "prompt_text": "Given a list of integers, find the maximum difference between any two elements in the list.",
        "prompt_explain": "Given a list of integers, find the maximum difference between any two elements in the list.\n>>> max_Abs_Diff {2 1 5 3}\n4",
        "func_title": "proc max_Abs_Diff {arr}"
    },
    {
        "prompt": "# Given an array of integers, find the length of the longest subsequence such that the difference between adjacent elements is one.\n# >>> longest_subseq_with_diff_one {1 2 3 4 5 3 2}\n# 6\nproc longest_subseq_with_diff_one {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set dp [lrepeat $n 1]\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j 0} {$j < $i} {incr j} {\n            if {[expr {abs([lindex $arr $i] - [lindex $arr $j])}] == 1} {\n                lset dp $i [expr {max([lindex $dp $i], [lindex $dp $j] + 1)}]\n            }\n        }\n    }\n    set result 1\n    for {set i 0} {$i < $n} {incr i} {\n        if {[lindex $dp $i] > $result} {\n            set result [lindex $dp $i]\n        }\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[longest_subseq_with_diff_one {1 2 3 4 5 3 2}] == 6}\nassert {[longest_subseq_with_diff_one {10 9 4 5 4 8 6}] == 3}\nassert {[longest_subseq_with_diff_one {1 2 3 2 3 7 2 1}] == 7}",
        "declaration": "proc longest_subseq_with_diff_one {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[longest_subseq_with_diff_one {1 2 3 4 5 3 2}] == 6}",
        "prompt_text": "Given an array of integers, find the length of the longest subsequence such that the difference between adjacent elements is one.",
        "prompt_explain": "Given an array of integers, find the length of the longest subsequence such that the difference between adjacent elements is one.\n>>> longest_subseq_with_diff_one {1 2 3 4 5 3 2}\n6",
        "func_title": "proc longest_subseq_with_diff_one {arr}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the given two numbers are co-prime or not.\n# Two numbers are co-prime if their greatest common divisor (GCD) is 1.\n# >>> is_coprime 17 13\n# 1\n# >>> is_coprime 15 21\n# 0\nproc is_coprime {x y} {",
        "canonical_solution": "    proc gcd {p q} {\n        while {$q != 0} {\n            set temp $q\n            set q [expr {$p % $q}]\n            set p $temp\n        }\n        return $p\n    }\n    return [expr {[gcd $x $y] == 1}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_coprime 17 13] == 1}\nassert {[is_coprime 15 21] == 0}\nassert {[is_coprime 25 45] == 0}",
        "declaration": "proc is_coprime {x y} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_coprime 17 13] == 1}",
        "prompt_text": "Write a Tcl function to check whether the given two numbers are co-prime or not. Two numbers are co-prime if their greatest common divisor (GCD) is 1.",
        "prompt_explain": "Write a Tcl function to check whether the given two numbers are co-prime or not. Two numbers are co-prime if their greatest common divisor (GCD) is 1.\n>>> is_coprime 17 13\n1\n>>> is_coprime 15 21\n0",
        "func_title": "proc is_coprime {x y}"
    },
    {
        "prompt": "# Write a Tcl function to toggle all even bits of a given number.\n# >>> even_bit_toggle_number 10\n# 0\n# >>> even_bit_toggle_number 20\n# 30\n# >>> even_bit_toggle_number 30\n# 20\nproc even_bit_toggle_number {n} {",
        "canonical_solution": "    set res 0\n    set count 0\n    set temp $n\n    while {$temp > 0} {\n        if {$count % 2 == 1} {\n            set res [expr {$res | (1 << $count)}]\n        }\n        incr count\n        set temp [expr {$temp >> 1}]\n    }\n    return [expr {$n ^ $res}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_bit_toggle_number 10] == 0}\nassert {[even_bit_toggle_number 20] == 30}\nassert {[even_bit_toggle_number 30] == 20}",
        "declaration": "proc even_bit_toggle_number {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_bit_toggle_number 10] == 0}",
        "prompt_text": "Write a Tcl function to toggle all even bits of a given number.",
        "prompt_explain": "Write a Tcl function to toggle all even bits of a given number.\n>>> even_bit_toggle_number 10\n0\n>>> even_bit_toggle_number 20\n30\n>>> even_bit_toggle_number 30\n20",
        "func_title": "proc even_bit_toggle_number {n}"
    },
    {
        "prompt": "# Given a list of integers and a number k, find the minimum number of operations required to make all elements equal. Each operation consists of adding k to an element.\n# >>> min_Ops {2 2 2 2} 4 3\n# 0\n# >>> min_Ops {4 2 6 8} 4 3\n# -1\n# >>> min_Ops {21 33 9 45 63} 5 6\n# 24\nproc min_Ops {arr n k} {",
        "canonical_solution": "    set max1 [tcl::mathfunc::max {*}$arr]\n    set res 0\n    for {set i 0} {$i < $n} {incr i} {\n        if {([expr {$max1 - [lindex $arr $i]}] % $k) != 0} {\n            return -1\n        } else {\n            set res [expr {$res + (($max1 - [lindex $arr $i]) / $k)}]\n        }\n    }\n    return [expr {int($res)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_Ops {2 2 2 2} 4 3] == 0}\nassert {[min_Ops {4 2 6 8} 4 3] == -1}\nassert {[min_Ops {21 33 9 45 63} 5 6] == 24}",
        "declaration": "proc min_Ops {arr n k} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_Ops {2 2 2 2} 4 3] == 0}",
        "prompt_text": "Given a list of integers and a number k, find the minimum number of operations required to make all elements equal. Each operation consists of adding k to an element.",
        "prompt_explain": "Given a list of integers and a number k, find the minimum number of operations required to make all elements equal. Each operation consists of adding k to an element.\n>>> min_Ops {2 2 2 2} 4 3\n0\n>>> min_Ops {4 2 6 8} 4 3\n-1\n>>> min_Ops {21 33 9 45 63} 5 6\n24",
        "func_title": "proc min_Ops {arr n k}"
    },
    {
        "prompt": "# Write a function to calculate the sum of the positive integers of n+(n-2)+(n-4)... (until n-x =< 0).\n# >>> sum_series 6\n# 12\nproc sum_series {n} {",
        "canonical_solution": "    if {$n < 1} {\n        return 0\n    } else {\n        return [expr {$n + [sum_series [expr {$n - 2}]]}]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_series 6] == 12}\nassert {[sum_series 10] == 30}\nassert {[sum_series 9] == 25}",
        "declaration": "proc sum_series {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_series 6] == 12}",
        "prompt_text": "Write a function to calculate the sum of the positive integers of n+(n-2)+(n-4)... (until n-x =< 0).",
        "prompt_explain": "Write a function to calculate the sum of the positive integers of n+(n-2)+(n-4)... (until n-x =< 0).\n>>> sum_series 6\n12",
        "func_title": "proc sum_series {n}"
    },
    {
        "prompt": "# Write a function to calculate the area of a regular polygon.\n# >>> area_polygon 4 20\n# 400.00000000000006\nproc area_polygon {s l} {",
        "canonical_solution": "    set pi [expr {acos(-1)}]\n    set area [expr {$s * ($l ** 2) / (4 * tan($pi / $s))}]\n    return $area\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[area_polygon 4 20] == 400.00000000000006}\nassert {[area_polygon 10 15] == 1731.1969896610804}\nassert {[area_polygon 9 7] == 302.90938549487214}",
        "declaration": "proc area_polygon {s l} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[area_polygon 4 20] == 400.00000000000006}",
        "prompt_text": "Write a function to calculate the area of a regular polygon.",
        "prompt_explain": "Write a function to calculate the area of a regular polygon.\n>>> area_polygon 4 20\n400.00000000000006",
        "func_title": "proc area_polygon {s l}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the sum of divisors are same or not.\n# >>> areEquivalent 36 57\n# 0\n# >>> areEquivalent 2 4\n# 0\n# >>> areEquivalent 23 47\n# 1\nproc areEquivalent {num1 num2} {",
        "canonical_solution": "    proc divSum {n} {\n        set sum 1\n        for {set i 2} {$i * $i <= $n} {incr i} {\n            if {$n % $i == 0} {\n                set sum [expr {$sum + $i + $n / $i}]\n            }\n        }\n        return $sum\n    }\n    return [expr {[divSum $num1] == [divSum $num2]}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[areEquivalent 36 57] == 0}\nassert {[areEquivalent 2 4] == 0}\nassert {[areEquivalent 23 47] == 1}",
        "declaration": "proc areEquivalent {num1 num2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[areEquivalent 36 57] == 0}",
        "prompt_text": "Write a Tcl function to check whether the sum of divisors are same or not.",
        "prompt_explain": "Write a Tcl function to check whether the sum of divisors are same or not.\n>>> areEquivalent 36 57\n0\n>>> areEquivalent 2 4\n0\n>>> areEquivalent 23 47\n1",
        "func_title": "proc areEquivalent {num1 num2}"
    },
    {
        "prompt": "# Write a Tcl function to count characters at same position in a given string (lower and uppercase characters) as in English alphabet.\n# >>> count_char_position \"xbcefg\"\n# 2\nproc count_char_position {str1} {",
        "canonical_solution": "    set count_chars 0\n    set length [string length $str1]\n    for {set i 0} {$i < $length} {incr i} {\n        set char [string index $str1 $i]\n        if {[expr {$i == [expr {[scan $char %c] - [scan \"A\" %c]}]}] || [expr {$i == [expr {[scan $char %c] - [scan \"a\" %c]}]}]} {\n            incr count_chars\n        }\n    }\n    return $count_chars\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_char_position \"xbcefg\"] == 2}\nassert {[count_char_position \"ABcED\"] == 3}\nassert {[count_char_position \"AbgdeF\"] == 5}",
        "declaration": "proc count_char_position {str1} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_char_position \"xbcefg\"] == 2}",
        "prompt_text": "Write a Tcl function to count characters at same position in a given string (lower and uppercase characters) as in English alphabet.",
        "prompt_explain": "Write a Tcl function to count characters at same position in a given string (lower and uppercase characters) as in English alphabet.\n>>> count_char_position \"xbcefg\"\n2",
        "func_title": "proc count_char_position {str1}"
    },
    {
        "prompt": "# Given a list of integers, return the count of pairs whose XOR is an even number.\n# >>> find_even_Pair {5 4 7 2 1}\n# 4\nproc find_even_Pair {A N} {",
        "canonical_solution": "    set evenPair 0\n    for {set i 0} {$i < $N} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $N} {incr j} {\n            if {([lindex $A $i] ^ [lindex $A $j]) % 2 == 0} {\n                incr evenPair\n            }\n        }\n    }\n    return $evenPair\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_even_Pair {5 4 7 2 1} 5] == 4}\nassert {[find_even_Pair {7 2 8 1 0 5 11} 7] == 9}\nassert {[find_even_Pair {1 2 3} 3] == 1}",
        "declaration": "proc find_even_Pair {A N} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_even_Pair {5 4 7 2 1} 5] == 4}",
        "prompt_text": "Given a list of integers, return the count of pairs whose XOR is an even number.",
        "prompt_explain": "Given a list of integers, return the count of pairs whose XOR is an even number.\n>>> find_even_Pair {5 4 7 2 1}\n4",
        "func_title": "proc find_even_Pair {A N}"
    },
    {
        "prompt": "# Write a Tcl function to find the smallest power of 2 greater than or equal to n.\n# >>> next_Power_Of_2 0\n# 1\n# >>> next_Power_Of_2 5\n# 8\n# >>> next_Power_Of_2 17\n# 32\nproc next_Power_Of_2 {n} {",
        "canonical_solution": "    set count 0\n    if {$n && !($n & ($n - 1))} {\n        return $n\n    }\n    while {$n != 0} {\n        set n [expr {$n >> 1}]\n        incr count\n    }\n    return [expr {1 << $count}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[next_Power_Of_2 0] == 1}\nassert {[next_Power_Of_2 5] == 8}\nassert {[next_Power_Of_2 17] == 32}",
        "declaration": "proc next_Power_Of_2 {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[next_Power_Of_2 0] == 1}",
        "prompt_text": "Write a Tcl function to find the smallest power of 2 greater than or equal to n.",
        "prompt_explain": "Write a Tcl function to find the smallest power of 2 greater than or equal to n.\n>>> next_Power_Of_2 0\n1\n>>> next_Power_Of_2 5\n8\n>>> next_Power_Of_2 17\n32",
        "func_title": "proc next_Power_Of_2 {n}"
    },
    {
        "prompt": "# Write a function to calculate the nth pell number.\n# >>> get_pell 4\n# 12\nproc get_pell {n} {",
        "canonical_solution": "    if {$n <= 2} {\n        return $n\n    }\n    set a 1\n    set b 2\n    for {set i 3} {$i <= $n} {incr i} {\n        set c [expr {2 * $b + $a}]\n        set a $b\n        set b $c\n    }\n    return $b\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_pell 4] == 12}\nassert {[get_pell 7] == 169}\nassert {[get_pell 8] == 408}",
        "declaration": "proc get_pell {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_pell 4] == 12}",
        "prompt_text": "Write a function to calculate the nth pell number.",
        "prompt_explain": "Write a function to calculate the nth pell number.\n>>> get_pell 4\n12",
        "func_title": "proc get_pell {n}"
    },
    {
        "prompt": "# Write a function to find the perimeter of a pentagon.\n# >>> perimeter_pentagon 5\n# 25\nproc perimeter_pentagon {a} {",
        "canonical_solution": "    set perimeter [expr {5 * $a}]\n    return $perimeter\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[perimeter_pentagon 5] == 25}\nassert {[perimeter_pentagon 10] == 50}\nassert {[perimeter_pentagon 15] == 75}",
        "declaration": "proc perimeter_pentagon {a} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[perimeter_pentagon 5] == 25}",
        "prompt_text": "Write a function to find the perimeter of a pentagon.",
        "prompt_explain": "Write a function to find the perimeter of a pentagon.\n>>> perimeter_pentagon 5\n25",
        "func_title": "proc perimeter_pentagon {a}"
    },
    {
        "prompt": "# Write a function to find the perimeter of a triangle.\n# >>> perimeter_triangle 10 20 30\n# 60\nproc perimeter_triangle {a b c} {",
        "canonical_solution": "    set perimeter [expr {$a + $b + $c}]\n    return $perimeter\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[perimeter_triangle 10 20 30] == 60}\nassert {[perimeter_triangle 3 4 5] == 12}\nassert {[perimeter_triangle 25 35 45] == 105}",
        "declaration": "proc perimeter_triangle {a b c} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[perimeter_triangle 10 20 30] == 60}",
        "prompt_text": "Write a function to find the perimeter of a triangle.",
        "prompt_explain": "Write a function to find the perimeter of a triangle.\n>>> perimeter_triangle 10 20 30\n60",
        "func_title": "proc perimeter_triangle {a b c}"
    },
    {
        "prompt": "# Write a function to find if the given number is a keith number or not.\n# A Keith number is a number that appears in a special sequence generated using its digits.\n# >>> is_num_keith 14\n# 1\n# >>> is_num_keith 12\n# 0\nproc is_num_keith {x} {",
        "canonical_solution": "    set terms {}\n    set temp $x\n    set n 0\n    while {$temp > 0} {\n        lappend terms [expr {$temp % 10}]\n        set temp [expr {$temp / 10}]\n        incr n\n    }\n    set terms [lreverse $terms]\n    set next_term 0\n    set i $n\n    while {$next_term < $x} {\n        set next_term 0\n        for {set j 1} {$j <= $n} {incr j} {\n            set next_term [expr {$next_term + [lindex $terms [expr {$i - $j}]]}]\n        }\n        lappend terms $next_term\n        incr i\n    }\n    return [expr {$next_term == $x ? 1 : 0}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_num_keith 14] == 1}\nassert {[is_num_keith 12] == 0}\nassert {[is_num_keith 197] == 1}",
        "declaration": "proc is_num_keith {x} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_num_keith 14] == 1}",
        "prompt_text": "Write a function to find if the given number is a keith number or not.",
        "prompt_explain": "Write a function to find if the given number is a keith number or not.\nA Keith number is a number that appears in a special sequence generated using its digits.\n>>> is_num_keith 14\n1\n>>> is_num_keith 12\n0",
        "func_title": "proc is_num_keith {x}"
    },
    {
        "prompt": "# Given two sequences, find the length of the longest common subsequence.\n# >>> longest_common_subsequence \"AGGTAB\" \"GXTXAYB\"\n# 4\nproc longest_common_subsequence {X Y} {",
        "canonical_solution": "    set m [string length $X]\n    set n [string length $Y]\n    if {$m == 0 || $n == 0} {\n        return 0\n    } elseif {[string index $X [expr {$m - 1}]] == [string index $Y [expr {$n - 1}]]} {\n        return [expr {1 + [longest_common_subsequence [string range $X 0 [expr {$m - 2}]] [string range $Y 0 [expr {$n - 2}]]]}]\n    } else {\n        return [expr {max([longest_common_subsequence $X [string range $Y 0 [expr {$n - 2}]]], [longest_common_subsequence [string range $X 0 [expr {$m - 2}]] $Y])}]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[longest_common_subsequence \"AGGTAB\" \"GXTXAYB\"] == 4}\nassert {[longest_common_subsequence \"ABCDGH\" \"AEDFHR\"] == 3}\nassert {[longest_common_subsequence \"AXYT\" \"AYZX\"] == 2}",
        "declaration": "proc longest_common_subsequence {X Y} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[longest_common_subsequence \"AGGTAB\" \"GXTXAYB\"] == 4}",
        "prompt_text": "Given two sequences, find the length of the longest common subsequence.",
        "prompt_explain": "Given two sequences, find the length of the longest common subsequence.\n>>> longest_common_subsequence \"AGGTAB\" \"GXTXAYB\"\n4",
        "func_title": "proc longest_common_subsequence {X Y}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the given number can be represented by product of two squares or not.\n# >>> prod_Square 25\n# 0\n# >>> prod_Square 30\n# 0\n# >>> prod_Square 16\n# 1\nproc prod_Square {n} {",
        "canonical_solution": "    for {set i 2} {$i <= $n} {incr i} {\n        if {$i * $i < ($n + 1)} {\n            for {set j 2} {$j <= $n} {incr j} {\n                if {($i * $i * $j * $j) == $n} {\n                    return 1\n                }\n            }\n        }\n    }\n    return 0\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[prod_Square 25] == 0}\nassert {[prod_Square 30] == 0}\nassert {[prod_Square 16] == 1}",
        "declaration": "proc prod_Square {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[prod_Square 25] == 0}",
        "prompt_text": "Write a Tcl function to check whether the given number can be represented by product of two squares or not.",
        "prompt_explain": "Write a Tcl function to check whether the given number can be represented by product of two squares or not.\n>>> prod_Square 25\n0\n>>> prod_Square 30\n0\n>>> prod_Square 16\n1",
        "func_title": "proc prod_Square {n}"
    },
    {
        "prompt": "# Given the coordinates of two opposite corners of a square, count the number of integral coordinates that lie inside the square.\n# >>> count_Intgral_Points 1 1 4 4\n# 4\nproc count_Intgral_Points {x1 y1 x2 y2} {",
        "canonical_solution": "    return [expr {($y2 - $y1 - 1) * ($x2 - $x1 - 1)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Intgral_Points 1 1 4 4] == 4}\nassert {[count_Intgral_Points 1 2 1 2] == 1}\nassert {[count_Intgral_Points 4 2 6 4] == 1}",
        "declaration": "proc count_Intgral_Points {x1 y1 x2 y2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Intgral_Points 1 1 4 4] == 4}",
        "prompt_text": "Given the coordinates of two opposite corners of a square, count the number of integral coordinates that lie inside the square.",
        "prompt_explain": "Given the coordinates of two opposite corners of a square, count the number of integral coordinates that lie inside the square.\n>>> count_Intgral_Points 1 1 4 4\n4",
        "func_title": "proc count_Intgral_Points {x1 y1 x2 y2}"
    },
    {
        "prompt": "# Given a month name, check whether the given month name contains 30 days or not.\n# >>> check_monthname \"February\"\n# 0\n# >>> check_monthname \"June\"\n# 1\nproc check_monthname {monthname} {",
        "canonical_solution": "    if {$monthname eq \"April\" || $monthname eq \"June\" || $monthname eq \"September\" || $monthname eq \"November\"} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_monthname \"February\"] == 0}\nassert {[check_monthname \"June\"] == 1}\nassert {[check_monthname \"April\"] == 1}",
        "declaration": "proc check_monthname {monthname} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_monthname \"February\"] == 0}",
        "prompt_text": "Given a month name, check whether the given month name contains 30 days or not.",
        "prompt_explain": "Given a month name, check whether the given month name contains 30 days or not.\n>>> check_monthname \"February\"\n0\n>>> check_monthname \"June\"\n1",
        "func_title": "proc check_monthname {monthname}"
    },
    {
        "prompt": "# Write a function to find the largest triangle that can be inscribed in an ellipse.\n# >>> largest_triangle 4 2\n# 10.392304845413264\nproc largest_triangle {a b} {",
        "canonical_solution": "    if {$a < 0 || $b < 0} {\n        return -1\n    }\n    set area [expr {(3 * sqrt(3) * pow($a, 2)) / (4 * $b)}]\n    return $area\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[largest_triangle 4 2] == 10.392304845413264}\nassert {[largest_triangle 5 7] == 4.639421805988064}\nassert {[largest_triangle 9 1] == 105.2220865598093}",
        "declaration": "proc largest_triangle {a b} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[largest_triangle 4 2] == 10.392304845413264}",
        "prompt_text": "Write a function to find the largest triangle that can be inscribed in an ellipse.",
        "prompt_explain": "Write a function to find the largest triangle that can be inscribed in an ellipse.\n>>> largest_triangle 4 2\n10.392304845413264",
        "func_title": "proc largest_triangle {a b}"
    },
    {
        "prompt": "# Write a Tcl function to find the highest power of 2 less than or equal to a given number.\n# >>> highest_Power_of_2 10\n# 8\nproc highest_Power_of_2 {n} {",
        "canonical_solution": "    set res 0\n    for {set i $n} {$i > 0} {incr i -1} {\n        if {($i & ($i - 1)) == 0} {\n            set res $i\n            break\n        }\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[highest_Power_of_2 10] == 8}\nassert {[highest_Power_of_2 19] == 16}\nassert {[highest_Power_of_2 32] == 32}",
        "declaration": "proc highest_Power_of_2 {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[highest_Power_of_2 10] == 8}",
        "prompt_text": "Write a Tcl function to find the highest power of 2 less than or equal to a given number.",
        "prompt_explain": "Write a Tcl function to find the highest power of 2 less than or equal to a given number.\n>>> highest_Power_of_2 10\n8",
        "func_title": "proc highest_Power_of_2 {n}"
    },
    {
        "prompt": "# Given a list of integers, return a new list containing the index positions of all maximum values in the list.\n# >>> position_max {12 33 23 10 67 89 45 667 23 12 11 10 54}\n# {7}\nproc position_max {list1} {",
        "canonical_solution": "    set max_val [lindex $list1 0]\n    set max_result {}\n    foreach i [lrange $list1 1 end] {\n        if {$i > $max_val} {\n            set max_val $i\n            set max_result {}\n        }\n        if {$i == $max_val} {\n            lappend max_result [expr {[lsearch -exact $list1 $i] + [llength $max_result]}]\n        }\n    }\n    return $max_result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[position_max {12 33 23 10 67 89 45 667 23 12 11 10 54}] eq {7}}\nassert {[position_max {1 2 2 2 4 4 4 5 5 5 5}] eq {7 8 9 10}}\nassert {[position_max {2 1 5 6 8 3 4 9 10 11 8 12}] eq {11}}",
        "declaration": "proc position_max {list1} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[position_max {12 33 23 10 67 89 45 667 23 12 11 10 54}] eq {7}}",
        "prompt_text": "Given a list of integers, return a new list containing the index positions of all maximum values in the list.",
        "prompt_explain": "Given a list of integers, return a new list containing the index positions of all maximum values in the list.\n>>> position_max {12 33 23 10 67 89 45 667 23 12 11 10 54}\n{7}",
        "func_title": "proc position_max {list1}"
    },
    {
        "prompt": "# Given a list, check whether the elements in the list are the same or not.\n# >>> chkList {one one one}\n# 1\nproc chkList {lst} {",
        "canonical_solution": "    set unique_elements [lsort -unique $lst]\n    if {[llength $unique_elements] == 1} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[chkList {one one one}] == 1}\nassert {[chkList {one Two Three}] == 0}\nassert {[chkList {bigdata python Django}] == 0}",
        "declaration": "proc chkList {lst} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[chkList {one one one}] == 1}",
        "prompt_text": "Given a list, check whether the elements in the list are the same or not.",
        "prompt_explain": "Given a list, check whether the elements in the list are the same or not.\n>>> chkList {one one one}\n1",
        "func_title": "proc chkList {lst}"
    },
    {
        "prompt": "# Write a Tcl function to find the hamming distance between given two integers.\n# >>> hamming_Distance 4 8\n# 2\nproc hamming_Distance {n1 n2} {",
        "canonical_solution": "    set x [expr {$n1 ^ $n2}]\n    set setBits 0\n    while {$x > 0} {\n        incr setBits [expr {$x & 1}]\n        set x [expr {$x >> 1}]\n    }\n    return $setBits\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[hamming_Distance 4 8] == 2}\nassert {[hamming_Distance 2 4] == 2}\nassert {[hamming_Distance 1 2] == 2}",
        "declaration": "proc hamming_Distance {n1 n2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[hamming_Distance 4 8] == 2}",
        "prompt_text": "Write a Tcl function to find the hamming distance between given two integers.",
        "prompt_explain": "Write a Tcl function to find the hamming distance between given two integers.\n>>> hamming_Distance 4 8\n2",
        "func_title": "proc hamming_Distance {n1 n2}"
    },
    {
        "prompt": "# Write a Tcl function to count the occurrence of a given character in a string.\n# >>> count \"abcc\" \"c\"\n# 2\nproc count {s c} {",
        "canonical_solution": "    set res 0\n    for {set i 0} {$i < [string length $s]} {incr i} {\n        if {[string index $s $i] eq $c} {\n            incr res\n        }\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count \"abcc\" \"c\"] == 2}\nassert {[count \"ababca\" \"a\"] == 3}\nassert {[count \"mnmm0pm\" \"m\"] == 4}",
        "declaration": "proc count {s c} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count \"abcc\" \"c\"] == 2}",
        "prompt_text": "Write a Tcl function to count the occurrence of a given character in a string.",
        "prompt_explain": "Write a Tcl function to count the occurrence of a given character in a string.\n>>> count \"abcc\" \"c\"\n2",
        "func_title": "proc count {s c}"
    },
    {
        "prompt": "# Given a string, find the length of the longest repeating subsequence such that the two subsequences dont have same string characters at same positions.\n# >>> find_longest_repeating_subseq \"AABEBCDD\"\n# 3\nproc find_longest_repeating_subseq {str} {",
        "canonical_solution": "    set n [string length $str]\n    set dp [lrepeat [expr {$n + 1}] [lrepeat [expr {$n + 1}] 0]]\n    for {set i 1} {$i <= $n} {incr i} {\n        for {set j 1} {$j <= $n} {incr j} {\n            if {[string index $str [expr {$i - 1}]] == [string index $str [expr {$j - 1}]] && $i != $j} {\n                lset dp $i $j [expr {1 + [lindex $dp [expr {$i - 1}] [expr {$j - 1}]]}]\n            } else {\n                lset dp $i $j [expr {max([lindex $dp $i [expr {$j - 1}]], [lindex $dp [expr {$i - 1}] $j])}]\n            }\n        }\n    }\n    return [lindex $dp $n $n]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_longest_repeating_subseq \"AABEBCDD\"] == 3}\nassert {[find_longest_repeating_subseq \"aabb\"] == 2}\nassert {[find_longest_repeating_subseq \"aab\"] == 1}",
        "declaration": "proc find_longest_repeating_subseq {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_longest_repeating_subseq \"AABEBCDD\"] == 3}",
        "prompt_text": "Given a string, find the length of the longest repeating subsequence such that the two subsequences dont have same string characters at same positions.",
        "prompt_explain": "Given a string, find the length of the longest repeating subsequence such that the two subsequences dont have same string characters at same positions.\n>>> find_longest_repeating_subseq \"AABEBCDD\"\n3",
        "func_title": "proc find_longest_repeating_subseq {str}"
    },
    {
        "prompt": "# Write a function to check that the given string contains only a certain set of characters (in this case a-z, A-Z, and 0-9) by using regex.\n# >>> is_allowed_specific_char \"ABCDEFabcdef123450\"\n# 1\n# >>> is_allowed_specific_char \"*&%@#!}{\"\n# 0\nproc is_allowed_specific_char {string} {",
        "canonical_solution": "    if {[regexp {[^a-zA-Z0-9]} $string]} {\n        return 0\n    } else {\n        return 1\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_allowed_specific_char \"ABCDEFabcdef123450\"] == 1}\nassert {[is_allowed_specific_char \"*&%@#!}{\"] == 0}\nassert {[is_allowed_specific_char \"HELLOhowareyou98765\"] == 1}",
        "declaration": "proc is_allowed_specific_char {string} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_allowed_specific_char \"ABCDEFabcdef123450\"] == 1}",
        "prompt_text": "Write a function to check that the given string contains only a certain set of characters (in this case a-z, A-Z, and 0-9) by using regex.",
        "prompt_explain": "Write a function to check that the given string contains only a certain set of characters (in this case a-z, A-Z, and 0-9) by using regex.\n>>> is_allowed_specific_char \"ABCDEFabcdef123450\"\n1\n>>> is_allowed_specific_char \"*&%@#!}{\"\n0",
        "func_title": "proc is_allowed_specific_char {string}"
    },
    {
        "prompt": "# Write a Tcl function to count numbers whose 0th and nth bits are set.\n# >>> count_Num 2\n# 1\n# >>> count_Num 3\n# 2\n# >>> count_Num 1\n# 1\nproc count_Num {n} {",
        "canonical_solution": "    if {$n == 1} {\n        return 1\n    }\n    set count [expr {pow(2, $n - 2)}]\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Num 2] == 1}\nassert {[count_Num 3] == 2}\nassert {[count_Num 1] == 1}",
        "declaration": "proc count_Num {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Num 2] == 1}",
        "prompt_text": "Write a Tcl function to count numbers whose 0th and nth bits are set.",
        "prompt_explain": "Write a Tcl function to count numbers whose 0th and nth bits are set.\n>>> count_Num 2\n1\n>>> count_Num 3\n2\n>>> count_Num 1\n1",
        "func_title": "proc count_Num {n}"
    },
    {
        "prompt": "# Write a function to convert radians to degrees.\n# >>> degree_radian 90\n# 5156.620156177409\nproc degree_radian {radian} {",
        "canonical_solution": "    set degree [expr {$radian * (180 / 3.141592653589793)}]\n    return $degree\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[degree_radian 90] == 5156.620156177409}\nassert {[degree_radian 60] == 3437.746770784939}\nassert {[degree_radian 120] == 6875.493541569878}",
        "declaration": "proc degree_radian {radian} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[degree_radian 90] == 5156.620156177409}",
        "prompt_text": "Write a function to convert radians to degrees.",
        "prompt_explain": "Write a function to convert radians to degrees.\n>>> degree_radian 90\n5156.620156177409",
        "func_title": "proc degree_radian {radian}"
    },
    {
        "prompt": "# Write a function to check if a nested list is a subset of another nested list.\n# >>> check_subset_list {1 2 3 4 5 6 7 8 9 10 11 12 13 14} {{12 18 23 25 45} {7 11 19 24 28} {1 5 8 18 15 16}}\n# 0\nproc check_subset_list {list1 list2} {",
        "canonical_solution": "    set exist 1\n    foreach sublist2 $list2 {\n        set found 0\n        foreach sublist1 $list1 {\n            if {$sublist2 eq $sublist1} {\n                set found 1\n                break\n            }\n        }\n        if {!$found} {\n            set exist 0\n            break\n        }\n    }\n    return $exist\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_subset_list {1 2 3 4 5 6 7 8 9 10 11 12 13 14} {{12 18 23 25 45} {7 11 19 24 28} {1 5 8 18 15 16}}] == 0}\nassert {[check_subset_list {{2 3 1} {4 5} {6 8}} {{4 5} {6 8}}] == 1}\nassert {[check_subset_list {{a b} {e} {c d}} {{g}}] == 0}",
        "declaration": "proc check_subset_list {list1 list2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_subset_list {1 2 3 4 5 6 7 8 9 10 11 12 13 14} {{12 18 23 25 45} {7 11 19 24 28} {1 5 8 18 15 16}}] == 0}",
        "prompt_text": "Write a function to check if a nested list is a subset of another nested list.",
        "prompt_explain": "Write a function to check if a nested list is a subset of another nested list.\n>>> check_subset_list {1 2 3 4 5 6 7 8 9 10 11 12 13 14} {{12 18 23 25 45} {7 11 19 24 28} {1 5 8 18 15 16}}\n0",
        "func_title": "proc check_subset_list {list1 list2}"
    },
    {
        "prompt": "# Given a tuple, check if all the elements in the tuple have the same data type or not.\n# >>> check_type {5 6 7 3 5 6}\n# 1\n# >>> check_type {1 2 \"4\"}\n# 0\nproc check_type {test_tuple} {",
        "canonical_solution": "    set res 1\n    set first_type [lindex $test_tuple 0]\n    foreach ele $test_tuple {\n        if {[string is integer -strict $first_type] != [string is integer -strict $ele]} {\n            set res 0\n            break\n        }\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_type {5 6 7 3 5 6}] == 1}\nassert {[check_type {1 2 \"4\"}] == 0}\nassert {[check_type {3 2 1 4 5}] == 1}",
        "declaration": "proc check_type {test_tuple} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_type {5 6 7 3 5 6}] == 1}",
        "prompt_text": "Given a tuple, check if all the elements in the tuple have the same data type or not.",
        "prompt_explain": "Given a tuple, check if all the elements in the tuple have the same data type or not.\n>>> check_type {5 6 7 3 5 6}\n1\n>>> check_type {1 2 \"4\"}\n0",
        "func_title": "proc check_type {test_tuple}"
    },
    {
        "prompt": "# Given a sorted array of integers, check if a given element is the majority element. A majority element in a sorted array is an element that appears more than n/2 times.\n# >>> is_majority {1 2 3 3 3 3 10} 7 3\n# 1\nproc is_majority {arr n x} {",
        "canonical_solution": "    set i [binary_search $arr 0 [expr {$n - 1}] $x]\n    if {$i == -1} {\n        return 0\n    }\n    if {[expr {$i + $n / 2}] <= [expr {$n - 1}] && [lindex $arr [expr {$i + $n / 2}]] == $x} {\n        return 1\n    } else {\n        return 0\n    }\n}\nproc binary_search {arr low high x} {\n    if {$high >= $low} {\n        set mid [expr {($low + $high) / 2}]\n        if {($mid == 0 || $x > [lindex $arr [expr {$mid - 1}]]) && [lindex $arr $mid] == $x} {\n            return $mid\n        } elseif {$x > [lindex $arr $mid]} {\n            return [binary_search $arr [expr {$mid + 1}] $high $x]\n        } else {\n            return [binary_search $arr $low [expr {$mid - 1}] $x]\n        }\n    }\n    return -1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_majority {1 2 3 3 3 3 10} 7 3] == 1}\nassert {[is_majority {1 1 2 4 4 4 6 6} 8 4] == 0}\nassert {[is_majority {1 1 1 2 2} 5 1] == 1}",
        "declaration": "proc is_majority {arr n x} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_majority {1 2 3 3 3 3 10} 7 3] == 1}",
        "prompt_text": "Given a sorted array of integers, check if a given element is the majority element. A majority element in a sorted array is an element that appears more than n/2 times.",
        "prompt_explain": "Given a sorted array of integers, check if a given element is the majority element. A majority element in a sorted array is an element that appears more than n/2 times.\n>>> is_majority {1 2 3 3 3 3 10} 7 3\n1",
        "func_title": "proc is_majority {arr n x}"
    },
    {
        "prompt": "# Write a Tcl function to count set bits of a given number.\n# >>> count_Set_Bits 2\n# 1\nproc count_Set_Bits {n} {",
        "canonical_solution": "    set count 0\n    while {$n != 0} {\n        set count [expr {$count + ($n & 1)}]\n        set n [expr {$n >> 1}]\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Set_Bits 2] == 1}\nassert {[count_Set_Bits 4] == 1}\nassert {[count_Set_Bits 6] == 2}",
        "declaration": "proc count_Set_Bits {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Set_Bits 2] == 1}",
        "prompt_text": "Write a Tcl function to count set bits of a given number.",
        "prompt_explain": "Write a Tcl function to count set bits of a given number.\n>>> count_Set_Bits 2\n1",
        "func_title": "proc count_Set_Bits {n}"
    },
    {
        "prompt": "# Given a sorted and rotated array, find the minimum element.\n# >>> find_Min {3 4 5 1 2} 0 4\n# 1\nproc find_Min {arr low high} {",
        "canonical_solution": "    while {$low < $high} {\n        set mid [expr {$low + ($high - $low) / 2}]\n        if {[lindex $arr $mid] == [lindex $arr $high]} {\n            incr high -1\n        } elseif {[lindex $arr $mid] > [lindex $arr $high]} {\n            set low [expr {$mid + 1}]\n        } else {\n            set high $mid\n        }\n    }\n    return [lindex $arr $high]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Min {1 2 3 4 5} 0 4] == 1}\nassert {[find_Min {4 6 8} 0 2] == 4}\nassert {[find_Min {2 3 5 7 9} 0 4] == 2}",
        "declaration": "proc find_Min {arr low high} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Min {1 2 3 4 5} 0 4] == 1}",
        "prompt_text": "Given a sorted and rotated array, find the minimum element.",
        "prompt_explain": "Given a sorted and rotated array, find the minimum element.\n>>> find_Min {3 4 5 1 2} 0 4\n1",
        "func_title": "proc find_Min {arr low high}"
    },
    {
        "prompt": "# Write a function to find minimum of three numbers.\n# >>> min_of_three 10 20 0\n# 0\nproc min_of_three {a b c} {",
        "canonical_solution": "    if {$a <= $b && $a <= $c} {\n        return $a\n    } elseif {$b <= $a && $b <= $c} {\n        return $b\n    } else {\n        return $c\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_of_three 10 20 0] == 0}\nassert {[min_of_three 19 15 18] == 15}\nassert {[min_of_three -10 -20 -30] == -30}",
        "declaration": "proc min_of_three {a b c} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_of_three 10 20 0] == 0}",
        "prompt_text": "Write a function to find minimum of three numbers.",
        "prompt_explain": "Write a function to find minimum of three numbers.\n>>> min_of_three 10 20 0\n0",
        "func_title": "proc min_of_three {a b c}"
    },
    {
        "prompt": "# Write a function to find the lateral surface area of a cylinder.\n# >>> lateralsuface_cylinder 10 5\n# 314.15000000000003\nproc lateralsuface_cylinder {r h} {",
        "canonical_solution": "    set lateralsurface [expr {2 * 3.1415 * $r * $h}]\n    return $lateralsurface\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[lateralsuface_cylinder 10 5] == 314.15000000000003}\nassert {[lateralsuface_cylinder 4 5] == 125.66000000000001}\nassert {[lateralsuface_cylinder 4 10] == 251.32000000000002}",
        "declaration": "proc lateralsuface_cylinder {r h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[lateralsuface_cylinder 10 5] == 314.15000000000003}",
        "prompt_text": "Write a function to find the lateral surface area of a cylinder.",
        "prompt_explain": "Write a function to find the lateral surface area of a cylinder.\n>>> lateralsuface_cylinder 10 5\n314.15000000000003",
        "func_title": "proc lateralsuface_cylinder {r h}"
    },
    {
        "prompt": "# Write a function to find the volume of a cube.\n# >>> volume_cube 3\n# 27\nproc volume_cube {l} {",
        "canonical_solution": "    set volume [expr {$l * $l * $l}]\n    return $volume\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_cube 3] == 27}\nassert {[volume_cube 2] == 8}\nassert {[volume_cube 5] == 125}",
        "declaration": "proc volume_cube {l} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_cube 3] == 27}",
        "prompt_text": "Write a function to find the volume of a cube.",
        "prompt_explain": "Write a function to find the volume of a cube.\n>>> volume_cube 3\n27",
        "func_title": "proc volume_cube {l}"
    },
    {
        "prompt": "# Write a Tcl function to set all even bits of a given number.\n# >>> even_bit_set_number 10\n# 10\n# >>> even_bit_set_number 20\n# 30\n# >>> even_bit_set_number 30\n# 30\nproc even_bit_set_number {n} {",
        "canonical_solution": "    set count 0\n    set res 0\n    set temp $n\n    while {$temp > 0} {\n        if {$count % 2 == 1} {\n            set res [expr {$res | (1 << $count)}]\n        }\n        incr count\n        set temp [expr {$temp >> 1}]\n    }\n    return [expr {$n | $res}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_bit_set_number 10] == 10}\nassert {[even_bit_set_number 20] == 30}\nassert {[even_bit_set_number 30] == 30}",
        "declaration": "proc even_bit_set_number {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_bit_set_number 10] == 10}",
        "prompt_text": "Write a Tcl function to set all even bits of a given number.",
        "prompt_explain": "Write a Tcl function to set all even bits of a given number.\n>>> even_bit_set_number 10\n10\n>>> even_bit_set_number 20\n30\n>>> even_bit_set_number 30\n30",
        "func_title": "proc even_bit_set_number {n}"
    },
    {
        "prompt": "# Write a Tcl function to find the next perfect square greater than a given number.\n# >>> next_Perfect_Square 35\n# 36\nproc next_Perfect_Square {N} {",
        "canonical_solution": "    set nextN [expr {int(sqrt($N)) + 1}]\n    return [expr {$nextN * $nextN}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[next_Perfect_Square 35] == 36}\nassert {[next_Perfect_Square 6] == 9}\nassert {[next_Perfect_Square 9] == 16}",
        "declaration": "proc next_Perfect_Square {N} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[next_Perfect_Square 35] == 36}",
        "prompt_text": "Write a Tcl function to find the next perfect square greater than a given number.",
        "prompt_explain": "Write a Tcl function to find the next perfect square greater than a given number.\n>>> next_Perfect_Square 35\n36",
        "func_title": "proc next_Perfect_Square {N}"
    },
    {
        "prompt": "# Given a list of integers, find the maximum sum of a bi-tonic sub-sequence.\n# >>> max_sum {1 15 51 45 33 100 12 18 9}\n# 194\nproc max_sum {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set MSIBS $arr\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j 0} {$j < $i} {incr j} {\n            if {[lindex $arr $i] > [lindex $arr $j] && [lindex $MSIBS $i] < [expr {[lindex $MSIBS $j] + [lindex $arr $i]}]} {\n                lset MSIBS $i [expr {[lindex $MSIBS $j] + [lindex $arr $i]}]\n            }\n        }\n    }\n    set MSDBS $arr\n    for {set i [expr {$n - 1}]} {$i >= 0} {incr i -1} {\n        for {set j [expr {$n - 1}]} {$j > $i} {incr j -1} {\n            if {[lindex $arr $i] > [lindex $arr $j] && [lindex $MSDBS $i] < [expr {[lindex $MSDBS $j] + [lindex $arr $i]}]} {\n                lset MSDBS $i [expr {[lindex $MSDBS $j] + [lindex $arr $i]}]\n            }\n        }\n    }\n    set max_sum [expr {-(1 << 31)}]\n    for {set i 0} {$i < $n} {incr i} {\n        set sum [expr {[lindex $MSIBS $i] + [lindex $MSDBS $i] - [lindex $arr $i]}]\n        if {$sum > $max_sum} {\n            set max_sum $sum\n        }\n    }\n    return $max_sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sum {1 15 51 45 33 100 12 18 9}] == 194}\nassert {[max_sum {80 60 30 40 20 10}] == 210}\nassert {[max_sum {2 3 14 16 21 23 29 30}] == 138}",
        "declaration": "proc max_sum {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sum {1 15 51 45 33 100 12 18 9}] == 194}",
        "prompt_text": "Given a list of integers, find the maximum sum of a bi-tonic sub-sequence.",
        "prompt_explain": "Given a list of integers, find the maximum sum of a bi-tonic sub-sequence.\n>>> max_sum {1 15 51 45 33 100 12 18 9}\n194",
        "func_title": "proc max_sum {arr}"
    },
    {
        "prompt": "# Write a function for computing square roots using the babylonian method.\n# >>> babylonian_squareroot 10\n# 3.162277660168379\nproc babylonian_squareroot {number} {",
        "canonical_solution": "    if {$number == 0} {\n        return 0\n    }\n    set g [expr {$number / 2.0}]\n    set g2 [expr {$g + 1}]\n    while {$g != $g2} {\n        set n [expr {$number / $g}]\n        set g2 $g\n        set g [expr {($g + $n) / 2}]\n    }\n    return $g\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[babylonian_squareroot 10] == 3.162277660168379}\nassert {[babylonian_squareroot 2] == 1.414213562373095}\nassert {[babylonian_squareroot 9] == 3.0}",
        "declaration": "proc babylonian_squareroot {number} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[babylonian_squareroot 10] == 3.162277660168379}",
        "prompt_text": "Write a function for computing square roots using the babylonian method.",
        "prompt_explain": "Write a function for computing square roots using the babylonian method.\n>>> babylonian_squareroot 10\n3.162277660168379",
        "func_title": "proc babylonian_squareroot {number}"
    },
    {
        "prompt": "# Write a function to calculate the harmonic sum of n-1.\n# >>> harmonic_sum 7\n# 2.5928571428571425\nproc harmonic_sum {n} {",
        "canonical_solution": "    if {$n < 2} {\n        return 1\n    } else {\n        return [expr {1.0 / $n + [harmonic_sum [expr {$n - 1}]]}]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[harmonic_sum 7] == 2.5928571428571425}\nassert {[harmonic_sum 4] == 2.083333333333333}\nassert {[harmonic_sum 19] == 3.547739657143682}",
        "declaration": "proc harmonic_sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[harmonic_sum 7] == 2.5928571428571425}",
        "prompt_text": "Write a function to calculate the harmonic sum of n-1.",
        "prompt_explain": "Write a function to calculate the harmonic sum of n-1.\n>>> harmonic_sum 7\n2.5928571428571425",
        "func_title": "proc harmonic_sum {n}"
    },
    {
        "prompt": "# Given a non-negative number, return the count of prime numbers less than that number.\n# >>> count_Primes_nums 5\n# 2\nproc count_Primes_nums {n} {",
        "canonical_solution": "    set ctr 0\n    for {set num 0} {$num < $n} {incr num} {\n        if {$num <= 1} {\n            continue\n        }\n        set is_prime 1\n        for {set i 2} {$i < $num} {incr i} {\n            if {[expr {$num % $i}] == 0} {\n                set is_prime 0\n                break\n            }\n        }\n        if {$is_prime} {\n            incr ctr\n        }\n    }\n    return $ctr\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Primes_nums 5] == 2}\nassert {[count_Primes_nums 10] == 4}\nassert {[count_Primes_nums 100] == 25}",
        "declaration": "proc count_Primes_nums {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Primes_nums 5] == 2}",
        "prompt_text": "Given a non-negative number, return the count of prime numbers less than that number.",
        "prompt_explain": "Given a non-negative number, return the count of prime numbers less than that number.\n>>> count_Primes_nums 5\n2",
        "func_title": "proc count_Primes_nums {n}"
    },
    {
        "prompt": "# Write a function to calculate a dog's age in dog's years.\n# >>> dog_age 12\n# 61\n# >>> dog_age 15\n# 73\n# >>> dog_age 24\n# 109\nproc dog_age {h_age} {",
        "canonical_solution": "    if {$h_age < 0} {\n        exit\n    } elseif {$h_age <= 2} {\n        set d_age [expr {$h_age * 10.5}]\n    } else {\n        set d_age [expr {21 + ($h_age - 2) * 4}]\n    }\n    return $d_age\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[dog_age 12] == 61}\nassert {[dog_age 15] == 73}\nassert {[dog_age 24] == 109}",
        "declaration": "proc dog_age {h_age} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[dog_age 12] == 61}",
        "prompt_text": "Write a function to calculate a dog's age in dog's years.",
        "prompt_explain": "Write a function to calculate a dog's age in dog's years.\n>>> dog_age 12\n61\n>>> dog_age 15\n73\n>>> dog_age 24\n109",
        "func_title": "proc dog_age {h_age}"
    },
    {
        "prompt": "# Write a function to find the lateral surface area of a cube.\n# >>> lateralsurface_cube 5\n# 100\nproc lateralsurface_cube {l} {",
        "canonical_solution": "    set LSA [expr {4 * ($l * $l)}]\n    return $LSA\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[lateralsurface_cube 5] == 100}\nassert {[lateralsurface_cube 9] == 324}\nassert {[lateralsurface_cube 10] == 400}",
        "declaration": "proc lateralsurface_cube {l} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[lateralsurface_cube 5] == 100}",
        "prompt_text": "Write a function to find the lateral surface area of a cube.",
        "prompt_explain": "Write a function to find the lateral surface area of a cube.\n>>> lateralsurface_cube 5\n100",
        "func_title": "proc lateralsurface_cube {l}"
    },
    {
        "prompt": "# Write a Tcl function to find the sum of fifth power of first n even natural numbers.\n# >>> even_Power_Sum 2\n# 1056\nproc even_Power_Sum {n} {",
        "canonical_solution": "    set sum 0\n    for {set i 1} {$i <= $n} {incr i} {\n        set j [expr {2 * $i}]\n        set sum [expr {$sum + pow($j, 5)}]\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_Power_Sum 2] == 1056}\nassert {[even_Power_Sum 3] == 8832}\nassert {[even_Power_Sum 1] == 32}",
        "declaration": "proc even_Power_Sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_Power_Sum 2] == 1056}",
        "prompt_text": "Write a Tcl function to find the sum of fifth power of first n even natural numbers.",
        "prompt_explain": "Write a Tcl function to find the sum of fifth power of first n even natural numbers.\n>>> even_Power_Sum 2\n1056",
        "func_title": "proc even_Power_Sum {n}"
    },
    {
        "prompt": "# Given two tuples of integers, return a new tuple with the elements of the first tuple subtracted by the corresponding elements of the second tuple.\n# >>> substract_elements {10 4 5} {2 5 18}\n# {8 -1 -13}\nproc substract_elements {test_tup1 test_tup2} {",
        "canonical_solution": "    set res {}\n    foreach i $test_tup1 j $test_tup2 {\n        lappend res [expr {$i - $j}]\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[substract_elements {10 4 5} {2 5 18}] eq {8 -1 -13}}\nassert {[substract_elements {11 2 3} {24 45 16}] eq {-13 -43 -13}}\nassert {[substract_elements {7 18 9} {10 11 12}] eq {-3 7 -3}}",
        "declaration": "proc substract_elements {test_tup1 test_tup2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[substract_elements {10 4 5} {2 5 18}] eq {8 -1 -13}}",
        "prompt_text": "Given two tuples of integers, return a new tuple with the elements of the first tuple subtracted by the corresponding elements of the second tuple.",
        "prompt_explain": "Given two tuples of integers, return a new tuple with the elements of the first tuple subtracted by the corresponding elements of the second tuple.\n>>> substract_elements {10 4 5} {2 5 18}\n{8 -1 -13}",
        "func_title": "proc substract_elements {test_tup1 test_tup2}"
    },
    {
        "prompt": "# Write a Tcl function to find the sum of even index binomial coefficients.\n# >>> even_binomial_Coeff_Sum 4\n# 8\nproc even_binomial_Coeff_Sum {n} {",
        "canonical_solution": "    return [expr {1 << ($n - 1)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_binomial_Coeff_Sum 4] == 8}\nassert {[even_binomial_Coeff_Sum 6] == 32}\nassert {[even_binomial_Coeff_Sum 2] == 2}",
        "declaration": "proc even_binomial_Coeff_Sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_binomial_Coeff_Sum 4] == 8}",
        "prompt_text": "Write a Tcl function to find the sum of even index binomial coefficients.",
        "prompt_explain": "Write a Tcl function to find the sum of even index binomial coefficients.\n>>> even_binomial_Coeff_Sum 4\n8",
        "func_title": "proc even_binomial_Coeff_Sum {n}"
    },
    {
        "prompt": "# Given a list of integers, find the position of the last removed element from the given array.\n# >>> get_Position {2 5 4} 3 2\n# 2\nproc get_Position {a n m} {",
        "canonical_solution": "    for {set i 0} {$i < $n} {incr i} {\n        set a [lreplace $a $i $i [expr {[lindex $a $i] / $m + ([lindex $a $i] % $m != 0)}]]\n    }\n    set result -1\n    set maxx -1\n    for {set i [expr {$n - 1}]} {$i >= 0} {incr i -1} {\n        if {$maxx < [lindex $a $i]} {\n            set maxx [lindex $a $i]\n            set result $i\n        }\n    }\n    return [expr {$result + 1}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Position {2 5 4} 3 2] == 2}\nassert {[get_Position {4 3} 2 2] == 2}\nassert {[get_Position {1 2 3 4} 4 1] == 4}",
        "declaration": "proc get_Position {a n m} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Position {2 5 4} 3 2] == 2}",
        "prompt_text": "Given a list of integers, find the position of the last removed element from the given array.",
        "prompt_explain": "Given a list of integers, find the position of the last removed element from the given array.\n>>> get_Position {2 5 4} 3 2\n2",
        "func_title": "proc get_Position {a n m}"
    },
    {
        "prompt": "# Write a function to find the volume of a cylinder.\n# >>> volume_cylinder 10 5\n# 1570.7500000000002\nproc volume_cylinder {r h} {",
        "canonical_solution": "    set volume [expr {3.1415 * $r * $r * $h}]\n    return $volume\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_cylinder 10 5] == 1570.7500000000002}\nassert {[volume_cylinder 4 5] == 251.32000000000002}\nassert {[volume_cylinder 4 10] == 502.64000000000004}",
        "declaration": "proc volume_cylinder {r h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_cylinder 10 5] == 1570.7500000000002}",
        "prompt_text": "Write a function to find the volume of a cylinder.",
        "prompt_explain": "Write a function to find the volume of a cylinder.\n>>> volume_cylinder 10 5\n1570.7500000000002",
        "func_title": "proc volume_cylinder {r h}"
    },
    {
        "prompt": "# Given a list of integers, check if all elements are unique.\n# >>> all_unique {1 2 3}\n# 1\n# >>> all_unique {1 2 1 2}\n# 0\nproc all_unique {test_list} {",
        "canonical_solution": "    set unique_elements [lsort -unique $test_list]\n    if {[llength $test_list] == [llength $unique_elements]} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[all_unique {1 2 3}] == 1}\nassert {[all_unique {1 2 1 2}] == 0}\nassert {[all_unique {1 2 3 4 5}] == 1}",
        "declaration": "proc all_unique {test_list} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[all_unique {1 2 3}] == 1}",
        "prompt_text": "Given a list of integers, check if all elements are unique.",
        "prompt_explain": "Given a list of integers, check if all elements are unique.\n>>> all_unique {1 2 3}\n1\n>>> all_unique {1 2 1 2}\n0",
        "func_title": "proc all_unique {test_list}"
    },
    {
        "prompt": "# Given a number, check whether the frequency of each digit is less than or equal to the digit itself.\n# >>> validate 1234\n# 1\n# >>> validate 51241\n# 0\nproc validate {n} {",
        "canonical_solution": "    for {set i 0} {$i < 10} {incr i} {\n        set temp $n\n        set count 0\n        while {$temp != 0} {\n            if {[expr {$temp % 10}] == $i} {\n                incr count\n            }\n            if {$count > $i} {\n                return 0\n            }\n            set temp [expr {$temp / 10}]\n        }\n    }\n    return 1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[validate 1234] == 1}\nassert {[validate 51241] == 0}\nassert {[validate 321] == 1}",
        "declaration": "proc validate {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[validate 1234] == 1}",
        "prompt_text": "Given a number, check whether the frequency of each digit is less than or equal to the digit itself.",
        "prompt_explain": "Given a number, check whether the frequency of each digit is less than or equal to the digit itself.\n>>> validate 1234\n1\n>>> validate 51241\n0",
        "func_title": "proc validate {n}"
    },
    {
        "prompt": "# Given a list of integers and a prime number p, count the number of elements in the list that have a modular inverse under p equal to themselves.\n# >>> modular_inverse {1 6 4 5} 7\n# 2\nproc modular_inverse {arr P} {",
        "canonical_solution": "    set count 0\n    foreach element $arr {\n        if {[expr {($element * $element) % $P}] == 1} {\n            incr count\n        }\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[modular_inverse {1 6 4 5} 7] == 2}\nassert {[modular_inverse {1 3 8 12 12} 13] == 3}\nassert {[modular_inverse {2 3 4 5} 6] == 1}",
        "declaration": "proc modular_inverse {arr P} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[modular_inverse {1 6 4 5} 7] == 2}",
        "prompt_text": "Given a list of integers and a prime number p, count the number of elements in the list that have a modular inverse under p equal to themselves.",
        "prompt_explain": "Given a list of integers and a prime number p, count the number of elements in the list that have a modular inverse under p equal to themselves.\n>>> modular_inverse {1 6 4 5} 7\n2",
        "func_title": "proc modular_inverse {arr P}"
    },
    {
        "prompt": "# Given a year, calculate the number of odd days in that year.\n# >>> odd_Days 100\n# 5\nproc odd_Days {N} {",
        "canonical_solution": "    set hund1 [expr {$N / 100}]\n    set hund4 [expr {$N / 400}]\n    set leap [expr {$N >> 2}]\n    set ordd [expr {$N - $leap}]\n    if {$hund1} {\n        set ordd [expr {$ordd + $hund1}]\n        set leap [expr {$leap - $hund1}]\n    }\n    if {$hund4} {\n        set ordd [expr {$ordd - $hund4}]\n        set leap [expr {$leap + $hund4}]\n    }\n    set days [expr {$ordd + $leap * 2}]\n    set odd [expr {$days % 7}]\n    return $odd\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[odd_Days 100] == 5}\nassert {[odd_Days 50] == 6}\nassert {[odd_Days 75] == 2}",
        "declaration": "proc odd_Days {N} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[odd_Days 100] == 5}",
        "prompt_text": "Given a year, calculate the number of odd days in that year.",
        "prompt_explain": "Given a year, calculate the number of odd days in that year.\n>>> odd_Days 100\n5",
        "func_title": "proc odd_Days {N}"
    },
    {
        "prompt": "# Given a fence with n posts and k colors, write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color.\n# >>> count_no_of_ways 2 4\n# 16\nproc count_no_of_ways {n k} {",
        "canonical_solution": "    if {$n == 0} {return 0}\n    if {$n == 1} {return $k}\n    if {$n == 2} {return [expr {$k * $k}]}\n    set mod 1000000007\n    set dp [list]\n    lappend dp $k\n    lappend dp [expr {$k * $k}]\n    for {set i 2} {$i < $n} {incr i} {\n        set next [expr {($k - 1) * ([lindex $dp [expr {$i - 1}]] + [lindex $dp [expr {$i - 2}]]) % $mod}]\n        lappend dp $next\n    }\n    return [lindex $dp [expr {$n - 1}]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_no_of_ways 2 4] == 16}\nassert {[count_no_of_ways 3 2] == 6}\nassert {[count_no_of_ways 4 4] == 228}",
        "declaration": "proc count_no_of_ways {n k} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_no_of_ways 2 4] == 16}",
        "prompt_text": "Given a fence with n posts and k colors, write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color.",
        "prompt_explain": "Given a fence with n posts and k colors, write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color.\n>>> count_no_of_ways 2 4\n16",
        "func_title": "proc count_no_of_ways {n k}"
    },
    {
        "prompt": "# Write a Tcl function to find the quotient of two numbers.\n# >>> find 10 3\n# 3\nproc find {n m} {",
        "canonical_solution": "    set q [expr {$n / $m}]\n    return $q\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find 10 3] == 3}\nassert {[find 4 2] == 2}\nassert {[find 20 5] == 4}",
        "declaration": "proc find {n m} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find 10 3] == 3}",
        "prompt_text": "Write a Tcl function to find the quotient of two numbers.",
        "prompt_explain": "Write a Tcl function to find the quotient of two numbers.\n>>> find 10 3\n3",
        "func_title": "proc find {n m}"
    },
    {
        "prompt": "# Write a function to find the third side of a right angled triangle.\n# >>> otherside_rightangle 7 8\n# 10.63014581273465\nproc otherside_rightangle {w h} {",
        "canonical_solution": "    set s [expr {sqrt($w * $w + $h * $h)}]\n    return $s\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[otherside_rightangle 7 8] == 10.63014581273465}\nassert {[otherside_rightangle 3 4] == 5}\nassert {[otherside_rightangle 7 15] == 16.55294535724685}",
        "declaration": "proc otherside_rightangle {w h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[otherside_rightangle 7 8] == 10.63014581273465}",
        "prompt_text": "Write a function to find the third side of a right angled triangle.",
        "prompt_explain": "Write a function to find the third side of a right angled triangle.\n>>> otherside_rightangle 7 8\n10.63014581273465",
        "func_title": "proc otherside_rightangle {w h}"
    },
    {
        "prompt": "# Write a function to return the sum of all divisors of a number.\n# >>> sum_div 8\n# 7\nproc sum_div {number} {",
        "canonical_solution": "    set divisors {1}\n    for {set i 2} {$i < $number} {incr i} {\n        if {$number % $i == 0} {\n            lappend divisors $i\n        }\n    }\n    return [expr [join $divisors +]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_div 8] == 7}\nassert {[sum_div 12] == 16}\nassert {[sum_div 7] == 1}",
        "declaration": "proc sum_div {number} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_div 8] == 7}",
        "prompt_text": "Write a function to return the sum of all divisors of a number.",
        "prompt_explain": "Write a function to return the sum of all divisors of a number.\n>>> sum_div 8\n7",
        "func_title": "proc sum_div {number}"
    },
    {
        "prompt": "# Given a list of integers, return the count of inversions in the list.\n# An inversion is a pair of indices (i, j) such that i < j and list[i] > list[j].\n# >>> get_Inv_Count {1 20 6 4 5}\n# 5\nproc get_Inv_Count {arr} {",
        "canonical_solution": "    set inv_count 0\n    set n [llength $arr]\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $n} {incr j} {\n            if {[lindex $arr $i] > [lindex $arr $j]} {\n                incr inv_count\n            }\n        }\n    }\n    return $inv_count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Inv_Count {1 20 6 4 5}] == 5}\nassert {[get_Inv_Count {1 2 1}] == 1}\nassert {[get_Inv_Count {1 2 5 6 1}] == 3}",
        "declaration": "proc get_Inv_Count {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Inv_Count {1 20 6 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the count of inversions in the list. An inversion is a pair of indices (i, j) such that i < j and list[i] > list[j].",
        "prompt_explain": "Given a list of integers, return the count of inversions in the list. An inversion is a pair of indices (i, j) such that i < j and list[i] > list[j].\n>>> get_Inv_Count {1 20 6 4 5}\n5",
        "func_title": "proc get_Inv_Count {arr}"
    },
    {
        "prompt": "# Write a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.\n# >>> count_binary_seq 1\n# 2.0\nproc count_binary_seq {n} {",
        "canonical_solution": "    set nCr 1\n    set res 1\n    for {set r 1} {$r <= $n} {incr r} {\n        set nCr [expr {($nCr * ($n + 1 - $r)) / $r}]\n        set res [expr {$res + $nCr * $nCr}]\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_binary_seq 1] == 2.0}\nassert {[count_binary_seq 2] == 6.0}\nassert {[count_binary_seq 3] == 20.0}",
        "declaration": "proc count_binary_seq {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_binary_seq 1] == 2.0}",
        "prompt_text": "Write a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.",
        "prompt_explain": "Write a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.\n>>> count_binary_seq 1\n2.0",
        "func_title": "proc count_binary_seq {n}"
    },
    {
        "prompt": "# Write a Tcl function to find the most significant bit number which is also a set bit.\n# >>> set_Bit_Number 6\n# 4\nproc set_Bit_Number {n} {",
        "canonical_solution": "    if {$n == 0} {\n        return 0\n    }\n    set msb 0\n    set n [expr {$n / 2}]\n    while {$n > 0} {\n        set n [expr {$n / 2}]\n        incr msb\n    }\n    return [expr {1 << $msb}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[set_Bit_Number 6] == 4}\nassert {[set_Bit_Number 10] == 8}\nassert {[set_Bit_Number 18] == 16}",
        "declaration": "proc set_Bit_Number {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[set_Bit_Number 6] == 4}",
        "prompt_text": "Write a Tcl function to find the most significant bit number which is also a set bit.",
        "prompt_explain": "Write a Tcl function to find the most significant bit number which is also a set bit.\n>>> set_Bit_Number 6\n4",
        "func_title": "proc set_Bit_Number {n}"
    },
    {
        "prompt": "# Given a list of integers, a list of ranges, the number of rotations, and an index, return the element at the given index after performing the specified number of rotations on the ranges.\n# >>> find_Element {1 2 3 4 5} {{0 2} {0 3}} 2 1\n# 3\nproc find_Element {arr ranges rotations index} {",
        "canonical_solution": "    for {set i [expr {$rotations - 1}]} {$i >= 0} {incr i -1} {\n        set left [lindex [lindex $ranges $i] 0]\n        set right [lindex [lindex $ranges $i] 1]\n        if {$left <= $index && $right >= $index} {\n            if {$index == $left} {\n                set index $right\n            } else {\n                set index [expr {$index - 1}]\n            }\n        }\n    }\n    return [lindex $arr $index]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Element {1 2 3 4 5} {{0 2} {0 3}} 2 1] == 3}\nassert {[find_Element {1 2 3 4} {{0 1} {0 2}} 1 2] == 3}\nassert {[find_Element {1 2 3 4 5 6} {{0 1} {0 2}} 1 1] == 1}",
        "declaration": "proc find_Element {arr ranges rotations index} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Element {1 2 3 4 5} {{0 2} {0 3}} 2 1] == 3}",
        "prompt_text": "Given a list of integers, a list of ranges, the number of rotations, and an index, return the element at the given index after performing the specified number of rotations on the ranges.",
        "prompt_explain": "Given a list of integers, a list of ranges, the number of rotations, and an index, return the element at the given index after performing the specified number of rotations on the ranges.\n>>> find_Element {1 2 3 4 5} {{0 2} {0 3}} 2 1\n3",
        "func_title": "proc find_Element {arr ranges rotations index}"
    },
    {
        "prompt": "# Write a Tcl function to find the maximum of two numbers.\n# >>> maximum 5 10\n# 10\nproc maximum {a b} {",
        "canonical_solution": "    if {$a >= $b} {\n        return $a\n    } else {\n        return $b\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[maximum 5 10] == 10}\nassert {[maximum -1 -2] == -1}\nassert {[maximum 9 7] == 9}",
        "declaration": "proc maximum {a b} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[maximum 5 10] == 10}",
        "prompt_text": "Write a Tcl function to find the maximum of two numbers.",
        "prompt_explain": "Write a Tcl function to find the maximum of two numbers.\n>>> maximum 5 10\n10",
        "func_title": "proc maximum {a b}"
    },
    {
        "prompt": "# Given an integer, set the left most unset bit.\n# >>> set_left_most_unset_bit 10\n# 14\nproc set_left_most_unset_bit {n} {",
        "canonical_solution": "    if {$n == 0} { return 1 }\n    if {($n & ($n + 1)) == 0} { return $n }\n    set pos 0\n    set temp $n\n    set count 0\n    while {$temp != 0} {\n        if {($temp & 1) == 0} {\n            set pos $count\n        }\n        incr count\n        set temp [expr {$temp >> 1}]\n    }\n    return [expr {$n | (1 << $pos)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[set_left_most_unset_bit 10] == 14}\nassert {[set_left_most_unset_bit 12] == 14}\nassert {[set_left_most_unset_bit 15] == 15}",
        "declaration": "proc set_left_most_unset_bit {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[set_left_most_unset_bit 10] == 14}",
        "prompt_text": "Given an integer, set the left most unset bit.",
        "prompt_explain": "Given an integer, set the left most unset bit.\n>>> set_left_most_unset_bit 10\n14",
        "func_title": "proc set_left_most_unset_bit {n}"
    },
    {
        "prompt": "# Write a function to find the volume of a cone.\n# >>> volume_cone 5 12\n# 314.15926535897927\nproc volume_cone {r h} {",
        "canonical_solution": "    set pi 3.141592653589793\n    set volume [expr {(1.0/3) * $pi * $r * $r * $h}]\n    return $volume\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_cone 5 12] == 314.15926535897927}\nassert {[volume_cone 10 15] == 1570.7963267948965}\nassert {[volume_cone 19 17] == 6426.651371693521}",
        "declaration": "proc volume_cone {r h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_cone 5 12] == 314.15926535897927}",
        "prompt_text": "Write a function to find the volume of a cone.",
        "prompt_explain": "Write a function to find the volume of a cone.\n>>> volume_cone 5 12\n314.15926535897927",
        "func_title": "proc volume_cone {r h}"
    },
    {
        "prompt": "# Given a rectangular grid of dimension 2 x n, write a function to find out the maximum sum such that no two chosen numbers are adjacent.\n# >>> max_sum_rectangular_grid { {1 4 5} {2 0 0} } 3\n# 7\nproc max_sum_rectangular_grid {grid n} {",
        "canonical_solution": "    set incl [expr {max([lindex $grid 0 0], [lindex $grid 1 0])}]\n    set excl 0\n    for {set i 1} {$i < $n} {incr i} {\n        set excl_new [expr {max($excl, $incl)}]\n        set incl [expr {$excl + max([lindex $grid 0 $i], [lindex $grid 1 $i])}]\n        set excl $excl_new\n    }\n    return [expr {max($excl, $incl)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sum_rectangular_grid { {1 4 5} {2 0 0} } 3] == 7}\nassert {[max_sum_rectangular_grid { {1 2 3 4 5} {6 7 8 9 10} } 5] == 24}\nassert {[max_sum_rectangular_grid { {7 9 11 15 19} {21 25 28 31 32} } 5] == 81}",
        "declaration": "proc max_sum_rectangular_grid {grid n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sum_rectangular_grid { {1 4 5} {2 0 0} } 3] == 7}",
        "prompt_text": "Given a rectangular grid of dimension 2 x n, write a function to find out the maximum sum such that no two chosen numbers are adjacent.",
        "prompt_explain": "Given a rectangular grid of dimension 2 x n, write a function to find out the maximum sum such that no two chosen numbers are adjacent.\n>>> max_sum_rectangular_grid { {1 4 5} {2 0 0} } 3\n7",
        "func_title": "proc max_sum_rectangular_grid {grid n}"
    },
    {
        "prompt": "# Given a sorted list of integers and a number, find the index of the last occurrence of the number in the list.\n# >>> find_last_occurrence {2 5 5 5 6 6 8 9 9 9} 5\n# 3\nproc find_last_occurrence {A x} {",
        "canonical_solution": "    set left 0\n    set right [expr {[llength $A] - 1}]\n    set result -1\n    while {$left <= $right} {\n        set mid [expr {($left + $right) / 2}]\n        if {$x == [lindex $A $mid]} {\n            set result $mid\n            set left [expr {$mid + 1}]\n        } elseif {$x < [lindex $A $mid]} {\n            set right [expr {$mid - 1}]\n        } else {\n            set left [expr {$mid + 1}]\n        }\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_last_occurrence {2 5 5 5 6 6 8 9 9 9} 5] == 3}\nassert {[find_last_occurrence {2 3 5 8 6 6 8 9 9 9} 9] == 9}\nassert {[find_last_occurrence {2 2 1 5 6 6 6 9 9 9} 6] == 6}",
        "declaration": "proc find_last_occurrence {A x} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_last_occurrence {2 5 5 5 6 6 8 9 9 9} 5] == 3}",
        "prompt_text": "Given a sorted list of integers and a number, find the index of the last occurrence of the number in the list.",
        "prompt_explain": "Given a sorted list of integers and a number, find the index of the last occurrence of the number in the list.\n>>> find_last_occurrence {2 5 5 5 6 6 8 9 9 9} 5\n3",
        "func_title": "proc find_last_occurrence {A x}"
    },
    {
        "prompt": "# Given the sum of the sides of a cuboid, find the maximum volume that can be achieved.\n# >>> max_volume 8\n# 18\nproc max_volume {s} {",
        "canonical_solution": "    set maxvalue 0\n    for {set i 1} {$i < $s} {incr i} {\n        for {set j 1} {$j < $s} {incr j} {\n            set k [expr {$s - $i - $j}]\n            if {$k > 0} {\n                set maxvalue [expr {max($maxvalue, $i * $j * $k)}]\n            }\n        }\n    }\n    return $maxvalue\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_volume 8] == 18}\nassert {[max_volume 4] == 2}\nassert {[max_volume 1] == 0}",
        "declaration": "proc max_volume {s} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_volume 8] == 18}",
        "prompt_text": "Given the sum of the sides of a cuboid, find the maximum volume that can be achieved.",
        "prompt_explain": "Given the sum of the sides of a cuboid, find the maximum volume that can be achieved.\n>>> max_volume 8\n18",
        "func_title": "proc max_volume {s}"
    },
    {
        "prompt": "# Write a function to calculate the difference between the squared sum of first n natural numbers and the sum of squared first n natural numbers.\n# >>> sum_difference 12\n# 5434\nproc sum_difference {n} {",
        "canonical_solution": "    set sumofsquares 0\n    set squareofsum 0\n    for {set num 1} {$num <= $n} {incr num} {\n        set sumofsquares [expr {$sumofsquares + $num * $num}]\n        set squareofsum [expr {$squareofsum + $num}]\n    }\n    set squareofsum [expr {$squareofsum ** 2}]\n    return [expr {$squareofsum - $sumofsquares}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_difference 12] == 5434}\nassert {[sum_difference 20] == 41230}\nassert {[sum_difference 54] == 2151270}",
        "declaration": "proc sum_difference {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_difference 12] == 5434}",
        "prompt_text": "Write a function to calculate the difference between the squared sum of first n natural numbers and the sum of squared first n natural numbers.",
        "prompt_explain": "Write a function to calculate the difference between the squared sum of first n natural numbers and the sum of squared first n natural numbers.\n>>> sum_difference 12\n5434",
        "func_title": "proc sum_difference {n}"
    },
    {
        "prompt": "# Given a number, find its Demlo number. A Demlo number is a number that is a concatenation of numbers from 1 to n and then back to 1.\n# >>> find_demlo 111111\n# 12345654321\nproc find_demlo {s} {",
        "canonical_solution": "    set l [string length $s]\n    set res \"\"\n    for {set i 1} {$i <= $l} {incr i} {\n        append res $i\n    }\n    for {set i [expr {$l - 1}]} {$i >= 1} {incr i -1} {\n        append res $i\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_demlo \"111111\"] eq \"12345654321\"}\nassert {[find_demlo \"1111\"] eq \"1234321\"}\nassert {[find_demlo \"13333122222\"] eq \"123456789101110987654321\"}",
        "declaration": "proc find_demlo {s} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_demlo \"111111\"] eq \"12345654321\"}",
        "prompt_text": "Given a number, find its Demlo number. A Demlo number is a number that is a concatenation of numbers from 1 to n and then back to 1.",
        "prompt_explain": "Given a number, find its Demlo number. A Demlo number is a number that is a concatenation of numbers from 1 to n and then back to 1.\n>>> find_demlo 111111\n12345654321",
        "func_title": "proc find_demlo {s}"
    },
    {
        "prompt": "# Write a Tcl function to find the minimum number of squares whose sum is equal to a given number.\n# >>> get_Min_Squares 6\n# 3\nproc get_Min_Squares {n} {",
        "canonical_solution": "    if {$n <= 3} {\n        return $n\n    }\n    set res $n\n    for {set x 1} {$x <= $n} {incr x} {\n        set temp [expr {$x * $x}]\n        if {$temp > $n} {\n            break\n        } else {\n            set res [expr {min($res, 1 + [get_Min_Squares [expr {$n - $temp}]])}]\n        }\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Min_Squares 6] == 3}\nassert {[get_Min_Squares 2] == 2}\nassert {[get_Min_Squares 4] == 1}",
        "declaration": "proc get_Min_Squares {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Min_Squares 6] == 3}",
        "prompt_text": "Write a Tcl function to find the minimum number of squares whose sum is equal to a given number.",
        "prompt_explain": "Write a Tcl function to find the minimum number of squares whose sum is equal to a given number.\n>>> get_Min_Squares 6\n3",
        "func_title": "proc get_Min_Squares {n}"
    },
    {
        "prompt": "# Write a function to check if the triangle is isosceles or not.\n# >>> check_isosceles 6 8 12\n# False\n# >>> check_isosceles 6 6 12\n# True\n# >>> check_isosceles 6 16 20\n# False\nproc check_isosceles {x y z} {",
        "canonical_solution": "    if {$x == $y || $y == $z || $z == $x} {\n        return True\n    } else {\n        return False\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_isosceles 6 8 12] eq False}\nassert {[check_isosceles 6 6 12] eq True}\nassert {[check_isosceles 6 16 20] eq False}",
        "declaration": "proc check_isosceles {x y z} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_isosceles 6 8 12] eq False}",
        "prompt_text": "Write a function to check if the triangle is isosceles or not.",
        "prompt_explain": "Write a function to check if the triangle is isosceles or not.\n>>> check_isosceles 6 8 12\nFalse\n>>> check_isosceles 6 6 12\nTrue\n>>> check_isosceles 6 16 20\nFalse",
        "func_title": "proc check_isosceles {x y z}"
    },
    {
        "prompt": "# Write a function to find the sum of arithmetic progression.\n# >>> ap_sum 1 5 2\n# 25\nproc ap_sum {a n d} {",
        "canonical_solution": "    set total [expr {($n * (2 * $a + ($n - 1) * $d)) / 2}]\n    return $total\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[ap_sum 1 5 2] == 25}\nassert {[ap_sum 2 6 4] == 72}\nassert {[ap_sum 1 4 5] == 34}",
        "declaration": "proc ap_sum {a n d} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[ap_sum 1 5 2] == 25}",
        "prompt_text": "Write a function to find the sum of arithmetic progression.",
        "prompt_explain": "Write a function to find the sum of arithmetic progression.\n>>> ap_sum 1 5 2\n25",
        "func_title": "proc ap_sum {a n d}"
    },
    {
        "prompt": "# Write a function to check whether the given month name contains 28 days or not.\n# >>> check_monthnum \"February\"\n# 1\n# >>> check_monthnum \"January\"\n# 0\nproc check_monthnum {monthname1} {",
        "canonical_solution": "    if {$monthname1 eq \"February\"} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_monthnum \"February\"] == 1}\nassert {[check_monthnum \"January\"] == 0}\nassert {[check_monthnum \"March\"] == 0}",
        "declaration": "proc check_monthnum {monthname1} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_monthnum \"February\"] == 1}",
        "prompt_text": "Write a function to check whether the given month name contains 28 days or not.",
        "prompt_explain": "Write a function to check whether the given month name contains 28 days or not.\n>>> check_monthnum \"February\"\n1\n>>> check_monthnum \"January\"\n0",
        "func_title": "proc check_monthnum {monthname1}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the given string is a binary string or not.\n# >>> check_binary \"01010101010\"\n# Yes\n# >>> check_binary \"name0\"\n# No\nproc check_binary {string} {",
        "canonical_solution": "    set p [split $string \"\"]\n    set s {0 1}\n    if {[lsort -unique $p] eq [lsort -unique $s]} {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_binary \"01010101010\"] eq \"Yes\"}\nassert {[check_binary \"name0\"] eq \"No\"}\nassert {[check_binary \"101\"] eq \"Yes\"}",
        "declaration": "proc check_binary {string} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_binary \"01010101010\"] eq \"Yes\"}",
        "prompt_text": "Write a Tcl function to check whether the given string is a binary string or not.",
        "prompt_explain": "Write a Tcl function to check whether the given string is a binary string or not.\n>>> check_binary \"01010101010\"\nYes\n>>> check_binary \"name0\"\nNo",
        "func_title": "proc check_binary {string}"
    },
    {
        "prompt": "# Write a Tcl function to check whether all the characters in a given string are unique.\n# >>> unique_Characters 'aba'\n# 0\n# >>> unique_Characters 'abc'\n# 1\nproc unique_Characters {str} {",
        "canonical_solution": "    set length [string length $str]\n    for {set i 0} {$i < $length} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $length} {incr j} {\n            if {[string index $str $i] eq [string index $str $j]} {\n                return 0\n            }\n        }\n    }\n    return 1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[unique_Characters 'aba'] == 0}\nassert {[unique_Characters 'abc'] == 1}\nassert {[unique_Characters 'abab'] == 0}",
        "declaration": "proc unique_Characters {str} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[unique_Characters 'aba'] == 0}",
        "prompt_text": "Write a Tcl function to check whether all the characters in a given string are unique.",
        "prompt_explain": "Write a Tcl function to check whether all the characters in a given string are unique.\n>>> unique_Characters 'aba'\n0\n>>> unique_Characters 'abc'\n1",
        "func_title": "proc unique_Characters {str}"
    },
    {
        "prompt": "# Write a function to find the nth term of an arithmetic progression.\n# >>> tn_ap 1 5 2\n# 9\nproc tn_ap {a n d} {",
        "canonical_solution": "    set tn [expr {$a + ($n - 1) * $d}]\n    return $tn\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[tn_ap 1 5 2] == 9}\nassert {[tn_ap 2 6 4] == 22}\nassert {[tn_ap 1 4 5] == 16}",
        "declaration": "proc tn_ap {a n d} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[tn_ap 1 5 2] == 9}",
        "prompt_text": "Write a function to find the nth term of an arithmetic progression.",
        "prompt_explain": "Write a function to find the nth term of an arithmetic progression.\n>>> tn_ap 1 5 2\n9",
        "func_title": "proc tn_ap {a n d}"
    },
    {
        "prompt": "# Given a list of tuple records, find the maximum element across all tuples.\n# >>> find_max {{2 4} {6 7} {5 1} {6 10} {8 7}}\n# 10\nproc find_max {test_list} {",
        "canonical_solution": "    set max_val [lindex [lindex $test_list 0] 0]\n    foreach tuple $test_list {\n        foreach element $tuple {\n            if {$element > $max_val} {\n                set max_val $element\n            }\n        }\n    }\n    return $max_val\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {{2 4} {6 7} {5 1} {6 10} {8 7}}] == 10}\nassert {[find_max {{3 5} {7 8} {6 2} {7 11} {9 8}}] == 11}\nassert {[find_max {{4 6} {8 9} {7 3} {8 12} {10 9}}] == 12}",
        "declaration": "proc find_max {test_list} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_max {{2 4} {6 7} {5 1} {6 10} {8 7}}] == 10}",
        "prompt_text": "Given a list of tuple records, find the maximum element across all tuples.",
        "prompt_explain": "Given a list of tuple records, find the maximum element across all tuples.\n>>> find_max {{2 4} {6 7} {5 1} {6 10} {8 7}}\n10",
        "func_title": "proc find_max {test_list}"
    },
    {
        "prompt": "# Write a Tcl function to check whether one root of the quadratic equation is twice of the other or not.\n# >>> Check_Solution 1 3 2\n# Yes\n# >>> Check_Solution 1 2 3\n# No\nproc Check_Solution {a b c} {",
        "canonical_solution": "    if {[expr {2 * $b * $b}] == [expr {9 * $a * $c}]} {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Check_Solution 1 3 2] eq \"Yes\"}\nassert {[Check_Solution 1 2 3] eq \"No\"}\nassert {[Check_Solution 1 -5 6] eq \"No\"}",
        "declaration": "proc Check_Solution {a b c} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Check_Solution 1 3 2] eq \"Yes\"}",
        "prompt_text": "Write a Tcl function to check whether one root of the quadratic equation is twice of the other or not.",
        "prompt_explain": "Write a Tcl function to check whether one root of the quadratic equation is twice of the other or not.\n>>> Check_Solution 1 3 2\nYes\n>>> Check_Solution 1 2 3\nNo",
        "func_title": "proc Check_Solution {a b c}"
    },
    {
        "prompt": "# Given a list of integers, return the item with maximum occurrences in the list.\n# >>> max_occurrences {1 2 3 1 2 3 12 4 2}\n# 2\nproc max_occurrences {nums} {",
        "canonical_solution": "    set max_val 0\n    set result [lindex $nums 0]\n    foreach i $nums {\n        set occu [llength [lsearch -all $nums $i]]\n        if {$occu > $max_val} {\n            set max_val $occu\n            set result $i\n        }\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_occurrences {1 2 3 1 2 3 12 4 2}] == 2}\nassert {[max_occurrences {1 2 6 7 0 1 0 1 0}] == 1}\nassert {[max_occurrences {1 2 3 1 2 4 1}] == 1}",
        "declaration": "proc max_occurrences {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_occurrences {1 2 3 1 2 3 12 4 2}] == 2}",
        "prompt_text": "Given a list of integers, return the item with maximum occurrences in the list.",
        "prompt_explain": "Given a list of integers, return the item with maximum occurrences in the list.\n>>> max_occurrences {1 2 3 1 2 3 12 4 2}\n2",
        "func_title": "proc max_occurrences {nums}"
    },
    {
        "prompt": "# Write a Tcl function to count the number of digits of a given number.\n# >>> count_Digit 12345\n# 5\nproc count_Digit {n} {",
        "canonical_solution": "    set count 0\n    while {$n != 0} {\n        set n [expr {$n / 10}]\n        incr count\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Digit 12345] == 5}\nassert {[count_Digit 11223305] == 8}\nassert {[count_Digit 4123459] == 7}",
        "declaration": "proc count_Digit {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Digit 12345] == 5}",
        "prompt_text": "Write a Tcl function to count the number of digits of a given number.",
        "prompt_explain": "Write a Tcl function to count the number of digits of a given number.\n>>> count_Digit 12345\n5",
        "func_title": "proc count_Digit {n}"
    },
    {
        "prompt": "# Write a function to find the lateral surface area of a cuboid\n# >>> lateralsurface_cuboid 8 5 6\n# 156\nproc lateralsurface_cuboid {l w h} {",
        "canonical_solution": "    set LSA [expr {2 * $h * ($l + $w)}]\n    return $LSA\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[lateralsurface_cuboid 8 5 6] == 156}\nassert {[lateralsurface_cuboid 7 9 10] == 320}\nassert {[lateralsurface_cuboid 10 20 30] == 1800}",
        "declaration": "proc lateralsurface_cuboid {l w h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[lateralsurface_cuboid 8 5 6] == 156}",
        "prompt_text": "Write a function to find the lateral surface area of a cuboid",
        "prompt_explain": "Write a function to find the lateral surface area of a cuboid\n>>> lateralsurface_cuboid 8 5 6\n156",
        "func_title": "proc lateralsurface_cuboid {l w h}"
    },
    {
        "prompt": "# Given a sorted list of integers, find the smallest missing element.\n# >>> smallest_missing {0 1 2 3 4 5 6} 0 6\n# 7\nproc smallest_missing {A left_element right_element} {",
        "canonical_solution": "    if {$left_element > $right_element} {\n        return $left_element\n    }\n    set mid [expr {$left_element + ($right_element - $left_element) / 2}]\n    if {[lindex $A $mid] == $mid} {\n        return [smallest_missing $A [expr {$mid + 1}] $right_element]\n    } else {\n        return [smallest_missing $A $left_element [expr {$mid - 1}]]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smallest_missing {0 1 2 3 4 5 6} 0 6] == 7}\nassert {[smallest_missing {0 1 2 6 9 11 15} 0 6] == 3}\nassert {[smallest_missing {1 2 3 4 6 9 11 15} 0 7] == 0}",
        "declaration": "proc smallest_missing {A left_element right_element} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smallest_missing {0 1 2 3 4 5 6} 0 6] == 7}",
        "prompt_text": "Given a sorted list of integers, find the smallest missing element.",
        "prompt_explain": "Given a sorted list of integers, find the smallest missing element.\n>>> smallest_missing {0 1 2 3 4 5 6} 0 6\n7",
        "func_title": "proc smallest_missing {A left_element right_element}"
    },
    {
        "prompt": "# Write a function to find the volume of a cuboid.\n# >>> volume_cuboid 1 2 3\n# 6\nproc volume_cuboid {l w h} {",
        "canonical_solution": "    set volume [expr {$l * $w * $h}]\n    return $volume\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_cuboid 1 2 3] == 6}\nassert {[volume_cuboid 5 7 9] == 315}\nassert {[volume_cuboid 10 15 21] == 3150}",
        "declaration": "proc volume_cuboid {l w h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_cuboid 1 2 3] == 6}",
        "prompt_text": "Write a function to find the volume of a cuboid.",
        "prompt_explain": "Write a function to find the volume of a cuboid.\n>>> volume_cuboid 1 2 3\n6",
        "func_title": "proc volume_cuboid {l w h}"
    },
    {
        "prompt": "# Write a function to round the given number to the nearest multiple of a specific number.\n# >>> round_num 4722 10\n# 4720\nproc round_num {n m} {",
        "canonical_solution": "    set a [expr {($n / $m) * $m}]\n    set b [expr {$a + $m}]\n    if {[expr {$n - $a}] > [expr {$b - $n}]} {\n        return $b\n    } else {\n        return $a\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[round_num 4722 10] == 4720}\nassert {[round_num 1111 5] == 1110}\nassert {[round_num 219 2] == 218}",
        "declaration": "proc round_num {n m} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[round_num 4722 10] == 4720}",
        "prompt_text": "Write a function to round the given number to the nearest multiple of a specific number.",
        "prompt_explain": "Write a function to round the given number to the nearest multiple of a specific number.\n>>> round_num 4722 10\n4720",
        "func_title": "proc round_num {n m}"
    },
    {
        "prompt": "# Write a function to find the surface area of a cuboid.\n# >>> surfacearea_cuboid 1 2 3\n# 22\nproc surfacearea_cuboid {l w h} {",
        "canonical_solution": "    set SA [expr {2 * ($l * $w + $l * $h + $w * $h)}]\n    return $SA\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surfacearea_cuboid 1 2 3] == 22}\nassert {[surfacearea_cuboid 5 7 9] == 286}\nassert {[surfacearea_cuboid 10 15 21] == 1350}",
        "declaration": "proc surfacearea_cuboid {l w h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surfacearea_cuboid 1 2 3] == 22}",
        "prompt_text": "Write a function to find the surface area of a cuboid.",
        "prompt_explain": "Write a function to find the surface area of a cuboid.\n>>> surfacearea_cuboid 1 2 3\n22",
        "func_title": "proc surfacearea_cuboid {l w h}"
    },
    {
        "prompt": "# Write a Tcl function to toggle all odd bits of a given number.\n# >>> even_bit_toggle_number 10\n# 15\nproc even_bit_toggle_number {n} {",
        "canonical_solution": "    set res 0\n    set count 0\n    set temp $n\n    while {$temp > 0} {\n        if {$count % 2 == 0} {\n            set res [expr {$res | (1 << $count)}]\n        }\n        incr count\n        set temp [expr {$temp >> 1}]\n    }\n    return [expr {$n ^ $res}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_bit_toggle_number 10] == 15}\nassert {[even_bit_toggle_number 20] == 1}\nassert {[even_bit_toggle_number 30] == 11}",
        "declaration": "proc even_bit_toggle_number {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_bit_toggle_number 10] == 15}",
        "prompt_text": "Write a Tcl function to toggle all odd bits of a given number.",
        "prompt_explain": "Write a Tcl function to toggle all odd bits of a given number.\n>>> even_bit_toggle_number 10\n15",
        "func_title": "proc even_bit_toggle_number {n}"
    },
    {
        "prompt": "# Write a Tcl function to find the highest power of 2 that is less than or equal to n.\n# >>> highest_Power_of_2 10\n# 8\nproc highest_Power_of_2 {n} {",
        "canonical_solution": "    set res 0\n    for {set i $n} {$i > 0} {incr i -1} {\n        if {[expr {$i & ($i - 1)}] == 0} {\n            set res $i\n            break\n        }\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[highest_Power_of_2 10] == 8}\nassert {[highest_Power_of_2 19] == 16}\nassert {[highest_Power_of_2 32] == 32}",
        "declaration": "proc highest_Power_of_2 {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[highest_Power_of_2 10] == 8}",
        "prompt_text": "Write a Tcl function to find the highest power of 2 that is less than or equal to n.",
        "prompt_explain": "Write a Tcl function to find the highest power of 2 that is less than or equal to n.\n>>> highest_Power_of_2 10\n8",
        "func_title": "proc highest_Power_of_2 {n}"
    },
    {
        "prompt": "# Given a number n, find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n# >>> get_max_sum 60\n# 106\nproc get_max_sum {n} {",
        "canonical_solution": "    set res [list 0 1]\n    for {set i 2} {$i <= $n} {incr i} {\n        set sum [expr {[lindex $res [expr {$i / 2}]] + [lindex $res [expr {$i / 3}]] + [lindex $res [expr {$i / 4}]] + [lindex $res [expr {$i / 5}]]}]\n        lappend res [expr {max($sum, $i)}]\n    }\n    return [lindex $res $n]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_max_sum 60] == 106}\nassert {[get_max_sum 10] == 12}\nassert {[get_max_sum 2] == 2}",
        "declaration": "proc get_max_sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_max_sum 60] == 106}",
        "prompt_text": "Given a number n, find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).",
        "prompt_explain": "Given a number n, find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n>>> get_max_sum 60\n106",
        "func_title": "proc get_max_sum {n}"
    },
    {
        "prompt": "# Given a list of numbers, compute the sum of digits of each number in the list.\n# >>> sum_of_digits {10 2 56}\n# 14\nproc sum_of_digits {nums} {",
        "canonical_solution": "    set total 0\n    foreach n $nums {\n        foreach el [split $n {}] {\n            if {[string is digit $el]} {\n                incr total $el\n            }\n        }\n    }\n    return $total\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_of_digits {10 2 56}] == 14}\nassert {[sum_of_digits {10 20 4 5 b 70 a}] == 19}\nassert {[sum_of_digits {10 20 -4 5 -70}] == 19}",
        "declaration": "proc sum_of_digits {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_of_digits {10 2 56}] == 14}",
        "prompt_text": "Given a list of numbers, compute the sum of digits of each number in the list.",
        "prompt_explain": "Given a list of numbers, compute the sum of digits of each number in the list.\n>>> sum_of_digits {10 2 56}\n14",
        "func_title": "proc sum_of_digits {nums}"
    },
    {
        "prompt": "# Write a function to compute the value of ncr%p.\n# >>> ncr_modp 10 2 13\n# 6\nproc ncr_modp {n r p} {",
        "canonical_solution": "    set C [lrepeat [expr {$r + 1}] 0]\n    lset C 0 1\n    for {set i 1} {$i <= $n} {incr i} {\n        for {set j [expr {min($i, $r)}]} {$j > 0} {incr j -1} {\n            lset C $j [expr {([lindex $C $j] + [lindex $C [expr {$j - 1}]]) % $p}]\n        }\n    }\n    return [lindex $C $r]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[ncr_modp 10 2 13] == 6}\nassert {[ncr_modp 15 12 43] == 25}\nassert {[ncr_modp 17 9 18] == 10}",
        "declaration": "proc ncr_modp {n r p} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[ncr_modp 10 2 13] == 6}",
        "prompt_text": "Write a function to compute the value of ncr%p.",
        "prompt_explain": "Write a function to compute the value of ncr%p.\n>>> ncr_modp 10 2 13\n6",
        "func_title": "proc ncr_modp {n r p}"
    },
    {
        "prompt": "# Write a Tcl function to find the minimum of two numbers.\n# >>> minimum 1 2\n# 1\nproc minimum {a b} {",
        "canonical_solution": "    if {$a <= $b} {\n        return $a\n    } else {\n        return $b\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[minimum 1 2] == 1}\nassert {[minimum -5 -4] == -5}\nassert {[minimum 0 0] == 0}",
        "declaration": "proc minimum {a b} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[minimum 1 2] == 1}",
        "prompt_text": "Write a Tcl function to find the minimum of two numbers.",
        "prompt_explain": "Write a Tcl function to find the minimum of two numbers.\n>>> minimum 1 2\n1",
        "func_title": "proc minimum {a b}"
    },
    {
        "prompt": "# Given a tuple and an element, check whether the element exists within the tuple.\n# >>> check_tuplex {w 3 r e s o u r c e} r\n# 1\nproc check_tuplex {tuplex element} {",
        "canonical_solution": "    if {$element in $tuplex} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_tuplex {w 3 r e s o u r c e} r] == 1}\nassert {[check_tuplex {w 3 r e s o u r c e} 5] == 0}\nassert {[check_tuplex {w 3 r e s o u r c e} 3] == 1}",
        "declaration": "proc check_tuplex {tuplex element} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_tuplex {w 3 r e s o u r c e} r] == 1}",
        "prompt_text": "Given a tuple and an element, check whether the element exists within the tuple.",
        "prompt_explain": "Given a tuple and an element, check whether the element exists within the tuple.\n>>> check_tuplex {w 3 r e s o u r c e} r\n1",
        "func_title": "proc check_tuplex {tuplex element}"
    },
    {
        "prompt": "# Given a heterogeneous list, return the minimum integer value.\n# >>> min_val {Python 3 2 4 5 version}\n# 2\nproc min_val {listval} {",
        "canonical_solution": "    set min_val {}\n    foreach i $listval {\n        if {[string is integer -strict $i]} {\n            if {$min_val eq {} || $i < $min_val} {\n                set min_val $i\n            }\n        }\n    }\n    return $min_val\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_val {Python 3 2 4 5 version}] == 2}\nassert {[min_val {Python 15 20 25}] == 15}\nassert {[min_val {Python 30 20 40 50 version}] == 20}",
        "declaration": "proc min_val {listval} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_val {Python 3 2 4 5 version}] == 2}",
        "prompt_text": "Given a heterogeneous list, return the minimum integer value.",
        "prompt_explain": "Given a heterogeneous list, return the minimum integer value.\n>>> min_val {Python 3 2 4 5 version}\n2",
        "func_title": "proc min_val {listval}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the value exists in a sequence or not.\n# >>> overlapping {1 2 3 4 5} {6 7 8 9}\n# 0\n# >>> overlapping {1 2 3} {4 5 6}\n# 0\n# >>> overlapping {1 4 5} {1 4 5}\n# 1\nproc overlapping {list1 list2} {",
        "canonical_solution": "    foreach i $list1 {\n        foreach j $list2 {\n            if {$i == $j} {\n                return 1\n            }\n        }\n    }\n    return 0\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[overlapping {1 2 3 4 5} {6 7 8 9}] == 0}\nassert {[overlapping {1 2 3} {4 5 6}] == 0}\nassert {[overlapping {1 4 5} {1 4 5}] == 1}",
        "declaration": "proc overlapping {list1 list2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[overlapping {1 2 3 4 5} {6 7 8 9}] == 0}",
        "prompt_text": "Write a Tcl function to check whether the value exists in a sequence or not.",
        "prompt_explain": "Write a Tcl function to check whether the value exists in a sequence or not.\n>>> overlapping {1 2 3 4 5} {6 7 8 9}\n0\n>>> overlapping {1 2 3} {4 5 6}\n0\n>>> overlapping {1 4 5} {1 4 5}\n1",
        "func_title": "proc overlapping {list1 list2}"
    },
    {
        "prompt": "# Given a number, find the maximum sum we can make by dividing the number into three parts recursively and summing them up together.\n# >>> breakSum 12\n# 13\nproc breakSum {n} {",
        "canonical_solution": "    set dp [list]\n    for {set i 0} {$i <= $n} {incr i} {\n        lappend dp 0\n    }\n    lset dp 0 0\n    lset dp 1 1\n    for {set i 2} {$i <= $n} {incr i} {\n        set half [expr {$i / 2}]\n        set third [expr {$i / 3}]\n        set fourth [expr {$i / 4}]\n        set sum [expr {[lindex $dp $half] + [lindex $dp $third] + [lindex $dp $fourth]}]\n        lset dp $i [expr {$sum > $i ? $sum : $i}]\n    }\n    return [lindex $dp $n]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[breakSum 12] == 13}\nassert {[breakSum 24] == 27}\nassert {[breakSum 23] == 23}",
        "declaration": "proc breakSum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[breakSum 12] == 13}",
        "prompt_text": "Given a number, find the maximum sum we can make by dividing the number into three parts recursively and summing them up together.",
        "prompt_explain": "Given a number, find the maximum sum we can make by dividing the number into three parts recursively and summing them up together.\n>>> breakSum 12\n13",
        "func_title": "proc breakSum {n}"
    },
    {
        "prompt": "# Write a Tcl function to find the cube sum of first n even natural numbers.\n# >>> cube_Sum 2\n# 72\n# >>> cube_Sum 3\n# 288\n# >>> cube_Sum 4\n# 800\nproc cube_Sum {n} {",
        "canonical_solution": "    set sum 0\n    for {set i 1} {$i <= $n} {incr i} {\n        set even [expr {2 * $i}]\n        set cube [expr {$even * $even * $even}]\n        set sum [expr {$sum + $cube}]\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[cube_Sum 2] == 72}\nassert {[cube_Sum 3] == 288}\nassert {[cube_Sum 4] == 800}",
        "declaration": "proc cube_Sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[cube_Sum 2] == 72}",
        "prompt_text": "Write a Tcl function to find the cube sum of first n even natural numbers.",
        "prompt_explain": "Write a Tcl function to find the cube sum of first n even natural numbers.\n>>> cube_Sum 2\n72\n>>> cube_Sum 3\n288\n>>> cube_Sum 4\n800",
        "func_title": "proc cube_Sum {n}"
    },
    {
        "prompt": "# Write a function to find the directrix of a parabola given its coefficients a, b, and c in the equation y = ax^2 + bx + c.\n# >>> parabola_directrix 5 3 2\n# -198\nproc parabola_directrix {a b c} {",
        "canonical_solution": "    set directrix [expr {int($c - (($b * $b) + 1) * 4 * $a)}]\n    return $directrix\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[parabola_directrix 5 3 2] == -198}\nassert {[parabola_directrix 9 8 4] == -2336}\nassert {[parabola_directrix 2 4 6] == -130}",
        "declaration": "proc parabola_directrix {a b c} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[parabola_directrix 5 3 2] == -198}",
        "prompt_text": "Write a function to find the directrix of a parabola given its coefficients a, b, and c in the equation y = ax^2 + bx + c.",
        "prompt_explain": "Write a function to find the directrix of a parabola given its coefficients a, b, and c in the equation y = ax^2 + bx + c.\n>>> parabola_directrix 5 3 2\n-198",
        "func_title": "proc parabola_directrix {a b c}"
    },
    {
        "prompt": "# Write a function that takes two lists and returns true if they have at least one common element.\n# >>> common_element {1 2 3 4 5} {5 6 7 8 9}\n# true\nproc common_element {list1 list2} {",
        "canonical_solution": "    foreach x $list1 {\n        foreach y $list2 {\n            if {$x == $y} {\n                return true\n            }\n        }\n    }\n    return false\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[common_element {1 2 3 4 5} {5 6 7 8 9}] == true}\nassert {[common_element {1 2 3 4 5} {6 7 8 9}] == false}\nassert {[common_element {a b c} {d b e}] == true}",
        "declaration": "proc common_element {list1 list2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[common_element {1 2 3 4 5} {5 6 7 8 9}] == true}",
        "prompt_text": "Write a function that takes two lists and returns true if they have at least one common element.",
        "prompt_explain": "Write a function that takes two lists and returns true if they have at least one common element.\n>>> common_element {1 2 3 4 5} {5 6 7 8 9}\ntrue",
        "func_title": "proc common_element {list1 list2}"
    },
    {
        "prompt": "# Given the lengths of the two bases and the height of a trapezium, return the median.\n# >>> median_trapezium 15 25 35\n# 20\nproc median_trapezium {base1 base2 height} {",
        "canonical_solution": "    set median [expr {0.5 * ($base1 + $base2)}]\n    return $median\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[median_trapezium 15 25 35] == 20}\nassert {[median_trapezium 10 20 30] == 15}\nassert {[median_trapezium 6 9 4] == 7.5}",
        "declaration": "proc median_trapezium {base1 base2 height} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[median_trapezium 15 25 35] == 20}",
        "prompt_text": "Given the lengths of the two bases and the height of a trapezium, return the median.",
        "prompt_explain": "Given the lengths of the two bases and the height of a trapezium, return the median.\n>>> median_trapezium 15 25 35\n20",
        "func_title": "proc median_trapezium {base1 base2 height}"
    },
    {
        "prompt": "# Given a number, return its last digit.\n# >>> last_Digit 123\n# 3\nproc last_Digit {n} {",
        "canonical_solution": "    return [expr {$n % 10}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[last_Digit 123] == 3}\nassert {[last_Digit 25] == 5}\nassert {[last_Digit 30] == 0}",
        "declaration": "proc last_Digit {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[last_Digit 123] == 3}",
        "prompt_text": "Given a number, return its last digit.",
        "prompt_explain": "Given a number, return its last digit.\n>>> last_Digit 123\n3",
        "func_title": "proc last_Digit {n}"
    },
    {
        "prompt": "# Given a list of integers, convert it into a single integer.\n# >>> multiple_to_single {11 33 50}\n# 113350\nproc multiple_to_single {L} {",
        "canonical_solution": "    set result \"\"\n    foreach num $L {\n        append result $num\n    }\n    return [expr {$result}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[multiple_to_single {11 33 50}] == 113350}\nassert {[multiple_to_single {-1 2 3 4 5 6}] == -123456}\nassert {[multiple_to_single {10 15 20 25}] == 10152025}",
        "declaration": "proc multiple_to_single {L} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[multiple_to_single {11 33 50}] == 113350}",
        "prompt_text": "Given a list of integers, convert it into a single integer.",
        "prompt_explain": "Given a list of integers, convert it into a single integer.\n>>> multiple_to_single {11 33 50}\n113350",
        "func_title": "proc multiple_to_single {L}"
    },
    {
        "prompt": "# Write a function to find the surface area of a cube.\n# >>> surfacearea_cube 5\n# 150\nproc surfacearea_cube {l} {",
        "canonical_solution": "    set surfacearea [expr {6 * $l * $l}]\n    return $surfacearea\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surfacearea_cube 5] == 150}\nassert {[surfacearea_cube 3] == 54}\nassert {[surfacearea_cube 10] == 600}",
        "declaration": "proc surfacearea_cube {l} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surfacearea_cube 5] == 150}",
        "prompt_text": "Write a function to find the surface area of a cube.",
        "prompt_explain": "Write a function to find the surface area of a cube.\n>>> surfacearea_cube 5\n150",
        "func_title": "proc surfacearea_cube {l}"
    },
    {
        "prompt": "# Given a tuple and a list, count the occurrence of all elements of the list in the tuple.\n# >>> count_Occurrence {'a' 'a' 'c' 'b' 'd'} {'a' 'b'}\n# 3\nproc count_Occurrence {tup lst} {",
        "canonical_solution": "    set count 0\n    foreach item $tup {\n        if {$item in $lst} {\n            incr count\n        }\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Occurrence {'a' 'a' 'c' 'b' 'd'} {'a' 'b'}] == 3}\nassert {[count_Occurrence {1 2 3 1 4 6 7 1 4} {1 4 7}] == 6}\nassert {[count_Occurrence {1 2 3 4 5 6} {1 2}] == 2}",
        "declaration": "proc count_Occurrence {tup lst} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Occurrence {'a' 'a' 'c' 'b' 'd'} {'a' 'b'}] == 3}",
        "prompt_text": "Given a tuple and a list, count the occurrence of all elements of the list in the tuple.",
        "prompt_explain": "Given a tuple and a list, count the occurrence of all elements of the list in the tuple.\n>>> count_Occurrence {'a' 'a' 'c' 'b' 'd'} {'a' 'b'}\n3",
        "func_title": "proc count_Occurrence {tup lst}"
    },
    {
        "prompt": "# Given three points (x1,y1), (x2,y2), (x3,y3), check whether they form a valid triangle.\n# >>> check_Triangle 1 5 2 5 4 6\n# Yes\n# >>> check_Triangle 1 1 1 4 1 5\n# No\nproc check_Triangle {x1 y1 x2 y2 x3 y3} {",
        "canonical_solution": "    set a [expr {$x1*($y2-$y3) + $x2*($y3-$y1) + $x3*($y1-$y2)}]\n    if {$a == 0} {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_Triangle 1 5 2 5 4 6] eq \"Yes\"}\nassert {[check_Triangle 1 1 1 4 1 5] eq \"No\"}\nassert {[check_Triangle 1 1 1 1 1 1] eq \"No\"}",
        "declaration": "proc check_Triangle {x1 y1 x2 y2 x3 y3} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_Triangle 1 5 2 5 4 6] eq \"Yes\"}",
        "prompt_text": "Given three points (x1,y1), (x2,y2), (x3,y3), check whether they form a valid triangle.",
        "prompt_explain": "Given three points (x1,y1), (x2,y2), (x3,y3), check whether they form a valid triangle.\n>>> check_Triangle 1 5 2 5 4 6\nYes\n>>> check_Triangle 1 1 1 4 1 5\nNo",
        "func_title": "proc check_Triangle {x1 y1 x2 y2 x3 y3}"
    },
    {
        "prompt": "# Write a function to check whether the given month number contains 31 days or not.\n# >>> check_monthnumb_number 5\n# 1\n# >>> check_monthnumb_number 2\n# 0\nproc check_monthnumb_number {monthnum2} {",
        "canonical_solution": "    if {$monthnum2 == 1 || $monthnum2 == 3 || $monthnum2 == 5 || $monthnum2 == 7 || $monthnum2 == 8 || $monthnum2 == 10 || $monthnum2 == 12} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_monthnumb_number 5] == 1}\nassert {[check_monthnumb_number 2] == 0}\nassert {[check_monthnumb_number 6] == 0}",
        "declaration": "proc check_monthnumb_number {monthnum2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_monthnumb_number 5] == 1}",
        "prompt_text": "Write a function to check whether the given month number contains 31 days or not.",
        "prompt_explain": "Write a function to check whether the given month number contains 31 days or not.\n>>> check_monthnumb_number 5\n1\n>>> check_monthnumb_number 2\n0",
        "func_title": "proc check_monthnumb_number {monthnum2}"
    },
    {
        "prompt": "# Write a function to find the area of a rectangle.\n# >>> rectangle_area 10 20\n# 200\nproc rectangle_area {l b} {",
        "canonical_solution": "    set area [expr {$l * $b}]\n    return $area\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[rectangle_area 10 20] == 200}\nassert {[rectangle_area 10 5] == 50}\nassert {[rectangle_area 4 2] == 8}",
        "declaration": "proc rectangle_area {l b} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[rectangle_area 10 20] == 200}",
        "prompt_text": "Write a function to find the area of a rectangle.",
        "prompt_explain": "Write a function to find the area of a rectangle.\n>>> rectangle_area 10 20\n200",
        "func_title": "proc rectangle_area {l b}"
    },
    {
        "prompt": "# Given a list of integers, find the maximum product of a contiguous subarray within the list.\n# >>> max_subarray_product {1 -2 -3 0 7 -8 -2}\n# 112\nproc max_subarray_product {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set max_ending_here 1\n    set min_ending_here 1\n    set max_so_far 0\n    set flag 0\n    for {set i 0} {$i < $n} {incr i} {\n        set current [lindex $arr $i]\n        if {$current > 0} {\n            set max_ending_here [expr {$max_ending_here * $current}]\n            set min_ending_here [expr {min($min_ending_here * $current, 1)}]\n            set flag 1\n        } elseif {$current == 0} {\n            set max_ending_here 1\n            set min_ending_here 1\n        } else {\n            set temp $max_ending_here\n            set max_ending_here [expr {max($min_ending_here * $current, 1)}]\n            set min_ending_here [expr {$temp * $current}]\n        }\n        if {$max_so_far < $max_ending_here} {\n            set max_so_far $max_ending_here\n        }\n    }\n    if {$flag == 0 && $max_so_far == 0} {\n        return 0\n    }\n    return $max_so_far\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_subarray_product {1 -2 -3 0 7 -8 -2}] == 112}\nassert {[max_subarray_product {6 -3 -10 0 2}] == 180}\nassert {[max_subarray_product {-2 -40 0 -2 -3}] == 80}",
        "declaration": "proc max_subarray_product {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_subarray_product {1 -2 -3 0 7 -8 -2}] == 112}",
        "prompt_text": "Given a list of integers, find the maximum product of a contiguous subarray within the list.",
        "prompt_explain": "Given a list of integers, find the maximum product of a contiguous subarray within the list.\n>>> max_subarray_product {1 -2 -3 0 7 -8 -2}\n112",
        "func_title": "proc max_subarray_product {arr}"
    },
    {
        "prompt": "# Given a list of integers, find the peak element in the list. A peak element is an element that is greater than or equal to its neighbors.\n# >>> find_peak {1 3 20 4 1 0}\n# 2\nproc find_peak {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    proc find_peak_util {arr low high n} {\n        set mid [expr {$low + ($high - $low) / 2}]\n        set mid [expr {int($mid)}]\n        if {($mid == 0 || [lindex $arr [expr {$mid - 1}]] <= [lindex $arr $mid]) &&\n            ($mid == $n - 1 || [lindex $arr [expr {$mid + 1}]] <= [lindex $arr $mid])} {\n            return $mid\n        } elseif {$mid > 0 && [lindex $arr [expr {$mid - 1}]] > [lindex $arr $mid]} {\n            return [find_peak_util $arr $low [expr {$mid - 1}] $n]\n        } else {\n            return [find_peak_util $arr [expr {$mid + 1}] $high $n]\n        }\n    }\n    return [find_peak_util $arr 0 [expr {$n - 1}] $n]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_peak {1 3 20 4 1 0}] == 2}\nassert {[find_peak {2 3 4 5 6}] == 4}\nassert {[find_peak {8 9 11 12 14 15}] == 5}",
        "declaration": "proc find_peak {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_peak {1 3 20 4 1 0}] == 2}",
        "prompt_text": "Given a list of integers, find the peak element in the list. A peak element is an element that is greater than or equal to its neighbors.",
        "prompt_explain": "Given a list of integers, find the peak element in the list. A peak element is an element that is greater than or equal to its neighbors.\n>>> find_peak {1 3 20 4 1 0}\n2",
        "func_title": "proc find_peak {arr}"
    },
    {
        "prompt": "# Given a list of integers, find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\n# >>> max_product {3 100 4 5 150 6}\n# 45000\nproc max_product {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set mpis [list]\n    for {set i 0} {$i < $n} {incr i} {\n        lappend mpis [lindex $arr $i]\n    }\n    for {set i 1} {$i < $n} {incr i} {\n        for {set j 0} {$j < $i} {incr j} {\n            if {[lindex $arr $i] > [lindex $arr $j] && [lindex $mpis $i] < ([lindex $mpis $j] * [lindex $arr $i])} {\n                lset mpis $i [expr {[lindex $mpis $j] * [lindex $arr $i]}]\n            }\n        }\n    }\n    return [tcl::mathfunc::max {*}$mpis]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_product {3 100 4 5 150 6}] == 45000}\nassert {[max_product {4 42 55 68 80}] == 50265600}\nassert {[max_product {10 22 9 33 21 50 41 60}] == 21780000}",
        "declaration": "proc max_product {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_product {3 100 4 5 150 6}] == 45000}",
        "prompt_text": "Given a list of integers, find the maximum product formed by multiplying numbers of an increasing subsequence of that array.",
        "prompt_explain": "Given a list of integers, find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\n>>> max_product {3 100 4 5 150 6}\n45000",
        "func_title": "proc max_product {arr}"
    },
    {
        "prompt": "# Given a list of stock prices and a maximum number of transactions k, find the maximum profit that can be earned from at most k transactions.\n# >>> max_profit {1 5 2 3 7 6 4 5} 3\n# 10\nproc max_profit {price k} {",
        "canonical_solution": "    set n [llength $price]\n    set final_profit [list]\n    for {set i 0} {$i <= $k} {incr i} {\n        lappend final_profit [list]\n        for {set j 0} {$j < $n} {incr j} {\n            if {$i == 0 || $j == 0} {\n                lset final_profit $i $j 0\n            } else {\n                set max_so_far 0\n                for {set x 0} {$x < $j} {incr x} {\n                    set curr_price [expr {[lindex $price $j] - [lindex $price $x] + [lindex $final_profit [expr {$i - 1}] $x]}]\n                    if {$max_so_far < $curr_price} {\n                        set max_so_far $curr_price\n                    }\n                }\n                lset final_profit $i $j [expr {max([lindex $final_profit $i [expr {$j - 1}]], $max_so_far)}]\n            }\n        }\n    }\n    return [lindex $final_profit $k [expr {$n - 1}]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_profit {1 5 2 3 7 6 4 5} 3] == 10}\nassert {[max_profit {2 4 7 5 4 3 5} 2] == 7}\nassert {[max_profit {10 6 8 4 2} 2] == 2}",
        "declaration": "proc max_profit {price k} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_profit {1 5 2 3 7 6 4 5} 3] == 10}",
        "prompt_text": "Given a list of stock prices and a maximum number of transactions k, find the maximum profit that can be earned from at most k transactions.",
        "prompt_explain": "Given a list of stock prices and a maximum number of transactions k, find the maximum profit that can be earned from at most k transactions.\n>>> max_profit {1 5 2 3 7 6 4 5} 3\n10",
        "func_title": "proc max_profit {price k}"
    },
    {
        "prompt": "# Given a list of integers and a number n, return the remainder of the multiplication of all elements in the list divided by n.\n# >>> find_remainder {100 10 5 25 35 14} 11\n# 9\nproc find_remainder {arr n} {",
        "canonical_solution": "    set mul 1\n    foreach num $arr {\n        set mul [expr {($mul * ($num % $n)) % $n}]\n    }\n    return [expr {$mul % $n}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_remainder {100 10 5 25 35 14} 11] == 9}\nassert {[find_remainder {1 1 1} 1] == 0}\nassert {[find_remainder {1 2 1} 2] == 0}",
        "declaration": "proc find_remainder {arr n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_remainder {100 10 5 25 35 14} 11] == 9}",
        "prompt_text": "Given a list of integers and a number n, return the remainder of the multiplication of all elements in the list divided by n.",
        "prompt_explain": "Given a list of integers and a number n, return the remainder of the multiplication of all elements in the list divided by n.\n>>> find_remainder {100 10 5 25 35 14} 11\n9",
        "func_title": "proc find_remainder {arr n}"
    },
    {
        "prompt": "# Given a list of integers, check whether the list contains consecutive numbers or not.\n# >>> check_Consecutive {1 2 3 4 5}\n# 1\n# >>> check_Consecutive {1 2 3 5 6}\n# 0\nproc check_Consecutive {l} {",
        "canonical_solution": "    set sorted [lsort -integer $l]\n    set min [lindex $sorted 0]\n    set max [lindex $sorted end]\n    if {[llength $sorted] != [expr {$max - $min + 1}]} {\n        return 0\n    }\n    for {set i 1} {$i < [llength $sorted]} {incr i} {\n        if {[lindex $sorted $i] != [expr {[lindex $sorted [expr {$i - 1}]] + 1}]} {\n            return 0\n        }\n    }\n    return 1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_Consecutive {1 2 3 4 5}] == 1}\nassert {[check_Consecutive {1 2 3 5 6}] == 0}\nassert {[check_Consecutive {1 2 1}] == 0}",
        "declaration": "proc check_Consecutive {l} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_Consecutive {1 2 3 4 5}] == 1}",
        "prompt_text": "Given a list of integers, check whether the list contains consecutive numbers or not.",
        "prompt_explain": "Given a list of integers, check whether the list contains consecutive numbers or not.\n>>> check_Consecutive {1 2 3 4 5}\n1\n>>> check_Consecutive {1 2 3 5 6}\n0",
        "func_title": "proc check_Consecutive {l}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of the largest and smallest value in the list.\n# >>> big_sum {1 2 3}\n# 4\nproc big_sum {nums} {",
        "canonical_solution": "    set max_num [lindex $nums 0]\n    set min_num [lindex $nums 0]\n    foreach num $nums {\n        if {$num > $max_num} {\n            set max_num $num\n        }\n        if {$num < $min_num} {\n            set min_num $num\n        }\n    }\n    return [expr {$max_num + $min_num}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[big_sum {1 2 3}] == 4}\nassert {[big_sum {-1 2 3 4}] == 3}\nassert {[big_sum {2 3 6}] == 8}",
        "declaration": "proc big_sum {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[big_sum {1 2 3}] == 4}",
        "prompt_text": "Given a list of integers, return the sum of the largest and smallest value in the list.",
        "prompt_explain": "Given a list of integers, return the sum of the largest and smallest value in the list.\n>>> big_sum {1 2 3}\n4",
        "func_title": "proc big_sum {nums}"
    },
    {
        "prompt": "# Write a Tcl function to find the first digit of a given number.\n# >>> first_Digit 123\n# 1\nproc first_Digit {n} {",
        "canonical_solution": "    while {$n >= 10} {\n        set n [expr {$n / 10}]\n    }\n    return [expr {int($n)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[first_Digit 123] == 1}\nassert {[first_Digit 456] == 4}\nassert {[first_Digit 12] == 1}",
        "declaration": "proc first_Digit {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[first_Digit 123] == 1}",
        "prompt_text": "Write a Tcl function to find the first digit of a given number.",
        "prompt_explain": "Write a Tcl function to find the first digit of a given number.\n>>> first_Digit 123\n1",
        "func_title": "proc first_Digit {n}"
    },
    {
        "prompt": "# Given a string, find sequences of one upper case letter followed by lower case letters by using regex.\n# >>> match \"Geeks\"\n# Yes\n# >>> match \"geeksforGeeks\"\n# Yes\n# >>> match \"geeks\"\n# No\nproc match {text} {",
        "canonical_solution": "    if {[regexp {^[A-Z][a-z]+$} $text]} {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[match \"Geeks\"] eq \"Yes\"}\nassert {[match \"geeksforGeeks\"] eq \"Yes\"}\nassert {[match \"geeks\"] eq \"No\"}",
        "declaration": "proc match {text} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[match \"Geeks\"] eq \"Yes\"}",
        "prompt_text": "Given a string, find sequences of one upper case letter followed by lower case letters by using regex.",
        "prompt_explain": "Given a string, find sequences of one upper case letter followed by lower case letters by using regex.\n>>> match \"Geeks\"\nYes\n>>> match \"geeksforGeeks\"\nYes\n>>> match \"geeks\"\nNo",
        "func_title": "proc match {text}"
    },
    {
        "prompt": "# Write a Tcl function to find the first natural number whose factorial is divisible by x.\n# >>> first_Factorial_Divisible_Number 10\n# 5\nproc first_Factorial_Divisible_Number {x} {",
        "canonical_solution": "    set i 1\n    set fact 1\n    while {1} {\n        set fact [expr {$fact * $i}]\n        if {[expr {$fact % $x}] == 0} {\n            break\n        }\n        incr i\n    }\n    return $i\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[first_Factorial_Divisible_Number 10] == 5}\nassert {[first_Factorial_Divisible_Number 15] == 5}\nassert {[first_Factorial_Divisible_Number 5] == 4}",
        "declaration": "proc first_Factorial_Divisible_Number {x} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[first_Factorial_Divisible_Number 10] == 5}",
        "prompt_text": "Write a Tcl function to find the first natural number whose factorial is divisible by x.",
        "prompt_explain": "Write a Tcl function to find the first natural number whose factorial is divisible by x.\n>>> first_Factorial_Divisible_Number 10\n5",
        "func_title": "proc first_Factorial_Divisible_Number {x}"
    },
    {
        "prompt": "# Given two lists of tuples, return a new list with tuples from the first list that are not in the second list.\n# >>> remove_matching_tuple {{Hello dude} {How are} {you ?}} {{Hello dude} {How are}}\n# {{you ?}}\nproc remove_matching_tuple {test_list1 test_list2} {",
        "canonical_solution": "    set res {}\n    foreach sub $test_list1 {\n        if {$sub ni $test_list2} {\n            lappend res $sub\n        }\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[remove_matching_tuple {{Hello dude} {How are} {you ?}} {{Hello dude} {How are}}] eq {{you ?}}}\nassert {[remove_matching_tuple {{Part of} {the journey} {is end}} {{Journey the} {is end}}] eq {{Part of} {the journey} {is end}}}\nassert {[remove_matching_tuple {{Its been} {a long} {day without}} {{a long} {my friend}}] eq {{Its been} {day without}}}",
        "declaration": "proc remove_matching_tuple {test_list1 test_list2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[remove_matching_tuple {{Hello dude} {How are} {you ?}} {{Hello dude} {How are}}] eq {{you ?}}}",
        "prompt_text": "Given two lists of tuples, return a new list with tuples from the first list that are not in the second list.",
        "prompt_explain": "Given two lists of tuples, return a new list with tuples from the first list that are not in the second list.\n>>> remove_matching_tuple {{Hello dude} {How are} {you ?}} {{Hello dude} {How are}}\n{{you ?}}",
        "func_title": "proc remove_matching_tuple {test_list1 test_list2}"
    },
    {
        "prompt": "# Given a list of integers, find the largest palindromic number in the list.\n# >>> largest_palindrome {1 232 54545 999991}\n# 54545\nproc largest_palindrome {numbers} {",
        "canonical_solution": "    proc is_palindrome {n} {\n        set str [string trimleft $n 0]\n        return [expr {$str eq [string reverse $str]}]\n    }\n    set max_palindrome -1\n    foreach number $numbers {\n        if {[is_palindrome $number] && $number > $max_palindrome} {\n            set max_palindrome $number\n        }\n    }\n    return $max_palindrome\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[largest_palindrome {1 232 54545 999991}] == 54545}\nassert {[largest_palindrome {1 2 3 4 5 50}] == 5}\nassert {[largest_palindrome {1 3 7 9 45}] == 9}",
        "declaration": "proc largest_palindrome {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[largest_palindrome {1 232 54545 999991}] == 54545}",
        "prompt_text": "Given a list of integers, find the largest palindromic number in the list.",
        "prompt_explain": "Given a list of integers, find the largest palindromic number in the list.\n>>> largest_palindrome {1 232 54545 999991}\n54545",
        "func_title": "proc largest_palindrome {numbers}"
    },
    {
        "prompt": "# Write a function to find the area of a pentagon.\n# >>> area_pentagon 5\n# 43.01193501472417\nproc area_pentagon {a} {",
        "canonical_solution": "    set area [expr {(sqrt(5 * (5 + 2 * sqrt(5))) * pow($a, 2)) / 4.0}]\n    return $area\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[area_pentagon 5] == 43.01193501472417}\nassert {[area_pentagon 10] == 172.0477400588967}\nassert {[area_pentagon 15] == 387.10741513251753}",
        "declaration": "proc area_pentagon {a} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[area_pentagon 5] == 43.01193501472417}",
        "prompt_text": "Write a function to find the area of a pentagon.",
        "prompt_explain": "Write a function to find the area of a pentagon.\n>>> area_pentagon 5\n43.01193501472417",
        "func_title": "proc area_pentagon {a}"
    },
    {
        "prompt": "# Write a function to find the surface area of a cone.\n# >>> surfacearea_cone 5 12\n# 282.7433388230814\nproc surfacearea_cone {r h} {",
        "canonical_solution": "    set l [expr {sqrt($r * $r + $h * $h)}]\n    set SA [expr {3.141592653589793 * $r * ($r + $l)}]\n    return $SA\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surfacearea_cone 5 12] == 282.7433388230814}\nassert {[surfacearea_cone 10 15] == 880.5179353159282}\nassert {[surfacearea_cone 19 17] == 2655.923961165254}",
        "declaration": "proc surfacearea_cone {r h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surfacearea_cone 5 12] == 282.7433388230814}",
        "prompt_text": "Write a function to find the surface area of a cone.",
        "prompt_explain": "Write a function to find the surface area of a cone.\n>>> surfacearea_cone 5 12\n282.7433388230814",
        "func_title": "proc surfacearea_cone {r h}"
    },
    {
        "prompt": "# Write a Tcl function to find the greatest common divisor (gcd) of two positive integers.\n# >>> gcd 12 17\n# 1\nproc gcd {x y} {",
        "canonical_solution": "    if {$y == 0} {\n        return $x\n    } else {\n        return [gcd $y [expr {$x % $y}]]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[gcd 12 17] == 1}\nassert {[gcd 4 6] == 2}\nassert {[gcd 2 9] == 1}",
        "declaration": "proc gcd {x y} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[gcd 12 17] == 1}",
        "prompt_text": "Write a Tcl function to find the greatest common divisor (gcd) of two positive integers.",
        "prompt_explain": "Write a Tcl function to find the greatest common divisor (gcd) of two positive integers.\n>>> gcd 12 17\n1",
        "func_title": "proc gcd {x y}"
    },
    {
        "prompt": "# Write a function to find the diameter of a circle.\n# >>> diameter_circle 10\n# 20\nproc diameter_circle {r} {",
        "canonical_solution": "    set diameter [expr {2 * $r}]\n    return $diameter\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[diameter_circle 10] == 20}\nassert {[diameter_circle 40] == 80}\nassert {[diameter_circle 15] == 30}",
        "declaration": "proc diameter_circle {r} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[diameter_circle 10] == 20}",
        "prompt_text": "Write a function to find the diameter of a circle.",
        "prompt_explain": "Write a function to find the diameter of a circle.\n>>> diameter_circle 10\n20",
        "func_title": "proc diameter_circle {r}"
    },
    {
        "prompt": "# Given two numbers, find the number of common divisors between them.\n# >>> num_comm_div 2 4\n# 2\nproc num_comm_div {x y} {",
        "canonical_solution": "    proc ngcd {x y} {\n        set i 1\n        while {$i <= $x && $i <= $y} {\n            if {$x % $i == 0 && $y % $i == 0} {\n                set gcd $i\n            }\n            incr i\n        }\n        return $gcd\n    }\n    set n [ngcd $x $y]\n    set result 0\n    set z [expr {int(sqrt($n))}]\n    set i 1\n    while {$i <= $z} {\n        if {$n % $i == 0} {\n            incr result 2\n            if {$i == $n / $i} {\n                incr result -1\n            }\n        }\n        incr i\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[num_comm_div 2 4] == 2}\nassert {[num_comm_div 2 8] == 2}\nassert {[num_comm_div 12 24] == 6}",
        "declaration": "proc num_comm_div {x y} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[num_comm_div 2 4] == 2}",
        "prompt_text": "Given two numbers, find the number of common divisors between them.",
        "prompt_explain": "Given two numbers, find the number of common divisors between them.\n>>> num_comm_div 2 4\n2",
        "func_title": "proc num_comm_div {x y}"
    },
    {
        "prompt": "# Write a Tcl function to find the remainder of two numbers.\n# >>> find 3 3\n# 0\nproc find {n m} {",
        "canonical_solution": "    set r [expr {$n % $m}]\n    return $r\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find 3 3] == 0}\nassert {[find 10 3] == 1}\nassert {[find 16 5] == 1}",
        "declaration": "proc find {n m} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find 3 3] == 0}",
        "prompt_text": "Write a Tcl function to find the remainder of two numbers.",
        "prompt_explain": "Write a Tcl function to find the remainder of two numbers.\n>>> find 3 3\n0",
        "func_title": "proc find {n m}"
    },
    {
        "prompt": "# Write a Tcl function to find the cube sum of first n natural numbers.\n# >>> sum_Of_Series 5\n# 225\nproc sum_Of_Series {n} {",
        "canonical_solution": "    set sum 0\n    for {set i 1} {$i <= $n} {incr i} {\n        set sum [expr {$sum + $i * $i * $i}]\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_Of_Series 5] == 225}\nassert {[sum_Of_Series 2] == 9}\nassert {[sum_Of_Series 3] == 36}",
        "declaration": "proc sum_Of_Series {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_Of_Series 5] == 225}",
        "prompt_text": "Write a Tcl function to find the cube sum of first n natural numbers.",
        "prompt_explain": "Write a Tcl function to find the cube sum of first n natural numbers.\n>>> sum_Of_Series 5\n225",
        "func_title": "proc sum_Of_Series {n}"
    },
    {
        "prompt": "# Write a function to check if the common elements between two given lists are in the same order or not.\n# >>> same_order {red green black orange} {red pink green white black}\n# 1\nproc same_order {l1 l2} {",
        "canonical_solution": "    set common_elements [lsort -unique [concat $l1 $l2]]\n    set l1_common [lsearch -all -inline $l1 $common_elements]\n    set l2_common [lsearch -all -inline $l2 $common_elements]\n    return [expr {$l1_common == $l2_common}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[same_order {red green black orange} {red pink green white black}] == 1}\nassert {[same_order {red pink green white black} {white orange pink black}] == 0}\nassert {[same_order {red green black orange} {red pink green white black}] == 1}",
        "declaration": "proc same_order {l1 l2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[same_order {red green black orange} {red pink green white black}] == 1}",
        "prompt_text": "Write a function to check if the common elements between two given lists are in the same order or not.",
        "prompt_explain": "Write a function to check if the common elements between two given lists are in the same order or not.\n>>> same_order {red green black orange} {red pink green white black}\n1",
        "func_title": "proc same_order {l1 l2}"
    },
    {
        "prompt": "# Write a Tcl function to find the average of odd numbers till a given odd number.\n# >>> average_Odd 9\n# 5\nproc average_Odd {n} {",
        "canonical_solution": "    if {$n % 2 == 0} {\n        return \"Invalid Input\"\n    }\n    set sm 0\n    set count 0\n    while {$n >= 1} {\n        incr count\n        incr sm $n\n        incr n -2\n    }\n    return [expr {$sm / $count}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average_Odd 9] == 5}\nassert {[average_Odd 5] == 3}\nassert {[average_Odd 11] == 6}",
        "declaration": "proc average_Odd {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[average_Odd 9] == 5}",
        "prompt_text": "Write a Tcl function to find the average of odd numbers till a given odd number.",
        "prompt_explain": "Write a Tcl function to find the average of odd numbers till a given odd number.\n>>> average_Odd 9\n5",
        "func_title": "proc average_Odd {n}"
    },
    {
        "prompt": "# Write a Tcl function to find the minimum sum of factors of a given number.\n# >>> find_Min_Sum 12\n# 7\nproc find_Min_Sum {num} {",
        "canonical_solution": "    set sum 0\n    set i 2\n    while {$i * $i <= $num} {\n        while {$num % $i == 0} {\n            set sum [expr {$sum + $i}]\n            set num [expr {$num / $i}]\n        }\n        set i [expr {$i + 1}]\n    }\n    set sum [expr {$sum + $num}]\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Min_Sum 12] == 7}\nassert {[find_Min_Sum 105] == 15}\nassert {[find_Min_Sum 2] == 2}",
        "declaration": "proc find_Min_Sum {num} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Min_Sum 12] == 7}",
        "prompt_text": "Write a Tcl function to find the minimum sum of factors of a given number.",
        "prompt_explain": "Write a Tcl function to find the minimum sum of factors of a given number.\n>>> find_Min_Sum 12\n7",
        "func_title": "proc find_Min_Sum {num}"
    },
    {
        "prompt": "# Given a list of integers and a number m, check if there is a subset with sum divisible by m.\n# >>> modular_sum {3 1 7 5} 4 6\n# True\nproc modular_sum {arr n m} {",
        "canonical_solution": "    if {$n > $m} {\n        return True\n    }\n    set DP [list]\n    for {set i 0} {$i < $m} {incr i} {\n        lappend DP False\n    }\n    for {set i 0} {$i < $n} {incr i} {\n        if {[lindex $DP 0]} {\n            return True\n        }\n        set temp [list]\n        for {set j 0} {$j < $m} {incr j} {\n            lappend temp False\n        }\n        for {set j 0} {$j < $m} {incr j} {\n            if {[lindex $DP $j]} {\n                if {![lindex $DP [expr {($j + [lindex $arr $i]) % $m}]]} {\n                    lset temp [expr {($j + [lindex $arr $i]) % $m}] True\n                }\n            }\n        }\n        for {set j 0} {$j < $m} {incr j} {\n            if {[lindex $temp $j]} {\n                lset DP $j True\n            }\n        }\n        lset DP [expr {[lindex $arr $i] % $m}] True\n    }\n    return [lindex $DP 0]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[modular_sum {3 1 7 5} 4 6] == True}\nassert {[modular_sum {1 7} 2 5] == False}\nassert {[modular_sum {1 6} 2 5] == False}",
        "declaration": "proc modular_sum {arr n m} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[modular_sum {3 1 7 5} 4 6] == True}",
        "prompt_text": "Given a list of integers and a number m, check if there is a subset with sum divisible by m.",
        "prompt_explain": "Given a list of integers and a number m, check if there is a subset with sum divisible by m.\n>>> modular_sum {3 1 7 5} 4 6\nTrue",
        "func_title": "proc modular_sum {arr n m}"
    },
    {
        "prompt": "# Given a list of integers, return the largest positive number from the list.\n# >>> largest_pos {1 2 3 4 -1}\n# 4\nproc largest_pos {list1} {",
        "canonical_solution": "    set max [lindex $list1 0]\n    foreach x $list1 {\n        if {$x > $max} {\n            set max $x\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[largest_pos {1 2 3 4 -1}] == 4}\nassert {[largest_pos {0 1 2 -5 -1 6}] == 6}\nassert {[largest_pos {0 0 1 0}] == 1}",
        "declaration": "proc largest_pos {list1} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[largest_pos {1 2 3 4 -1}] == 4}",
        "prompt_text": "Given a list of integers, return the largest positive number from the list.",
        "prompt_explain": "Given a list of integers, return the largest positive number from the list.\n>>> largest_pos {1 2 3 4 -1}\n4",
        "func_title": "proc largest_pos {list1}"
    },
    {
        "prompt": "# Write a function to calculate the volume of a tetrahedron.\n# >>> volume_tetrahedron 10\n# 117.85\nproc volume_tetrahedron {num} {",
        "canonical_solution": "    set volume [expr {pow($num, 3) / (6 * sqrt(2))}]\n    return [format \"%.2f\" $volume]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_tetrahedron 10] == 117.85}\nassert {[volume_tetrahedron 15] == 397.75}\nassert {[volume_tetrahedron 20] == 942.81}",
        "declaration": "proc volume_tetrahedron {num} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[volume_tetrahedron 10] == 117.85}",
        "prompt_text": "Write a function to calculate the volume of a tetrahedron.",
        "prompt_explain": "Write a function to calculate the volume of a tetrahedron.\n>>> volume_tetrahedron 10\n117.85",
        "func_title": "proc volume_tetrahedron {num}"
    },
    {
        "prompt": "# Write a function to check if the triangle is scalene or not.\n# A scalene triangle is a triangle that has three unequal sides.\n# >>> check_scalene 6 8 12\n# 1\n# >>> check_scalene 6 6 12\n# 0\nproc check_scalene {x y z} {",
        "canonical_solution": "    if {$x != $y && $y != $z && $z != $x} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_scalene 6 8 12] == 1}\nassert {[check_scalene 6 6 12] == 0}\nassert {[check_scalene 6 15 20] == 1}",
        "declaration": "proc check_scalene {x y z} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_scalene 6 8 12] == 1}",
        "prompt_text": "Write a function to check if the triangle is scalene or not. A scalene triangle is a triangle that has three unequal sides.",
        "prompt_explain": "Write a function to check if the triangle is scalene or not. A scalene triangle is a triangle that has three unequal sides.\n>>> check_scalene 6 8 12\n1\n>>> check_scalene 6 6 12\n0",
        "func_title": "proc check_scalene {x y z}"
    },
    {
        "prompt": "# Given an array of integers, find the sum of the maximum increasing subsequence.\n# >>> max_sum_increasing_subsequence {1 101 2 3 100 4 5}\n# 106\nproc max_sum_increasing_subsequence {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set max 0\n    set msis [lrepeat $n 0]\n    for {set i 0} {$i < $n} {incr i} {\n        lset msis $i [lindex $arr $i]\n    }\n    for {set i 1} {$i < $n} {incr i} {\n        for {set j 0} {$j < $i} {incr j} {\n            if {[lindex $arr $i] > [lindex $arr $j] && [lindex $msis $i] < [expr {[lindex $msis $j] + [lindex $arr $i]}]} {\n                lset msis $i [expr {[lindex $msis $j] + [lindex $arr $i]}]\n            }\n        }\n    }\n    for {set i 0} {$i < $n} {incr i} {\n        if {$max < [lindex $msis $i]} {\n            set max [lindex $msis $i]\n        }\n    }\n    return $max\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sum_increasing_subsequence {1 101 2 3 100 4 5}] == 106}\nassert {[max_sum_increasing_subsequence {3 4 5 10}] == 22}\nassert {[max_sum_increasing_subsequence {10 5 4 3}] == 10}",
        "declaration": "proc max_sum_increasing_subsequence {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sum_increasing_subsequence {1 101 2 3 100 4 5}] == 106}",
        "prompt_text": "Given an array of integers, find the sum of the maximum increasing subsequence.",
        "prompt_explain": "Given an array of integers, find the sum of the maximum increasing subsequence.\n>>> max_sum_increasing_subsequence {1 101 2 3 100 4 5}\n106",
        "func_title": "proc max_sum_increasing_subsequence {arr}"
    },
    {
        "prompt": "# Given two lines represented by their coefficients (a1, b1, c1) and (a2, b2, c2), check if they are parallel.\n# >>> parallel_lines {2 3 4} {2 3 8}\n# 1\nproc parallel_lines {line1 line2} {",
        "canonical_solution": "    set a1 [lindex $line1 0]\n    set b1 [lindex $line1 1]\n    set a2 [lindex $line2 0]\n    set b2 [lindex $line2 1]\n    if {$a1 * $b2 == $a2 * $b1} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[parallel_lines {2 3 4} {2 3 8}] == 1}\nassert {[parallel_lines {2 3 4} {4 -3 8}] == 0}\nassert {[parallel_lines {3 3} {5 5}] == 1}",
        "declaration": "proc parallel_lines {line1 line2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[parallel_lines {2 3 4} {2 3 8}] == 1}",
        "prompt_text": "Given two lines represented by their coefficients (a1, b1, c1) and (a2, b2, c2), check if they are parallel.",
        "prompt_explain": "Given two lines represented by their coefficients (a1, b1, c1) and (a2, b2, c2), check if they are parallel.\n>>> parallel_lines {2 3 4} {2 3 8}\n1",
        "func_title": "proc parallel_lines {line1 line2}"
    },
    {
        "prompt": "# Given a list of integers and a target sum, find all pairs in the list whose sum is equal to the target sum.\n# >>> get_pairs_count {1 5 7 -1 5} 6\n# 3\nproc get_pairs_count {arr sum} {",
        "canonical_solution": "    set count 0\n    set n [llength $arr]\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $n} {incr j} {\n            if {[expr {[lindex $arr $i] + [lindex $arr $j]}] == $sum} {\n                incr count\n            }\n        }\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_pairs_count {1 5 7 -1 5} 6] == 3}\nassert {[get_pairs_count {1 5 7 -1} 6] == 2}\nassert {[get_pairs_count {1 1 1 1} 2] == 6}",
        "declaration": "proc get_pairs_count {arr sum} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_pairs_count {1 5 7 -1 5} 6] == 3}",
        "prompt_text": "Given a list of integers and a target sum, find all pairs in the list whose sum is equal to the target sum.",
        "prompt_explain": "Given a list of integers and a target sum, find all pairs in the list whose sum is equal to the target sum.\n>>> get_pairs_count {1 5 7 -1 5} 6\n3",
        "func_title": "proc get_pairs_count {arr sum}"
    },
    {
        "prompt": "# Write a function to find the nth Jacobsthal-Lucas number.\n# >>> jacobsthal_lucas 5\n# 31\nproc jacobsthal_lucas {n} {",
        "canonical_solution": "    if {$n == 0} { return 2 }\n    if {$n == 1} { return 1 }\n    set dp [list 2 1]\n    for {set i 2} {$i <= $n} {incr i} {\n        lappend dp [expr {[lindex $dp [expr {$i - 1}]] + 2 * [lindex $dp [expr {$i - 2}]]}]\n    }\n    return [lindex $dp $n]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[jacobsthal_lucas 5] == 31}\nassert {[jacobsthal_lucas 2] == 5}\nassert {[jacobsthal_lucas 4] == 17}",
        "declaration": "proc jacobsthal_lucas {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[jacobsthal_lucas 5] == 31}",
        "prompt_text": "Write a function to find the nth Jacobsthal-Lucas number.",
        "prompt_explain": "Write a function to find the nth Jacobsthal-Lucas number.\n>>> jacobsthal_lucas 5\n31",
        "func_title": "proc jacobsthal_lucas {n}"
    },
    {
        "prompt": "# Given a list of integers, return the ratio of negative numbers in the list.\n# >>> negative_count {0 1 2 -1 -5 6 0 -3 -2 3 4 6 8}\n# 0.31\nproc negative_count {nums} {",
        "canonical_solution": "    set n [llength $nums]\n    set n1 0\n    foreach x $nums {\n        if {$x < 0} {\n            incr n1\n        }\n    }\n    return [expr {round(double($n1)/$n*100)/100.0}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[negative_count {0 1 2 -1 -5 6 0 -3 -2 3 4 6 8}] == 0.31}\nassert {[negative_count {2 1 2 -1 -5 6 4 -3 -2 3 4 6 8}] == 0.31}\nassert {[negative_count {2 4 -6 -9 11 -12 14 -5 17}] == 0.44}",
        "declaration": "proc negative_count {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[negative_count {0 1 2 -1 -5 6 0 -3 -2 3 4 6 8}] == 0.31}",
        "prompt_text": "Given a list of integers, return the ratio of negative numbers in the list.",
        "prompt_explain": "Given a list of integers, return the ratio of negative numbers in the list.\n>>> negative_count {0 1 2 -1 -5 6 0 -3 -2 3 4 6 8}\n0.31",
        "func_title": "proc negative_count {nums}"
    },
    {
        "prompt": "# Given a list of coin denominations and a value, return the minimum number of coins needed to make that value.\n# >>> min_coins {9 6 5 1} 11\n# 2\nproc min_coins {coins V} {",
        "canonical_solution": "    set m [llength $coins]\n    if {$V == 0} {\n        return 0\n    }\n    set res 2147483647\n    for {set i 0} {$i < $m} {incr i} {\n        if {[lindex $coins $i] <= $V} {\n            set sub_res [min_coins $coins [expr {$V - [lindex $coins $i]}]]\n            if {$sub_res != 2147483647 && [expr {$sub_res + 1}] < $res} {\n                set res [expr {$sub_res + 1}]\n            }\n        }\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_coins {9 6 5 1} 11] == 2}\nassert {[min_coins {4 5 6 7 8 9} 9] == 1}\nassert {[min_coins {1 2 3} 4] == 2}",
        "declaration": "proc min_coins {coins V} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_coins {9 6 5 1} 11] == 2}",
        "prompt_text": "Given a list of coin denominations and a value, return the minimum number of coins needed to make that value.",
        "prompt_explain": "Given a list of coin denominations and a value, return the minimum number of coins needed to make that value.\n>>> min_coins {9 6 5 1} 11\n2",
        "func_title": "proc min_coins {coins V}",
        "test_setup_code": "",
        "test_list": [
            "assert {[min_coins {9 6 5 1} 11] == 2}",
            "assert {[min_coins {4 5 6 7 8 9} 9] == 1}",
            "assert {[min_coins {1 2 3} 4] == 2}"
        ],
        "challenge_test_list": []
    },
    {
        "prompt": "# Write a function to check if the two given strings are permutations of each other.\n# >>> check_permutation \"abc\" \"cba\"\n# 1\n# >>> check_permutation \"test\" \"ttew\"\n# 0\nproc check_permutation {str1 str2} {",
        "canonical_solution": "    set n1 [string length $str1]\n    set n2 [string length $str2]\n    if {$n1 != $n2} {\n        return 0\n    }\n    set a [lsort [split $str1 \"\"]]\n    set str1 [join $a \"\"]\n    set b [lsort [split $str2 \"\"]]\n    set str2 [join $b \"\"]\n    for {set i 0} {$i < $n1} {incr i} {\n        if {[string index $str1 $i] != [string index $str2 $i]} {\n            return 0\n        }\n    }\n    return 1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_permutation \"abc\" \"cba\"] == 1}\nassert {[check_permutation \"test\" \"ttew\"] == 0}\nassert {[check_permutation \"xxyz\" \"yxzx\"] == 1}",
        "declaration": "proc check_permutation {str1 str2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_permutation \"abc\" \"cba\"] == 1}",
        "prompt_text": "Write a function to check if the two given strings are permutations of each other.",
        "prompt_explain": "Write a function to check if the two given strings are permutations of each other.\n>>> check_permutation \"abc\" \"cba\"\n1\n>>> check_permutation \"test\" \"ttew\"\n0",
        "func_title": "proc check_permutation {str1 str2}"
    },
    {
        "prompt": "# Given a list of integers, write a Tcl function to find the difference between the highest and least frequencies in the list.\n# >>> find_Diff {1 1 2 2 7 8 4 5 1 4}\n# 2\nproc find_Diff {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set arr [lsort -integer $arr]\n    set count 0\n    set max_count 0\n    set min_count $n\n    for {set i 0} {$i < [expr {$n - 1}]} {incr i} {\n        if {[lindex $arr $i] == [lindex $arr [expr {$i + 1}]]} {\n            incr count\n            continue\n        } else {\n            set max_count [expr {max($max_count, $count)}]\n            set min_count [expr {min($min_count, $count)}]\n            set count 0\n        }\n    }\n    return [expr {$max_count - $min_count}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Diff {1 1 2 2 7 8 4 5 1 4}] == 2}\nassert {[find_Diff {1 7 9 2 3 3 1 3 3}] == 3}\nassert {[find_Diff {1 2 1 2}] == 0}",
        "declaration": "proc find_Diff {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Diff {1 1 2 2 7 8 4 5 1 4}] == 2}",
        "prompt_text": "Given a list of integers, write a Tcl function to find the difference between the highest and least frequencies in the list.",
        "prompt_explain": "Given a list of integers, write a Tcl function to find the difference between the highest and least frequencies in the list.\n>>> find_Diff {1 1 2 2 7 8 4 5 1 4}\n2",
        "func_title": "proc find_Diff {arr}"
    },
    {
        "prompt": "# Given a list of integers, find the length of the longest increasing subsequence.\n# >>> longest_increasing_subsequence {10 22 9 33 21 50 41 60}\n# 5\nproc longest_increasing_subsequence {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set lis [lrepeat $n 1]\n    for {set i 1} {$i < $n} {incr i} {\n        for {set j 0} {$j < $i} {incr j} {\n            if {[lindex $arr $i] > [lindex $arr $j] && [lindex $lis $i] < [expr {[lindex $lis $j] + 1}]} {\n                lset lis $i [expr {[lindex $lis $j] + 1}]\n            }\n        }\n    }\n    set maximum 0\n    for {set i 0} {$i < $n} {incr i} {\n        if {[lindex $lis $i] > $maximum} {\n            set maximum [lindex $lis $i]\n        }\n    }\n    return $maximum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[longest_increasing_subsequence {10 22 9 33 21 50 41 60}] == 5}\nassert {[longest_increasing_subsequence {3 10 2 1 20}] == 3}\nassert {[longest_increasing_subsequence {50 3 10 7 40 80}] == 4}",
        "declaration": "proc longest_increasing_subsequence {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[longest_increasing_subsequence {10 22 9 33 21 50 41 60}] == 5}",
        "prompt_text": "Given a list of integers, find the length of the longest increasing subsequence.",
        "prompt_explain": "Given a list of integers, find the length of the longest increasing subsequence.\n>>> longest_increasing_subsequence {10 22 9 33 21 50 41 60}\n5",
        "func_title": "proc longest_increasing_subsequence {arr}"
    },
    {
        "prompt": "# Write a Tcl function to find the sum of fifth power of first n odd natural numbers.\n# >>> odd_Num_Sum 1\n# 1\n# >>> odd_Num_Sum 2\n# 244\n# >>> odd_Num_Sum 3\n# 3369\nproc odd_Num_Sum {n} {",
        "canonical_solution": "    set j 0\n    set sm 0\n    for {set i 1} {$i <= $n} {incr i} {\n        set j [expr {2*$i-1}]\n        set sm [expr {$sm + $j**5}]\n    }\n    return $sm\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[odd_Num_Sum 1] == 1}\nassert {[odd_Num_Sum 2] == 244}\nassert {[odd_Num_Sum 3] == 3369}",
        "declaration": "proc odd_Num_Sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[odd_Num_Sum 1] == 1}",
        "prompt_text": "Write a Tcl function to find the sum of fifth power of first n odd natural numbers.",
        "prompt_explain": "Write a Tcl function to find the sum of fifth power of first n odd natural numbers.\n>>> odd_Num_Sum 1\n1\n>>> odd_Num_Sum 2\n244\n>>> odd_Num_Sum 3\n3369",
        "func_title": "proc odd_Num_Sum {n}"
    },
    {
        "prompt": "# Write a Tcl function to find the difference between sum of cubes of first n natural numbers and the sum of first n natural numbers.\n# >>> difference 3\n# 30\nproc difference {n} {",
        "canonical_solution": "    set S [expr {($n * ($n + 1)) / 2}]\n    set res [expr {$S * ($S - 1)}]\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[difference 3] == 30}\nassert {[difference 5] == 210}\nassert {[difference 2] == 6}",
        "declaration": "proc difference {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[difference 3] == 30}",
        "prompt_text": "Write a Tcl function to find the difference between sum of cubes of first n natural numbers and the sum of first n natural numbers.",
        "prompt_explain": "Write a Tcl function to find the difference between sum of cubes of first n natural numbers and the sum of first n natural numbers.\n>>> difference 3\n30",
        "func_title": "proc difference {n}"
    },
    {
        "prompt": "# Given a list of integers, return the count of pairs whose XOR is an odd number.\n# >>> find_Odd_Pair {5 4 7 2 1}\n# 6\nproc find_Odd_Pair {A N} {",
        "canonical_solution": "    set oddPair 0\n    for {set i 0} {$i < $N} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $N} {incr j} {\n            if {([lindex $A $i] ^ [lindex $A $j]) % 2 != 0} {\n                incr oddPair\n            }\n        }\n    }\n    return $oddPair\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Odd_Pair {5 4 7 2 1} 5] == 6}\nassert {[find_Odd_Pair {7 2 8 1 0 5 11} 7] == 12}\nassert {[find_Odd_Pair {1 2 3} 3] == 2}",
        "declaration": "proc find_Odd_Pair {A N} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Odd_Pair {5 4 7 2 1} 5] == 6}",
        "prompt_text": "Given a list of integers, return the count of pairs whose XOR is an odd number.",
        "prompt_explain": "Given a list of integers, return the count of pairs whose XOR is an odd number.\n>>> find_Odd_Pair {5 4 7 2 1}\n6",
        "func_title": "proc find_Odd_Pair {A N}"
    },
    {
        "prompt": "# Write a Tcl function to find the digit distance between two integers.\n# >>> digit_distance_nums 1 2\n# 1\nproc digit_distance_nums {n1 n2} {",
        "canonical_solution": "    set diff [expr {abs($n1 - $n2)}]\n    set sum 0\n    foreach digit [split $diff {}] {\n        incr sum $digit\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[digit_distance_nums 1 2] == 1}\nassert {[digit_distance_nums 23 56] == 6}\nassert {[digit_distance_nums 123 256] == 7}",
        "declaration": "proc digit_distance_nums {n1 n2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[digit_distance_nums 1 2] == 1}",
        "prompt_text": "Write a Tcl function to find the digit distance between two integers.",
        "prompt_explain": "Write a Tcl function to find the digit distance between two integers.\n>>> digit_distance_nums 1 2\n1",
        "func_title": "proc digit_distance_nums {n1 n2}"
    },
    {
        "prompt": "# Given a list of integers, find the largest sum of contiguous subarray in the given array.\n# >>> max_sub_array_sum {-2 -3 4 -1 -2 1 5 -3}\n# 7\nproc max_sub_array_sum {a} {",
        "canonical_solution": "    set max_so_far 0\n    set max_ending_here 0\n    set size [llength $a]\n    for {set i 0} {$i < $size} {incr i} {\n        set max_ending_here [expr {$max_ending_here + [lindex $a $i]}]\n        if {$max_ending_here < 0} {\n            set max_ending_here 0\n        } elseif {$max_so_far < $max_ending_here} {\n            set max_so_far $max_ending_here\n        }\n    }\n    return $max_so_far\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sub_array_sum {-2 -3 4 -1 -2 1 5 -3}] == 7}\nassert {[max_sub_array_sum {-3 -4 5 -2 -3 2 6 -4}] == 8}\nassert {[max_sub_array_sum {-4 -5 6 -3 -4 3 7 -5}] == 10}",
        "declaration": "proc max_sub_array_sum {a} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sub_array_sum {-2 -3 4 -1 -2 1 5 -3}] == 7}",
        "prompt_text": "Given a list of integers, find the largest sum of contiguous subarray in the given array.",
        "prompt_explain": "Given a list of integers, find the largest sum of contiguous subarray in the given array.\n>>> max_sub_array_sum {-2 -3 4 -1 -2 1 5 -3}\n7",
        "func_title": "proc max_sub_array_sum {a}"
    },
    {
        "prompt": "# Given a list of lists, find the maximum length of sublist.\n# >>> Find_Max_Length {{1} {1 4} {5 6 7 8}}\n# 4\nproc Find_Max_Length {lst} {",
        "canonical_solution": "    set maxLength 0\n    foreach x $lst {\n        set currentLength [llength $x]\n        if {$currentLength > $maxLength} {\n            set maxLength $currentLength\n        }\n    }\n    return $maxLength\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Find_Max_Length {{1} {1 4} {5 6 7 8}}] == 4}\nassert {[Find_Max_Length {{0 1} {2 2} {3 2 1}}] == 3}\nassert {[Find_Max_Length {{7} {22 23} {13 14 15} {10 20 30 40 50}}] == 5}",
        "declaration": "proc Find_Max_Length {lst} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Find_Max_Length {{1} {1 4} {5 6 7 8}}] == 4}",
        "prompt_text": "Given a list of lists, find the maximum length of sublist.",
        "prompt_explain": "Given a list of lists, find the maximum length of sublist.\n>>> Find_Max_Length {{1} {1 4} {5 6 7 8}}\n4",
        "func_title": "proc Find_Max_Length {lst}"
    },
    {
        "prompt": "# Given a list of integers, count the number of unequal element pairs.\n# >>> count_Pairs {1 2 1}\n# 2\nproc count_Pairs {arr} {",
        "canonical_solution": "    set cnt 0\n    set n [llength $arr]\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $n} {incr j} {\n            if {[lindex $arr $i] != [lindex $arr $j]} {\n                incr cnt\n            }\n        }\n    }\n    return $cnt\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Pairs {1 2 1}] == 2}\nassert {[count_Pairs {1 1 1 1}] == 0}\nassert {[count_Pairs {1 2 3 4 5}] == 10}",
        "declaration": "proc count_Pairs {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Pairs {1 2 1}] == 2}",
        "prompt_text": "Given a list of integers, count the number of unequal element pairs.",
        "prompt_explain": "Given a list of integers, count the number of unequal element pairs.\n>>> count_Pairs {1 2 1}\n2",
        "func_title": "proc count_Pairs {arr}"
    },
    {
        "prompt": "# Write a function to get the sum of a non-negative integer.\n# >>> sum_digits 345\n# 12\nproc sum_digits {n} {",
        "canonical_solution": "    if {$n == 0} {\n        return 0\n    } else {\n        return [expr {$n % 10 + [sum_digits [expr {int($n / 10)}]]}]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_digits 345] == 12}\nassert {[sum_digits 12] == 3}\nassert {[sum_digits 97] == 16}",
        "declaration": "proc sum_digits {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_digits 345] == 12}",
        "prompt_text": "Write a function to get the sum of a non-negative integer.",
        "prompt_explain": "Write a function to get the sum of a non-negative integer.\n>>> sum_digits 345\n12",
        "func_title": "proc sum_digits {n}"
    },
    {
        "prompt": "# Given a list of integers, calculate the product of the unique numbers in the list.\n# >>> unique_product {10 20 30 40 20 50 60 40}\n# 720000000\nproc unique_product {list_data} {",
        "canonical_solution": "    set temp [lsort -unique $list_data]\n    set p 1\n    foreach i $temp {\n        set p [expr {$p * $i}]\n    }\n    return $p\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[unique_product {10 20 30 40 20 50 60 40}] == 720000000}\nassert {[unique_product {1 2 3 1}] == 6}\nassert {[unique_product {7 8 9 0 1 1}] == 0}",
        "declaration": "proc unique_product {list_data} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[unique_product {10 20 30 40 20 50 60 40}] == 720000000}",
        "prompt_text": "Given a list of integers, calculate the product of the unique numbers in the list.",
        "prompt_explain": "Given a list of integers, calculate the product of the unique numbers in the list.\n>>> unique_product {10 20 30 40 20 50 60 40}\n720000000",
        "func_title": "proc unique_product {list_data}"
    },
    {
        "prompt": "# Write a function to find the surface area of a cylinder.\n# >>> surfacearea_cylinder 10 5\n# 942.45\nproc surfacearea_cylinder {r h} {",
        "canonical_solution": "    set pi 3.1415\n    set surfacearea [expr {2 * $pi * $r * $r + 2 * $pi * $r * $h}]\n    return $surfacearea\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surfacearea_cylinder 10 5] == 942.45}\nassert {[surfacearea_cylinder 4 5] == 226.18800000000002}\nassert {[surfacearea_cylinder 4 10] == 351.848}",
        "declaration": "proc surfacearea_cylinder {r h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surfacearea_cylinder 10 5] == 942.45}",
        "prompt_text": "Write a function to find the surface area of a cylinder.",
        "prompt_explain": "Write a function to find the surface area of a cylinder.\n>>> surfacearea_cylinder 10 5\n942.45",
        "func_title": "proc surfacearea_cylinder {r h}"
    },
    {
        "prompt": "# Given two lists of integers, check whether the second list is a subarray of the first or not.\n# >>> is_Sub_Array {1 4 3 5} {1 2}\n# 0\n# >>> is_Sub_Array {1 2 1} {1 2 1}\n# 1\nproc is_Sub_Array {A B} {",
        "canonical_solution": "    set n [llength $A]\n    set m [llength $B]\n    set i 0\n    set j 0\n    while {$i < $n && $j < $m} {\n        if {[lindex $A $i] == [lindex $B $j]} {\n            incr i\n            incr j\n            if {$j == $m} {\n                return 1\n            }\n        } else {\n            set i [expr {$i - $j + 1}]\n            set j 0\n        }\n    }\n    return 0\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Sub_Array {1 4 3 5} {1 2}] == 0}\nassert {[is_Sub_Array {1 2 1} {1 2 1}] == 1}\nassert {[is_Sub_Array {1 0 2 2} {2 2 0}] == 0}",
        "declaration": "proc is_Sub_Array {A B} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Sub_Array {1 4 3 5} {1 2}] == 0}",
        "prompt_text": "Given two lists of integers, check whether the second list is a subarray of the first or not.",
        "prompt_explain": "Given two lists of integers, check whether the second list is a subarray of the first or not.\n>>> is_Sub_Array {1 4 3 5} {1 2}\n0\n>>> is_Sub_Array {1 2 1} {1 2 1}\n1",
        "func_title": "proc is_Sub_Array {A B}"
    },
    {
        "prompt": "# Write a Tcl function to find the surface area of the square pyramid.\n# >>> surface_Area 3 4\n# 33\nproc surface_Area {b s} {",
        "canonical_solution": "    return [expr {2 * $b * $s + pow($b, 2)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surface_Area 3 4] == 33}\nassert {[surface_Area 4 5] == 56}\nassert {[surface_Area 1 2] == 5}",
        "declaration": "proc surface_Area {b s} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[surface_Area 3 4] == 33}",
        "prompt_text": "Write a Tcl function to find the surface area of the square pyramid.",
        "prompt_explain": "Write a Tcl function to find the surface area of the square pyramid.\n>>> surface_Area 3 4\n33",
        "func_title": "proc surface_Area {b s}"
    },
    {
        "prompt": "# Write a function to check if a dictionary is empty or not.\n# >>> my_dict {}\n# 1\n# >>> my_dict {key value}\n# 0\nproc my_dict {dict1} {",
        "canonical_solution": "    if {[dict size $dict1] == 0} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[my_dict {}] == 1}\nassert {[my_dict {key value}] == 0}\nassert {[my_dict {a 1 b 2}] == 0}",
        "declaration": "proc my_dict {dict1} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[my_dict {}] == 1}",
        "prompt_text": "Write a function to check if a dictionary is empty or not.",
        "prompt_explain": "Write a function to check if a dictionary is empty or not.\n>>> my_dict {}\n1\n>>> my_dict {key value}\n0",
        "func_title": "proc my_dict {dict1}"
    },
    {
        "prompt": "# Write a function for nth catalan number.\n# >>> catalan_number 10\n# 16796\nproc catalan_number {num} {",
        "canonical_solution": "    if {$num <= 1} {\n        return 1\n    }\n    set res_num 0\n    for {set i 0} {$i < $num} {incr i} {\n        set res_num [expr {$res_num + [catalan_number $i] * [catalan_number [expr {$num - $i - 1}]]}]\n    }\n    return $res_num\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[catalan_number 10] == 16796}\nassert {[catalan_number 9] == 4862}\nassert {[catalan_number 7] == 429}",
        "declaration": "proc catalan_number {num} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[catalan_number 10] == 16796}",
        "prompt_text": "Write a function for nth catalan number.",
        "prompt_explain": "Write a function for nth catalan number.\n>>> catalan_number 10\n16796",
        "func_title": "proc catalan_number {num}"
    },
    {
        "prompt": "# Given a list of integers, find the difference between the largest and smallest value in the list.\n# >>> big_diff {1 2 3 4}\n# 3\nproc big_diff {nums} {",
        "canonical_solution": "    set max_num [lindex $nums 0]\n    set min_num [lindex $nums 0]\n    foreach num $nums {\n        if {$num > $max_num} {\n            set max_num $num\n        }\n        if {$num < $min_num} {\n            set min_num $num\n        }\n    }\n    return [expr {$max_num - $min_num}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[big_diff {1 2 3 4}] == 3}\nassert {[big_diff {4 5 12}] == 8}\nassert {[big_diff {9 2 3}] == 7}",
        "declaration": "proc big_diff {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[big_diff {1 2 3 4}] == 3}",
        "prompt_text": "Given a list of integers, find the difference between the largest and smallest value in the list.",
        "prompt_explain": "Given a list of integers, find the difference between the largest and smallest value in the list.\n>>> big_diff {1 2 3 4}\n3",
        "func_title": "proc big_diff {nums}"
    },
    {
        "prompt": "# Write a Tcl function to find the sum of the product of binomial coefficients.\n# >>> sum_Of_product 3\n# 15\nproc sum_Of_product {n} {",
        "canonical_solution": "    proc binomial_Coeff {n k} {\n        set C [lrepeat [expr {$k + 1}] 0]\n        lset C 0 1\n        for {set i 1} {$i <= $n} {incr i} {\n            for {set j [expr {min($i, $k)}]} {$j > 0} {incr j -1} {\n                lset C $j [expr {[lindex $C $j] + [lindex $C [expr {$j - 1}]]}]\n            }\n        }\n        return [lindex $C $k]\n    }\n    return [binomial_Coeff [expr {2 * $n}] [expr {$n - 1}]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_Of_product 3] == 15}\nassert {[sum_Of_product 4] == 56}\nassert {[sum_Of_product 1] == 1}",
        "declaration": "proc sum_Of_product {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_Of_product 3] == 15}",
        "prompt_text": "Write a Tcl function to find the sum of the product of binomial coefficients.",
        "prompt_explain": "Write a Tcl function to find the sum of the product of binomial coefficients.\n>>> sum_Of_product 3\n15",
        "func_title": "proc sum_Of_product {n}"
    },
    {
        "prompt": "# Given a list of integers, find the difference between the first even and the first odd number in the list.\n# >>> diff_even_odd {1 3 5 7 4 1 6 8}\n# 3\nproc diff_even_odd {list1} {",
        "canonical_solution": "    set first_even -1\n    set first_odd -1\n    foreach el $list1 {\n        if {$el % 2 == 0 && $first_even == -1} {\n            set first_even $el\n        }\n        if {$el % 2 != 0 && $first_odd == -1} {\n            set first_odd $el\n        }\n        if {$first_even != -1 && $first_odd != -1} {\n            break\n        }\n    }\n    return [expr {$first_even - $first_odd}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[diff_even_odd {1 3 5 7 4 1 6 8}] == 3}\nassert {[diff_even_odd {1 2 3 4 5 6 7 8 9 10}] == 1}\nassert {[diff_even_odd {1 5 7 9 10}] == 9}",
        "declaration": "proc diff_even_odd {list1} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[diff_even_odd {1 3 5 7 4 1 6 8}] == 3}",
        "prompt_text": "Given a list of integers, find the difference between the first even and the first odd number in the list.",
        "prompt_explain": "Given a list of integers, find the difference between the first even and the first odd number in the list.\n>>> diff_even_odd {1 3 5 7 4 1 6 8}\n3",
        "func_title": "proc diff_even_odd {list1}"
    },
    {
        "prompt": "# Given two binary strings, return the minimum number of swaps required to convert one binary string to another. If conversion is not possible, return 'Not Possible'.\n# >>> min_Swaps \"1101\" \"1110\"\n# 1\nproc min_Swaps {str1 str2} {",
        "canonical_solution": "    set count 0\n    for {set i 0} {$i < [string length $str1]} {incr i} {\n        if {[string index $str1 $i] != [string index $str2 $i]} {\n            incr count\n        }\n    }\n    if {$count % 2 == 0} {\n        return [expr {$count / 2}]\n    } else {\n        return \"Not Possible\"\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_Swaps \"1101\" \"1110\"] == 1}\nassert {[min_Swaps \"111\" \"000\"] eq \"Not Possible\"}\nassert {[min_Swaps \"111\" \"110\"] eq \"Not Possible\"}",
        "declaration": "proc min_Swaps {str1 str2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_Swaps \"1101\" \"1110\"] == 1}",
        "prompt_text": "Given two binary strings, return the minimum number of swaps required to convert one binary string to another. If conversion is not possible, return 'Not Possible'.",
        "prompt_explain": "Given two binary strings, return the minimum number of swaps required to convert one binary string to another. If conversion is not possible, return 'Not Possible'.\n>>> min_Swaps \"1101\" \"1110\"\n1",
        "func_title": "proc min_Swaps {str1 str2}"
    },
    {
        "prompt": "# Given a tuple, return its size.\n# >>> tuple_size {A 1 B 2 C 3}\n# <size of the tuple>\nproc tuple_size {tuple_list} {",
        "canonical_solution": "    return [string length $tuple_list]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[tuple_size {A 1 B 2 C 3}] == [string length {A 1 B 2 C 3}]}\nassert {[tuple_size {1 Raju 2 Nikhil 3 Deepanshu}] == [string length {1 Raju 2 Nikhil 3 Deepanshu}]}\nassert {[tuple_size {{1 Lion} {2 Tiger} {3 Fox} {4 Wolf}}] == [string length {{1 Lion} {2 Tiger} {3 Fox} {4 Wolf}}]}",
        "declaration": "proc tuple_size {tuple_list} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[tuple_size {A 1 B 2 C 3}] == [string length {A 1 B 2 C 3}]}",
        "prompt_text": "Given a tuple, return its size.",
        "prompt_explain": "Given a tuple, return its size.\n>>> tuple_size {A 1 B 2 C 3}\n<size of the tuple>",
        "func_title": "proc tuple_size {tuple_list}"
    },
    {
        "prompt": "# Given two sorted arrays, find the kth element from the combined array.\n# >>> find_kth {2 3 6 7 9} {1 4 8 10} 5 4 5\n# 6\nproc find_kth {arr1 arr2 m n k} {",
        "canonical_solution": "    set sorted1 [list]\n    set i 0\n    set j 0\n    set d 0\n    while {$i < $m && $j < $n} {\n        if {[lindex $arr1 $i] < [lindex $arr2 $j]} {\n            lappend sorted1 [lindex $arr1 $i]\n            incr i\n        } else {\n            lappend sorted1 [lindex $arr2 $j]\n            incr j\n        }\n        incr d\n    }\n    while {$i < $m} {\n        lappend sorted1 [lindex $arr1 $i]\n        incr i\n        incr d\n    }\n    while {$j < $n} {\n        lappend sorted1 [lindex $arr2 $j]\n        incr j\n        incr d\n    }\n    return [lindex $sorted1 [expr {$k - 1}]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_kth {2 3 6 7 9} {1 4 8 10} 5 4 5] == 6}\nassert {[find_kth {100 112 256 349 770} {72 86 113 119 265 445 892} 5 7 7] == 256}\nassert {[find_kth {3 4 7 8 10} {2 5 9 11} 5 4 6] == 8}",
        "declaration": "proc find_kth {arr1 arr2 m n k} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_kth {2 3 6 7 9} {1 4 8 10} 5 4 5] == 6}",
        "prompt_text": "Given two sorted arrays, find the kth element from the combined array.",
        "prompt_explain": "Given two sorted arrays, find the kth element from the combined array.\n>>> find_kth {2 3 6 7 9} {1 4 8 10} 5 4 5\n6",
        "func_title": "proc find_kth {arr1 arr2 m n k}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the given number is even or not using bitwise operator.\n# >>> is_Even 1\n# False\n# >>> is_Even 2\n# True\nproc is_Even {n} {",
        "canonical_solution": "    if {($n ^ 1) == ($n + 1)} {\n        return True\n    } else {\n        return False\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Even 1] == False}\nassert {[is_Even 2] == True}\nassert {[is_Even 3] == False}",
        "declaration": "proc is_Even {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Even 1] == False}",
        "prompt_text": "Write a Tcl function to check whether the given number is even or not using bitwise operator.",
        "prompt_explain": "Write a Tcl function to check whether the given number is even or not using bitwise operator.\n>>> is_Even 1\nFalse\n>>> is_Even 2\nTrue",
        "func_title": "proc is_Even {n}"
    },
    {
        "prompt": "# Write a function to check if the given integer is a prime number.\n# >>> prime_num 13\n# 1\n# >>> prime_num 7\n# 1\n# >>> prime_num -1010\n# 0\nproc prime_num {num} {",
        "canonical_solution": "    if {$num >= 1} {\n        for {set i 2} {$i <= [expr {$num / 2}]} {incr i} {\n            if {[expr {$num % $i}] == 0} {\n                return 0\n            }\n        }\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[prime_num 13] == 1}\nassert {[prime_num 7] == 1}\nassert {[prime_num -1010] == 0}",
        "declaration": "proc prime_num {num} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[prime_num 13] == 1}",
        "prompt_text": "Write a function to check if the given integer is a prime number.",
        "prompt_explain": "Write a function to check if the given integer is a prime number.\n>>> prime_num 13\n1\n>>> prime_num 7\n1\n>>> prime_num -1010\n0",
        "func_title": "proc prime_num {num}"
    },
    {
        "prompt": "# Write a function to convert degrees to radians.\n# >>> radian_degree 90\n# 1.5707963267948966\nproc radian_degree {degree} {",
        "canonical_solution": "    set pi [expr {acos(-1)}]\n    set radian [expr {$degree * ($pi / 180)}]\n    return $radian\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[radian_degree 90] == 1.5707963267948966}\nassert {[radian_degree 60] == 1.0471975511965976}\nassert {[radian_degree 120] == 2.0943951023931953}",
        "declaration": "proc radian_degree {degree} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[radian_degree 90] == 1.5707963267948966}",
        "prompt_text": "Write a function to convert degrees to radians.",
        "prompt_explain": "Write a function to convert degrees to radians.\n>>> radian_degree 90\n1.5707963267948966",
        "func_title": "proc radian_degree {degree}"
    },
    {
        "prompt": "# Write a Tcl function to find the nth Bell number.\n# >>> bell_Number 2\n# 2\nproc bell_Number {n} {",
        "canonical_solution": "    set bell [lrepeat [expr {$n + 1}] [lrepeat [expr {$n + 1}] 0]]\n    lset bell 0 0 1\n    for {set i 1} {$i <= $n} {incr i} {\n        lset bell $i 0 [lindex $bell [expr {$i - 1}] [expr {$i - 1}]]\n        for {set j 1} {$j <= $i} {incr j} {\n            lset bell $i $j [expr {[lindex $bell [expr {$i - 1}] [expr {$j - 1}]] + [lindex $bell $i [expr {$j - 1}]]}]\n        }\n    }\n    return [lindex $bell $n 0]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[bell_Number 2] == 2}\nassert {[bell_Number 3] == 5}\nassert {[bell_Number 4] == 15}",
        "declaration": "proc bell_Number {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[bell_Number 2] == 2}",
        "prompt_text": "Write a Tcl function to find the nth Bell number.",
        "prompt_explain": "Write a Tcl function to find the nth Bell number.\n>>> bell_Number 2\n2",
        "func_title": "proc bell_Number {n}"
    },
    {
        "prompt": "# Given a list of tuples, find the maximum of nth column from the given tuple list.\n# >>> max_of_nth {{5 6 7} {1 3 5} {8 9 19}} 2\n# 19\nproc max_of_nth {test_list N} {",
        "canonical_solution": "    set res [lindex [lindex $test_list 0] $N]\n    foreach sub $test_list {\n        if {[lindex $sub $N] > $res} {\n            set res [lindex $sub $N]\n        }\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_of_nth {{5 6 7} {1 3 5} {8 9 19}} 2] == 19}\nassert {[max_of_nth {{6 7 8} {2 4 6} {9 10 20}} 1] == 10}\nassert {[max_of_nth {{7 8 9} {3 5 7} {10 11 21}} 1] == 11}",
        "declaration": "proc max_of_nth {test_list N} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_of_nth {{5 6 7} {1 3 5} {8 9 19}} 2] == 19}",
        "prompt_text": "Given a list of tuples, find the maximum of nth column from the given tuple list.",
        "prompt_explain": "Given a list of tuples, find the maximum of nth column from the given tuple list.\n>>> max_of_nth {{5 6 7} {1 3 5} {8 9 19}} 2\n19",
        "func_title": "proc max_of_nth {test_list N}"
    },
    {
        "prompt": "# Given a list of integers, find the smallest missing number from the given array.\n# >>> find_First_Missing {0 1 2 3} 0 3\n# 4\nproc find_First_Missing {array start end} {",
        "canonical_solution": "    if {$start > $end} {\n        return [expr {$end + 1}]\n    }\n    if {$start != [lindex $array $start]} {\n        return $start\n    }\n    set mid [expr {($start + $end) / 2}]\n    if {[lindex $array $mid] == $mid} {\n        return [find_First_Missing $array [expr {$mid + 1}] $end]\n    }\n    return [find_First_Missing $array $start $mid]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_First_Missing {0 1 2 3} 0 3] == 4}\nassert {[find_First_Missing {0 1 2 6 9} 0 4] == 3}\nassert {[find_First_Missing {2 3 5 8 9} 0 4] == 0}",
        "declaration": "proc find_First_Missing {array start end} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_First_Missing {0 1 2 3} 0 3] == 4}",
        "prompt_text": "Given a list of integers, find the smallest missing number from the given array.",
        "prompt_explain": "Given a list of integers, find the smallest missing number from the given array.\n>>> find_First_Missing {0 1 2 3} 0 3\n4",
        "func_title": "proc find_First_Missing {array start end}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of XOR of all pairs of numbers in the given array.\n# >>> pair_OR_Sum {5 9 7 6}\n# 47\nproc pair_OR_Sum {arr} {",
        "canonical_solution": "    set ans 0\n    set n [llength $arr]\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $n} {incr j} {\n            set ans [expr {$ans + ([lindex $arr $i] ^ [lindex $arr $j])}]\n        }\n    }\n    return $ans\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[pair_OR_Sum {5 9 7 6}] == 47}\nassert {[pair_OR_Sum {7 3 5}] == 12}\nassert {[pair_OR_Sum {7 3}] == 4}",
        "declaration": "proc pair_OR_Sum {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[pair_OR_Sum {5 9 7 6}] == 47}",
        "prompt_text": "Given a list of integers, return the sum of XOR of all pairs of numbers in the given array.",
        "prompt_explain": "Given a list of integers, return the sum of XOR of all pairs of numbers in the given array.\n>>> pair_OR_Sum {5 9 7 6}\n47",
        "func_title": "proc pair_OR_Sum {arr}"
    },
    {
        "prompt": "# Write a Tcl function to find the sum of fourth power of first n even natural numbers.\n# >>> even_Power_Sum 2\n# 272\nproc even_Power_Sum {n} {",
        "canonical_solution": "    set sum 0\n    for {set i 1} {$i <= $n} {incr i} {\n        set j [expr {2 * $i}]\n        set sum [expr {$sum + $j ** 4}]\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_Power_Sum 2] == 272}\nassert {[even_Power_Sum 3] == 1568}\nassert {[even_Power_Sum 4] == 5664}",
        "declaration": "proc even_Power_Sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_Power_Sum 2] == 272}",
        "prompt_text": "Write a Tcl function to find the sum of fourth power of first n even natural numbers.",
        "prompt_explain": "Write a Tcl function to find the sum of fourth power of first n even natural numbers.\n>>> even_Power_Sum 2\n272",
        "func_title": "proc even_Power_Sum {n}"
    },
    {
        "prompt": "# Write a Tcl function to check if roots of a quadratic equation are reciprocal of each other or not.\n# >>> Check_Solution 2 0 2\n# Yes\n# >>> Check_Solution 2 -5 2\n# Yes\n# >>> Check_Solution 1 2 3\n# No\nproc Check_Solution {a b c} {",
        "canonical_solution": "    if {$a == $c} {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Check_Solution 2 0 2] eq \"Yes\"}\nassert {[Check_Solution 2 -5 2] eq \"Yes\"}\nassert {[Check_Solution 1 2 3] eq \"No\"}",
        "declaration": "proc Check_Solution {a b c} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Check_Solution 2 0 2] eq \"Yes\"}",
        "prompt_text": "Write a Tcl function to check if roots of a quadratic equation are reciprocal of each other or not.",
        "prompt_explain": "Write a Tcl function to check if roots of a quadratic equation are reciprocal of each other or not.\n>>> Check_Solution 2 0 2\nYes\n>>> Check_Solution 2 -5 2\nYes\n>>> Check_Solution 1 2 3\nNo",
        "func_title": "proc Check_Solution {a b c}"
    },
    {
        "prompt": "# Write a function to check whether the given amount has no profit and no loss\n# >>> noprofit_noloss 1500 1200\n# False\n# >>> noprofit_noloss 100 100\n# True\n# >>> noprofit_noloss 2000 5000\n# False\nproc noprofit_noloss {actual_cost sale_amount} {",
        "canonical_solution": "    if {$sale_amount == $actual_cost} {\n        return True\n    } else {\n        return False\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[noprofit_noloss 1500 1200] == False}\nassert {[noprofit_noloss 100 100] == True}\nassert {[noprofit_noloss 2000 5000] == False}",
        "declaration": "proc noprofit_noloss {actual_cost sale_amount} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[noprofit_noloss 1500 1200] == False}",
        "prompt_text": "Write a function to check whether the given amount has no profit and no loss",
        "prompt_explain": "Write a function to check whether the given amount has no profit and no loss\n>>> noprofit_noloss 1500 1200\nFalse\n>>> noprofit_noloss 100 100\nTrue\n>>> noprofit_noloss 2000 5000\nFalse",
        "func_title": "proc noprofit_noloss {actual_cost sale_amount}"
    },
    {
        "prompt": "# Write a function to calculate wind chill index.\n# >>> wind_chill 120 35\n# 40\nproc wind_chill {v t} {",
        "canonical_solution": "    set windchill [expr {13.12 + 0.6215 * $t - 11.37 * pow($v, 0.16) + 0.3965 * $t * pow($v, 0.16)}]\n    return [expr {int(round($windchill))}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[wind_chill 120 35] == 40}\nassert {[wind_chill 40 70] == 86}\nassert {[wind_chill 10 100] == 116}",
        "declaration": "proc wind_chill {v t} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[wind_chill 120 35] == 40}",
        "prompt_text": "Write a function to calculate wind chill index.",
        "prompt_explain": "Write a function to calculate wind chill index.\n>>> wind_chill 120 35\n40",
        "func_title": "proc wind_chill {v t}"
    },
    {
        "prompt": "# Write a function to find the nth nonagonal number.\n# >>> is_nonagonal 10\n# 325\nproc is_nonagonal {n} {",
        "canonical_solution": "    return [expr {int($n * (7 * $n - 5) / 2)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_nonagonal 10] == 325}\nassert {[is_nonagonal 15] == 750}\nassert {[is_nonagonal 18] == 1089}",
        "declaration": "proc is_nonagonal {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_nonagonal 10] == 325}",
        "prompt_text": "Write a function to find the nth nonagonal number.",
        "prompt_explain": "Write a function to find the nth nonagonal number.\n>>> is_nonagonal 10\n325",
        "func_title": "proc is_nonagonal {n}"
    },
    {
        "prompt": "# Given a cube of size n, return the number of smaller cubes of size k that can fit inside it.\n# >>> No_of_cubes 2 1\n# 8\nproc No_of_cubes {N K} {",
        "canonical_solution": "    set No [expr {($N - $K + 1) ** 3}]\n    return $No\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[No_of_cubes 2 1] == 8}\nassert {[No_of_cubes 5 2] == 64}\nassert {[No_of_cubes 1 1] == 1}",
        "declaration": "proc No_of_cubes {N K} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[No_of_cubes 2 1] == 8}",
        "prompt_text": "Given a cube of size n, return the number of smaller cubes of size k that can fit inside it.",
        "prompt_explain": "Given a cube of size n, return the number of smaller cubes of size k that can fit inside it.\n>>> No_of_cubes 2 1\n8",
        "func_title": "proc No_of_cubes {N K}"
    },
    {
        "prompt": "# Given two lists of integers, check whether they are equal or not. The lists are considered equal if they contain the same elements in the same order.\n# >>> are_Equal {1 2 3} {3 2 1}\n# False\nproc are_Equal {arr1 arr2} {",
        "canonical_solution": "    if {[llength $arr1] != [llength $arr2]} {\n        return False\n    }\n    set arr1 [lsort $arr1]\n    set arr2 [lsort $arr2]\n    for {set i 0} {$i < [llength $arr1]} {incr i} {\n        if {[lindex $arr1 $i] != [lindex $arr2 $i]} {\n            return False\n        }\n    }\n    return True\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[are_Equal {1 2 3} {3 2 1}] == True}\nassert {[are_Equal {1 1 1} {2 2 2}] == False}\nassert {[are_Equal {8 9} {4 5 6}] == False}",
        "declaration": "proc are_Equal {arr1 arr2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[are_Equal {1 2 3} {3 2 1}] == True}",
        "prompt_text": "Given two lists of integers, check whether they are equal or not. The lists are considered equal if they contain the same elements in the same order.",
        "prompt_explain": "Given two lists of integers, check whether they are equal or not. The lists are considered equal if they contain the same elements in the same order.\n>>> are_Equal {1 2 3} {3 2 1}\nFalse",
        "func_title": "proc are_Equal {arr1 arr2}"
    },
    {
        "prompt": "# Write a function to find the perimeter of a rectangle.\n# >>> rectangle_perimeter 10 20\n# 60\nproc rectangle_perimeter {l b} {",
        "canonical_solution": "    set perimeter [expr {2 * ($l + $b)}]\n    return $perimeter\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[rectangle_perimeter 10 20] == 60}\nassert {[rectangle_perimeter 10 5] == 30}\nassert {[rectangle_perimeter 4 2] == 12}",
        "declaration": "proc rectangle_perimeter {l b} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[rectangle_perimeter 10 20] == 60}",
        "prompt_text": "Write a function to find the perimeter of a rectangle.",
        "prompt_explain": "Write a function to find the perimeter of a rectangle.\n>>> rectangle_perimeter 10 20\n60",
        "func_title": "proc rectangle_perimeter {l b}"
    },
    {
        "prompt": "# Write a Tcl function to find the sum of fifth power of n natural numbers.\n# >>> fifth_Power_Sum 2\n# 33\nproc fifth_Power_Sum {n} {",
        "canonical_solution": "    set sm 0\n    for {set i 1} {$i <= $n} {incr i} {\n        set sm [expr {$sm + $i**5}]\n    }\n    return $sm\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[fifth_Power_Sum 2] == 33}\nassert {[fifth_Power_Sum 4] == 1300}\nassert {[fifth_Power_Sum 3] == 276}",
        "declaration": "proc fifth_Power_Sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[fifth_Power_Sum 2] == 33}",
        "prompt_text": "Write a Tcl function to find the sum of fifth power of n natural numbers.",
        "prompt_explain": "Write a Tcl function to find the sum of fifth power of n natural numbers.\n>>> fifth_Power_Sum 2\n33",
        "func_title": "proc fifth_Power_Sum {n}"
    },
    {
        "prompt": "# Write a Tcl function to find the first digit in factorial of a given number.\n# >>> first_Digit 5\n# 1\nproc first_Digit {n} {",
        "canonical_solution": "    set fact 1\n    for {set i 2} {$i <= $n} {incr i} {\n        set fact [expr {$fact * $i}]\n        while {[expr {$fact % 10}] == 0} {\n            set fact [expr {$fact / 10}]\n        }\n    }\n    while {$fact >= 10} {\n        set fact [expr {$fact / 10}]\n    }\n    return [expr {int($fact)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[first_Digit 5] == 1}\nassert {[first_Digit 10] == 3}\nassert {[first_Digit 7] == 5}",
        "declaration": "proc first_Digit {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[first_Digit 5] == 1}",
        "prompt_text": "Write a Tcl function to find the first digit in factorial of a given number.",
        "prompt_explain": "Write a Tcl function to find the first digit in factorial of a given number.\n>>> first_Digit 5\n1",
        "func_title": "proc first_Digit {n}"
    },
    {
        "prompt": "# Given a list of items, return the item with maximum occurrences in the list.\n# >>> max_occurrences {2 3 8 4 7 9 8 2 6 5 1 6 1 2 3 4 6 9 1 2}\n# 2\nproc max_occurrences {list1} {",
        "canonical_solution": "    set max_val 0\n    set result [lindex $list1 0]\n    foreach i $list1 {\n        set occu [llength [lsearch -all $list1 $i]]\n        if {$occu > $max_val} {\n            set max_val $occu\n            set result $i\n        }\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_occurrences {2 3 8 4 7 9 8 2 6 5 1 6 1 2 3 4 6 9 1 2}] == 2}\nassert {[max_occurrences {1 3 5 7 1 3 13 15 17 5 7 9 1 11}] == 1}\nassert {[max_occurrences {1 2 3 2 4 5 1 1 1}] == 1}",
        "declaration": "proc max_occurrences {list1} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_occurrences {2 3 8 4 7 9 8 2 6 5 1 6 1 2 3 4 6 9 1 2}] == 2}",
        "prompt_text": "Given a list of items, return the item with maximum occurrences in the list.",
        "prompt_explain": "Given a list of items, return the item with maximum occurrences in the list.\n>>> max_occurrences {2 3 8 4 7 9 8 2 6 5 1 6 1 2 3 4 6 9 1 2}\n2",
        "func_title": "proc max_occurrences {list1}"
    },
    {
        "prompt": "# Given a list of integers, find the maximum sum that can be formed which has no three consecutive elements present.\n# >>> max_sum_of_three_consecutive {100 1000 100 1000 1}\n# 2101\nproc max_sum_of_three_consecutive {arr n} {",
        "canonical_solution": "    set sum [list]\n    for {set k 0} {$k < $n} {incr k} {\n        lappend sum 0\n    }\n    if {$n >= 1} {\n        lset sum 0 [lindex $arr 0]\n    }\n    if {$n >= 2} {\n        lset sum 1 [expr {[lindex $arr 0] + [lindex $arr 1]}]\n    }\n    if {$n > 2} {\n        lset sum 2 [expr {max([lindex $sum 1], max([lindex $arr 1] + [lindex $arr 2], [lindex $arr 0] + [lindex $arr 2]))}]\n    }\n    for {set i 3} {$i < $n} {incr i} {\n        lset sum $i [expr {max(max([lindex $sum [expr {$i - 1}]], [lindex $sum [expr {$i - 2}]] + [lindex $arr $i]), [lindex $arr $i] + [lindex $arr [expr {$i - 1}]] + [lindex $sum [expr {$i - 3}]])}]\n    }\n    return [lindex $sum [expr {$n - 1}]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sum_of_three_consecutive {100 1000 100 1000 1} 5] == 2101}\nassert {[max_sum_of_three_consecutive {3000 2000 1000 3 10} 5] == 5013}\nassert {[max_sum_of_three_consecutive {1 2 3 4 5 6 7 8} 8] == 27}",
        "declaration": "proc max_sum_of_three_consecutive {arr n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sum_of_three_consecutive {100 1000 100 1000 1} 5] == 2101}",
        "prompt_text": "Given a list of integers, find the maximum sum that can be formed which has no three consecutive elements present.",
        "prompt_explain": "Given a list of integers, find the maximum sum that can be formed which has no three consecutive elements present.\n>>> max_sum_of_three_consecutive {100 1000 100 1000 1}\n2101",
        "func_title": "proc max_sum_of_three_consecutive {arr n}"
    },
    {
        "prompt": "# Given a list of integers, check whether the sequence has a decreasing trend or not.\n# >>> decreasing_trend {3 2 1}\n# 1\n# >>> decreasing_trend {1 2 3}\n# 0\nproc decreasing_trend {nums} {",
        "canonical_solution": "    set sorted_nums [lsort -integer $nums]\n    if {$sorted_nums eq $nums} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[decreasing_trend {-4 -3 -2 -1}] == 1}\nassert {[decreasing_trend {1 2 3}] == 1}\nassert {[decreasing_trend {3 2 1}] == 0}",
        "declaration": "proc decreasing_trend {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[decreasing_trend {3 2 1}] == 0}",
        "prompt_text": "Given a list of integers, check whether the sequence has a decreasing trend or not.",
        "prompt_explain": "Given a list of integers, check whether the sequence has a decreasing trend or not.\n>>> decreasing_trend {3 2 1}\n1\n>>> decreasing_trend {1 2 3}\n0",
        "func_title": "proc decreasing_trend {nums}"
    },
    {
        "prompt": "# Write a function to find maximum of three numbers.\n# >>> max_of_three 10 20 30\n# 30\nproc max_of_three {num1 num2 num3} {",
        "canonical_solution": "    if {$num1 >= $num2 && $num1 >= $num3} {\n        return $num1\n    } elseif {$num2 >= $num1 && $num2 >= $num3} {\n        return $num2\n    } else {\n        return $num3\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_of_three 10 20 30] == 30}\nassert {[max_of_three 55 47 39] == 55}\nassert {[max_of_three 10 49 30] == 49}",
        "declaration": "proc max_of_three {num1 num2 num3} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_of_three 10 20 30] == 30}",
        "prompt_text": "Write a function to find maximum of three numbers.",
        "prompt_explain": "Write a function to find maximum of three numbers.\n>>> max_of_three 10 20 30\n30",
        "func_title": "proc max_of_three {num1 num2 num3}"
    },
    {
        "prompt": "# Given a list of integers, convert it into a single integer.\n# >>> convert {1 2 3}\n# 123\nproc convert {list} {",
        "canonical_solution": "    set s \"\"\n    foreach i $list {\n        append s $i\n    }\n    return [expr {$s}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[convert {1 2 3}] == 123}\nassert {[convert {4 5 6}] == 456}\nassert {[convert {7 8 9}] == 789}",
        "declaration": "proc convert {list} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[convert {1 2 3}] == 123}",
        "prompt_text": "Given a list of integers, convert it into a single integer.",
        "prompt_explain": "Given a list of integers, convert it into a single integer.\n>>> convert {1 2 3}\n123",
        "func_title": "proc convert {list}"
    },
    {
        "prompt": "# Write a function to add two integers. however, if the sum is between the given range it will return 20.\n# >>> sum_nums 2 10 11 20\n# 20\n# >>> sum_nums 15 17 1 10\n# 32\n# >>> sum_nums 10 15 5 30\n# 20\nproc sum_nums {x y m n} {",
        "canonical_solution": "    set sum_nums [expr {$x + $y}]\n    if {$sum_nums >= $m && $sum_nums < $n} {\n        return 20\n    } else {\n        return $sum_nums\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_nums 2 10 11 20] == 20}\nassert {[sum_nums 15 17 1 10] == 32}\nassert {[sum_nums 10 15 5 30] == 20}",
        "declaration": "proc sum_nums {x y m n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_nums 2 10 11 20] == 20}",
        "prompt_text": "Write a function to add two integers. however, if the sum is between the given range it will return 20.",
        "prompt_explain": "Write a function to add two integers. however, if the sum is between the given range it will return 20.\n>>> sum_nums 2 10 11 20\n20\n>>> sum_nums 15 17 1 10\n32\n>>> sum_nums 10 15 5 30\n20",
        "func_title": "proc sum_nums {x y m n}"
    },
    {
        "prompt": "# Write a function to check if the triangle is valid or not.\n# >>> validity_triangle 60 50 90\n# 0\n# >>> validity_triangle 45 75 60\n# 1\nproc validity_triangle {a b c} {",
        "canonical_solution": "    set total [expr {$a + $b + $c}]\n    if {$total == 180} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[validity_triangle 60 50 90] == 0}\nassert {[validity_triangle 45 75 60] == 1}\nassert {[validity_triangle 30 50 100] == 1}",
        "declaration": "proc validity_triangle {a b c} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[validity_triangle 60 50 90] == 0}",
        "prompt_text": "Write a function to check if the triangle is valid or not.",
        "prompt_explain": "Write a function to check if the triangle is valid or not.\n>>> validity_triangle 60 50 90\n0\n>>> validity_triangle 45 75 60\n1",
        "func_title": "proc validity_triangle {a b c}"
    },
    {
        "prompt": "# Write a Tcl function to find the smallest prime divisor of a number.\n# >>> smallest_Divisor 10\n# 2\nproc smallest_Divisor {n} {",
        "canonical_solution": "    if {$n % 2 == 0} {\n        return 2\n    }\n    set i 3\n    while {$i * $i <= $n} {\n        if {$n % $i == 0} {\n            return $i\n        }\n        incr i 2\n    }\n    return $n\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smallest_Divisor 10] == 2}\nassert {[smallest_Divisor 25] == 5}\nassert {[smallest_Divisor 31] == 31}",
        "declaration": "proc smallest_Divisor {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smallest_Divisor 10] == 2}",
        "prompt_text": "Write a Tcl function to find the smallest prime divisor of a number.",
        "prompt_explain": "Write a Tcl function to find the smallest prime divisor of a number.\n>>> smallest_Divisor 10\n2",
        "func_title": "proc smallest_Divisor {n}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the given number can be represented by sum of two squares or not.\n# >>> sum_Square 25\n# 1\n# >>> sum_Square 24\n# 0\n# >>> sum_Square 17\n# 1\nproc sum_Square {n} {",
        "canonical_solution": "    set i 1\n    while {$i * $i <= $n} {\n        set j 1\n        while {$j * $j <= $n} {\n            if {$i * $i + $j * $j == $n} {\n                return 1\n            }\n            incr j\n        }\n        incr i\n    }\n    return 0\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_Square 25] == 1}\nassert {[sum_Square 24] == 0}\nassert {[sum_Square 17] == 1}",
        "declaration": "proc sum_Square {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_Square 25] == 1}",
        "prompt_text": "Write a Tcl function to check whether the given number can be represented by sum of two squares or not.",
        "prompt_explain": "Write a Tcl function to check whether the given number can be represented by sum of two squares or not.\n>>> sum_Square 25\n1\n>>> sum_Square 24\n0\n>>> sum_Square 17\n1",
        "func_title": "proc sum_Square {n}"
    },
    {
        "prompt": "# Write a function to find the greatest common divisor (gcd) of two integers by using recursion.\n# >>> recur_gcd 12 14\n# 2\nproc recur_gcd {a b} {",
        "canonical_solution": "    set low [expr {min($a, $b)}]\n    set high [expr {max($a, $b)}]\n    if {$low == 0} {\n        return $high\n    } elseif {$low == 1} {\n        return 1\n    } else {\n        return [recur_gcd $low [expr {$high % $low}]]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[recur_gcd 12 14] == 2}\nassert {[recur_gcd 13 17] == 1}\nassert {[recur_gcd 9 3] == 3}",
        "declaration": "proc recur_gcd {a b} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[recur_gcd 12 14] == 2}",
        "prompt_text": "Write a function to find the greatest common divisor (gcd) of two integers by using recursion.",
        "prompt_explain": "Write a function to find the greatest common divisor (gcd) of two integers by using recursion.\n>>> recur_gcd 12 14\n2",
        "func_title": "proc recur_gcd {a b}"
    },
    {
        "prompt": "# Given an array of integers where each element represents the max number of steps that can be made forward from that element, write a function to find the minimum number of jumps to reach the end of the array.\n# >>> min_jumps {1 3 6 1 0 9}\n# 3\nproc min_jumps {arr} {",
        "canonical_solution": "    set n [llength $arr]\n    set jumps [list]\n    for {set i 0} {$i < $n} {incr i} {\n        lappend jumps 0\n    }\n    if {$n == 0 || [lindex $arr 0] == 0} {\n        return Inf\n    }\n    lset jumps 0 0\n    for {set i 1} {$i < $n} {incr i} {\n        lset jumps $i Inf\n        for {set j 0} {$j < $i} {incr j} {\n            if {$i <= [expr {$j + [lindex $arr $j]}] && [lindex $jumps $j] != Inf} {\n                lset jumps $i [expr {min([lindex $jumps $i], [lindex $jumps $j] + 1)}]\n                break\n            }\n        }\n    }\n    return [lindex $jumps [expr {$n - 1}]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_jumps {1 3 6 1 0 9}] == 3}\nassert {[min_jumps {1 3 5 8 9 2 6 7 6 8 9}] == 3}\nassert {[min_jumps {1 1 1 1 1 1 1 1 1 1 1}] == 10}",
        "declaration": "proc min_jumps {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_jumps {1 3 6 1 0 9}] == 3}",
        "prompt_text": "Given an array of integers where each element represents the max number of steps that can be made forward from that element, write a function to find the minimum number of jumps to reach the end of the array.",
        "prompt_explain": "Given an array of integers where each element represents the max number of steps that can be made forward from that element, write a function to find the minimum number of jumps to reach the end of the array.\n>>> min_jumps {1 3 6 1 0 9}\n3",
        "func_title": "proc min_jumps {arr}"
    },
    {
        "prompt": "# Given two binary strings, find the minimum number of swaps required to convert one binary string to another.\n# >>> min_Swaps \"1101\" \"1110\"\n# 1\nproc min_Swaps {str1 str2} {",
        "canonical_solution": "    set count 0\n    for {set i 0} {$i < [string length $str1]} {incr i} {\n        if {[string index $str1 $i] != [string index $str2 $i]} {\n            incr count\n        }\n    }\n    if {$count % 2 == 0} {\n        return [expr {$count / 2}]\n    } else {\n        return \"Not Possible\"\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_Swaps \"1101\" \"1110\"] == 1}\nassert {[min_Swaps \"1111\" \"0100\"] eq \"Not Possible\"}\nassert {[min_Swaps \"1110000\" \"0001101\"] == 3}",
        "declaration": "proc min_Swaps {str1 str2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_Swaps \"1101\" \"1110\"] == 1}",
        "prompt_text": "Given two binary strings, find the minimum number of swaps required to convert one binary string to another.",
        "prompt_explain": "Given two binary strings, find the minimum number of swaps required to convert one binary string to another.\n>>> min_Swaps \"1101\" \"1110\"\n1",
        "func_title": "proc min_Swaps {str1 str2}"
    },
    {
        "prompt": "# Given a list of elements, count the number of elements which are within a specific range.\n# >>> count_range_in_list {10 20 30 40 40 40 70 80 99} 40 100\n# 6\nproc count_range_in_list {li min max} {",
        "canonical_solution": "    set ctr 0\n    foreach x $li {\n        if {$min <= $x && $x <= $max} {\n            incr ctr\n        }\n    }\n    return $ctr\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_range_in_list {10 20 30 40 40 40 70 80 99} 40 100] == 6}\nassert {[count_range_in_list {a b c d e f} a e] == 5}\nassert {[count_range_in_list {7 8 9 15 17 19 45} 15 20] == 3}",
        "declaration": "proc count_range_in_list {li min max} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_range_in_list {10 20 30 40 40 40 70 80 99} 40 100] == 6}",
        "prompt_text": "Given a list of elements, count the number of elements which are within a specific range.",
        "prompt_explain": "Given a list of elements, count the number of elements which are within a specific range.\n>>> count_range_in_list {10 20 30 40 40 40 70 80 99} 40 100\n6",
        "func_title": "proc count_range_in_list {li min max}"
    },
    {
        "prompt": "# Given a list of integers, find the equilibrium index of the given array.\n# The equilibrium index is the index where the sum of elements at lower indexes is equal to the sum of elements at higher indexes.\n# >>> equilibrium_index {1 2 3 4 1 2 3}\n# 3\nproc equilibrium_index {arr} {",
        "canonical_solution": "    set total_sum [expr [join $arr +]]\n    set left_sum 0\n    for {set i 0} {$i < [llength $arr]} {incr i} {\n        set total_sum [expr $total_sum - [lindex $arr $i]]\n        if {$left_sum == $total_sum} {\n            return $i\n        }\n        set left_sum [expr $left_sum + [lindex $arr $i]]\n    }\n    return -1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[equilibrium_index {1 2 3 4 1 2 3}] == 3}\nassert {[equilibrium_index {-7 1 5 2 -4 3 0}] == 3}\nassert {[equilibrium_index {1 2 3}] == -1}",
        "declaration": "proc equilibrium_index {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[equilibrium_index {1 2 3 4 1 2 3}] == 3}",
        "prompt_text": "Given a list of integers, find the equilibrium index of the given array. The equilibrium index is the index where the sum of elements at lower indexes is equal to the sum of elements at higher indexes.",
        "prompt_explain": "Given a list of integers, find the equilibrium index of the given array. The equilibrium index is the index where the sum of elements at lower indexes is equal to the sum of elements at higher indexes.\n>>> equilibrium_index {1 2 3 4 1 2 3}\n3",
        "func_title": "proc equilibrium_index {arr}"
    },
    {
        "prompt": "# Given a list of integers and an integer k, find the minimum number of elements that should be removed such that the difference between the maximum and minimum elements in the list is less than or equal to k.\n# >>> removals {1 3 4 9 10 11 12 17 20} 4\n# 5\nproc removals {arr k} {",
        "canonical_solution": "    set n [llength $arr]\n    set arr [lsort -integer $arr]\n    set ans [expr {$n - 1}]\n    for {set i 0} {$i < $n} {incr i} {\n        set j [find_ind [lindex $arr $i] $i $n $k $arr]\n        if {$j != -1} {\n            set ans [expr {min($ans, $n - ($j - $i + 1))}]\n        }\n    }\n    return $ans\n}\n\nproc find_ind {key i n k arr} {\n    set ind -1\n    set start [expr {$i + 1}]\n    set end [expr {$n - 1}]\n    while {$start < $end} {\n        set mid [expr {int($start + ($end - $start) / 2)}]\n        if {[lindex $arr $mid] - $key <= $k} {\n            set ind $mid\n            set start [expr {$mid + 1}]\n        } else {\n            set end $mid\n        }\n    }\n    return $ind\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[removals {1 3 4 9 10 11 12 17 20} 4] == 5}\nassert {[removals {1 5 6 2 8} 2] == 3}\nassert {[removals {1 2 3 4 5 6} 3] == 2}",
        "declaration": "proc removals {arr k} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[removals {1 3 4 9 10 11 12 17 20} 4] == 5}",
        "prompt_text": "Given a list of integers and an integer k, find the minimum number of elements that should be removed such that the difference between the maximum and minimum elements in the list is less than or equal to k.",
        "prompt_explain": "Given a list of integers and an integer k, find the minimum number of elements that should be removed such that the difference between the maximum and minimum elements in the list is less than or equal to k.\n>>> removals {1 3 4 9 10 11 12 17 20} 4\n5",
        "func_title": "proc removals {arr k}"
    },
    {
        "prompt": "# Write a function to check whether the given key is present in the dictionary or not.\n# >>> is_key_present {1 10 2 20 3 30 4 40 5 50 6 60} 5\n# 1\nproc is_key_present {dict key} {",
        "canonical_solution": "    if {[dict exists $dict $key]} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_key_present {1 10 2 20 3 30 4 40 5 50 6 60} 5] == 1}\nassert {[is_key_present {1 10 2 20 3 30 4 40 5 50 6 60} 6] == 1}\nassert {[is_key_present {1 10 2 20 3 30 4 40 5 50 6 60} 10] == 0}",
        "declaration": "proc is_key_present {dict key} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_key_present {1 10 2 20 3 30 4 40 5 50 6 60} 5] == 1}",
        "prompt_text": "Write a function to check whether the given key is present in the dictionary or not.",
        "prompt_explain": "Write a function to check whether the given key is present in the dictionary or not.\n>>> is_key_present {1 10 2 20 3 30 4 40 5 50 6 60} 5\n1",
        "func_title": "proc is_key_present {dict key}"
    },
    {
        "prompt": "# Write a function to calculate the harmonic sum of n-1.\n# >>> harmonic_sum 10\n# 2.9289682539682538\nproc harmonic_sum {n} {",
        "canonical_solution": "    if {$n < 2} {\n        return 1\n    } else {\n        return [expr {1.0 / $n + [harmonic_sum [expr {$n - 1}]]}]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[harmonic_sum 10] == 2.9289682539682538}\nassert {[harmonic_sum 4] == 2.083333333333333}\nassert {[harmonic_sum 7] == 2.5928571428571425}",
        "declaration": "proc harmonic_sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[harmonic_sum 10] == 2.9289682539682538}",
        "prompt_text": "Write a function to calculate the harmonic sum of n-1.",
        "prompt_explain": "Write a function to calculate the harmonic sum of n-1.\n>>> harmonic_sum 10\n2.9289682539682538",
        "func_title": "proc harmonic_sum {n}"
    },
    {
        "prompt": "# Write a Tcl function to count the total set bits from 1 to n.\n# >>> count_Set_Bits 16\n# 33\nproc count_Set_Bits {n} {",
        "canonical_solution": "    incr n\n    set powerOf2 2\n    set cnt [expr {$n / 2}]\n    while {$powerOf2 <= $n} {\n        set totalPairs [expr {$n / $powerOf2}]\n        set cnt [expr {$cnt + ($totalPairs / 2) * $powerOf2}]\n        if {$totalPairs & 1} {\n            set cnt [expr {$cnt + ($n % $powerOf2)}]\n        }\n        set powerOf2 [expr {$powerOf2 << 1}]\n    }\n    return $cnt\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Set_Bits 16] == 33}\nassert {[count_Set_Bits 2] == 2}\nassert {[count_Set_Bits 14] == 28}",
        "declaration": "proc count_Set_Bits {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Set_Bits 16] == 33}",
        "prompt_text": "Write a Tcl function to count the total set bits from 1 to n.",
        "prompt_explain": "Write a Tcl function to count the total set bits from 1 to n.\n>>> count_Set_Bits 16\n33",
        "func_title": "proc count_Set_Bits {n}"
    },
    {
        "prompt": "# Write a function to find the perimeter of a rhombus.\n# >>> rombus_perimeter 10\n# 40\nproc rombus_perimeter {a} {",
        "canonical_solution": "    set perimeter [expr {4 * $a}]\n    return $perimeter\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[rombus_perimeter 10] == 40}\nassert {[rombus_perimeter 5] == 20}\nassert {[rombus_perimeter 4] == 16}",
        "declaration": "proc rombus_perimeter {a} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[rombus_perimeter 10] == 40}",
        "prompt_text": "Write a function to find the perimeter of a rhombus.",
        "prompt_explain": "Write a function to find the perimeter of a rhombus.\n>>> rombus_perimeter 10\n40",
        "func_title": "proc rombus_perimeter {a}"
    },
    {
        "prompt": "# Given a list of numbers, calculate the standard deviation.\n# >>> sd_calc {4 2 5 8 6}\n# 2.23606797749979\nproc sd_calc {data} {",
        "canonical_solution": "    set n [llength $data]\n    if {$n <= 1} {\n        return 0.0\n    }\n    set mean [avg_calc $data]\n    set sd 0.0\n    foreach el $data {\n        set sd [expr {$sd + pow($el - $mean, 2)}]\n    }\n    set sd [expr {sqrt($sd / ($n - 1))}]\n    return $sd\n}\n\nproc avg_calc {ls} {\n    set n [llength $ls]\n    set mean 0.0\n    if {$n <= 1} {\n        return [lindex $ls 0]\n    }\n    foreach el $ls {\n        set mean [expr {$mean + $el}]\n    }\n    set mean [expr {$mean / $n}]\n    return $mean\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sd_calc {4 2 5 8 6}] == 2.23606797749979}\nassert {[sd_calc {1 2 3 4 5 6 7}] == 2.160246899469287}\nassert {[sd_calc {5 9 10 15 6 4}] == 4.070217029430577}",
        "declaration": "proc sd_calc {data} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sd_calc {4 2 5 8 6}] == 2.23606797749979}",
        "prompt_text": "Given a list of numbers, calculate the standard deviation.",
        "prompt_explain": "Given a list of numbers, calculate the standard deviation.\n>>> sd_calc {4 2 5 8 6}\n2.23606797749979",
        "func_title": "proc sd_calc {data}"
    },
    {
        "prompt": "# Given two lists of integers, return the count of positions where the elements are the same using the map function.\n# >>> count_same_pair {1 2 3 4 5 6 7 8} {2 2 3 1 2 6 7 9}\n# 4\nproc count_same_pair {nums1 nums2} {",
        "canonical_solution": "    set result 0\n    foreach a $nums1 b $nums2 {\n        if {$a == $b} {\n            incr result\n        }\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_same_pair {1 2 3 4 5 6 7 8} {2 2 3 1 2 6 7 9}] == 4}\nassert {[count_same_pair {0 1 2 -1 -5 6 0 -3 -2 3 4 6 8} {2 1 2 -1 -5 6 4 -3 -2 3 4 6 8}] == 11}\nassert {[count_same_pair {2 4 -6 -9 11 -12 14 -5 17} {2 1 2 -1 -5 6 4 -3 -2 3 4 6 8}] == 1}",
        "declaration": "proc count_same_pair {nums1 nums2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_same_pair {1 2 3 4 5 6 7 8} {2 2 3 1 2 6 7 9}] == 4}",
        "prompt_text": "Given two lists of integers, return the count of positions where the elements are the same using the map function.",
        "prompt_explain": "Given two lists of integers, return the count of positions where the elements are the same using the map function.\n>>> count_same_pair {1 2 3 4 5 6 7 8} {2 2 3 1 2 6 7 9}\n4",
        "func_title": "proc count_same_pair {nums1 nums2}"
    },
    {
        "prompt": "# Write a function to calculate the sum of all digits of the base to the specified power.\n# >>> power_base_sum 2 100\n# 115\nproc power_base_sum {base power} {",
        "canonical_solution": "    set result [expr {$base ** $power}]\n    set sum 0\n    foreach digit [split $result {}] {\n        incr sum $digit\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[power_base_sum 2 100] == 115}\nassert {[power_base_sum 8 10] == 37}\nassert {[power_base_sum 8 15] == 62}",
        "declaration": "proc power_base_sum {base power} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[power_base_sum 2 100] == 115}",
        "prompt_text": "Write a function to calculate the sum of all digits of the base to the specified power.",
        "prompt_explain": "Write a function to calculate the sum of all digits of the base to the specified power.\n>>> power_base_sum 2 100\n115",
        "func_title": "proc power_base_sum {base power}"
    },
    {
        "prompt": "# Write a function to find the lateral surface area of a cone.\n# >>> lateralsurface_cone 5 12\n# 204.20352248333654\nproc lateralsurface_cone {r h} {",
        "canonical_solution": "    set l [expr {sqrt($r * $r + $h * $h)}]\n    set LSA [expr {3.141592653589793 * $r * $l}]\n    return $LSA\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[lateralsurface_cone 5 12] == 204.20352248333654}\nassert {[lateralsurface_cone 10 15] == 566.3586699569488}\nassert {[lateralsurface_cone 19 17] == 1521.8090132193388}",
        "declaration": "proc lateralsurface_cone {r h} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[lateralsurface_cone 5 12] == 204.20352248333654}",
        "prompt_text": "Write a function to find the lateral surface area of a cone.",
        "prompt_explain": "Write a function to find the lateral surface area of a cone.\n>>> lateralsurface_cone 5 12\n204.20352248333654",
        "func_title": "proc lateralsurface_cone {r h}"
    },
    {
        "prompt": "# Given a sorted list of integers and a number, return the index of the first occurrence of the number in the list. If the number is not found, return -1.\n# >>> find_first_occurrence {2 5 5 5 6 6 8 9 9 9} 5\n# 1\nproc find_first_occurrence {A x} {",
        "canonical_solution": "    set left 0\n    set right [expr {[llength $A] - 1}]\n    set result -1\n    while {$left <= $right} {\n        set mid [expr {($left + $right) / 2}]\n        if {$x == [lindex $A $mid]} {\n            set result $mid\n            set right [expr {$mid - 1}]\n        } elseif {$x < [lindex $A $mid]} {\n            set right [expr {$mid - 1}]\n        } else {\n            set left [expr {$mid + 1}]\n        }\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_first_occurrence {2 5 5 5 6 6 8 9 9 9} 5] == 1}\nassert {[find_first_occurrence {2 3 5 5 6 6 8 9 9 9} 5] == 2}\nassert {[find_first_occurrence {2 4 1 5 6 6 8 9 9 9} 6] == 4}",
        "declaration": "proc find_first_occurrence {A x} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_first_occurrence {2 5 5 5 6 6 8 9 9 9} 5] == 1}",
        "prompt_text": "Given a sorted list of integers and a number, return the index of the first occurrence of the number in the list. If the number is not found, return -1.",
        "prompt_explain": "Given a sorted list of integers and a number, return the index of the first occurrence of the number in the list. If the number is not found, return -1.\n>>> find_first_occurrence {2 5 5 5 6 6 8 9 9 9} 5\n1",
        "func_title": "proc find_first_occurrence {A x}"
    },
    {
        "prompt": "# Write a function to calculate the geometric sum of n-1.\n# >>> geometric_sum 7\n# 1.9921875\nproc geometric_sum {n} {",
        "canonical_solution": "    if {$n < 0} {\n        return 0\n    } else {\n        return [expr {1 / (pow(2, $n)) + [geometric_sum [expr {$n - 1}]]}]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[geometric_sum 7] == 1.9921875}\nassert {[geometric_sum 4] == 1.9375}\nassert {[geometric_sum 8] == 1.99609375}",
        "declaration": "proc geometric_sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[geometric_sum 7] == 1.9921875}",
        "prompt_text": "Write a function to calculate the geometric sum of n-1.",
        "prompt_explain": "Write a function to calculate the geometric sum of n-1.\n>>> geometric_sum 7\n1.9921875",
        "func_title": "proc geometric_sum {n}"
    },
    {
        "prompt": "# Write a Tcl function to find the index of the smallest triangular number with n digits.\n# Triangular numbers are numbers that can form an equilateral triangle.\n# The nth triangular number is given by the formula: Tn = n(n+1)/2.\n# >>> find_Index 2\n# 4\nproc find_Index {n} {",
        "canonical_solution": "    set x [expr {int(sqrt(2 * pow(10, ($n - 1))))}]\n    return $x\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Index 2] == 4}\nassert {[find_Index 3] == 14}\nassert {[find_Index 4] == 45}",
        "declaration": "proc find_Index {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Index 2] == 4}",
        "prompt_text": "Write a Tcl function to find the index of the smallest triangular number with n digits.",
        "prompt_explain": "Write a Tcl function to find the index of the smallest triangular number with n digits.\nTriangular numbers are numbers that can form an equilateral triangle.\nThe nth triangular number is given by the formula: Tn = n(n+1)/2.\n>>> find_Index 2\n4",
        "func_title": "proc find_Index {n}"
    },
    {
        "prompt": "# Write a function to calculate the area of a tetrahedron.\n# >>> area_tetrahedron 3\n# 15.588457268119894\nproc area_tetrahedron {side} {",
        "canonical_solution": "    set area [expr {sqrt(3) * ($side * $side)}]\n    return $area\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[area_tetrahedron 3] == 15.588457268119894}\nassert {[area_tetrahedron 20] == 692.8203230275509}\nassert {[area_tetrahedron 10] == 173.20508075688772}",
        "declaration": "proc area_tetrahedron {side} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[area_tetrahedron 3] == 15.588457268119894}",
        "prompt_text": "Write a function to calculate the area of a tetrahedron.",
        "prompt_explain": "Write a function to calculate the area of a tetrahedron.\n>>> area_tetrahedron 3\n15.588457268119894",
        "func_title": "proc area_tetrahedron {side}"
    },
    {
        "prompt": "# Given a list of integers, check if the list represents a min heap.\n# >>> check_min_heap {1 2 3 4 5 6} 0\n# 1\nproc check_min_heap {arr i} {",
        "canonical_solution": "    if {[expr {2 * $i + 2}] > [llength $arr]} {\n        return 1\n    }\n    set left_child [expr {[lindex $arr $i] <= [lindex $arr [expr {2 * $i + 1}]] && [check_min_heap $arr [expr {2 * $i + 1}]]}]\n    set right_child [expr {[expr {2 * $i + 2}] == [llength $arr] || ([lindex $arr $i] <= [lindex $arr [expr {2 * $i + 2}]] && [check_min_heap $arr [expr {2 * $i + 2}]])}]\n    return [expr {$left_child && $right_child}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_min_heap {1 2 3 4 5 6} 0] == 1}\nassert {[check_min_heap {2 3 4 5 10 15} 0] == 1}\nassert {[check_min_heap {2 10 4 5 3 15} 0] == 0}",
        "declaration": "proc check_min_heap {arr i} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_min_heap {1 2 3 4 5 6} 0] == 1}",
        "prompt_text": "Given a list of integers, check if the list represents a min heap.",
        "prompt_explain": "Given a list of integers, check if the list represents a min heap.\n>>> check_min_heap {1 2 3 4 5 6} 0\n1",
        "func_title": "proc check_min_heap {arr i}"
    },
    {
        "prompt": "# Write a function to find the nth jacobsthal number.\n# >>> jacobsthal_num 5\n# 11\nproc jacobsthal_num {n} {",
        "canonical_solution": "    if {$n == 0} {return 0}\n    if {$n == 1} {return 1}\n    set dp [list 0 1]\n    for {set i 2} {$i <= $n} {incr i} {\n        lappend dp [expr {[lindex $dp [expr {$i - 1}]] + 2 * [lindex $dp [expr {$i - 2}]]}]\n    }\n    return [lindex $dp $n]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[jacobsthal_num 5] == 11}\nassert {[jacobsthal_num 2] == 1}\nassert {[jacobsthal_num 4] == 5}",
        "declaration": "proc jacobsthal_num {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[jacobsthal_num 5] == 11}",
        "prompt_text": "Write a function to find the nth jacobsthal number.",
        "prompt_explain": "Write a function to find the nth jacobsthal number.\n>>> jacobsthal_num 5\n11",
        "func_title": "proc jacobsthal_num {n}"
    },
    {
        "prompt": "# Write a function to calculate arc length of an angle.\n# >>> arc_length 9 45\n# 3.5357142857142856\n# >>> arc_length 9 480\n# None\n# >>> arc_length 5 270\n# 11.785714285714285\nproc arc_length {d a} {",
        "canonical_solution": "    set pi [expr {22.0 / 7}]\n    if {$a >= 360} {\n        return \"None\"\n    }\n    set arclength [expr {($pi * $d) * ($a / 360.0)}]\n    return $arclength\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[arc_length 9 45] == 3.5357142857142856}\nassert {[arc_length 9 480] eq \"None\"}\nassert {[arc_length 5 270] == 11.785714285714285}",
        "declaration": "proc arc_length {d a} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[arc_length 9 45] == 3.5357142857142856}",
        "prompt_text": "Write a function to calculate arc length of an angle.",
        "prompt_explain": "Write a function to calculate arc length of an angle.\n>>> arc_length 9 45\n3.5357142857142856\n>>> arc_length 9 480\nNone\n>>> arc_length 5 270\n11.785714285714285",
        "func_title": "proc arc_length {d a}"
    },
    {
        "prompt": "# Write a function to check whether the given month number contains 30 days or not.\n# >>> check_monthnumber_number 6\n# 1\n# >>> check_monthnumber_number 2\n# 0\nproc check_monthnumber_number {monthnum3} {",
        "canonical_solution": "    if {$monthnum3 == 4 || $monthnum3 == 6 || $monthnum3 == 9 || $monthnum3 == 11} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_monthnumber_number 6] == 1}\nassert {[check_monthnumber_number 2] == 0}\nassert {[check_monthnumber_number 12] == 0}",
        "declaration": "proc check_monthnumber_number {monthnum3} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_monthnumber_number 6] == 1}",
        "prompt_text": "Write a function to check whether the given month number contains 30 days or not.",
        "prompt_explain": "Write a function to check whether the given month number contains 30 days or not.\n>>> check_monthnumber_number 6\n1\n>>> check_monthnumber_number 2\n0",
        "func_title": "proc check_monthnumber_number {monthnum3}"
    },
    {
        "prompt": "# Given a list of integers, return the count of pairs whose sum is equal to a given sum.\n# >>> get_Pairs_Count {1 1 1 1} 4 2\n# 6\nproc get_Pairs_Count {arr n sum} {",
        "canonical_solution": "    set count 0\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $n} {incr j} {\n            if {[expr {[lindex $arr $i] + [lindex $arr $j]}] == $sum} {\n                incr count\n            }\n        }\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Pairs_Count {1 1 1 1} 4 2] == 6}\nassert {[get_Pairs_Count {1 5 7 -1 5} 5 6] == 3}\nassert {[get_Pairs_Count {1 -2 3} 3 1] == 1}",
        "declaration": "proc get_Pairs_Count {arr n sum} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_Pairs_Count {1 1 1 1} 4 2] == 6}",
        "prompt_text": "Given a list of integers, return the count of pairs whose sum is equal to a given sum.",
        "prompt_explain": "Given a list of integers, return the count of pairs whose sum is equal to a given sum.\n>>> get_Pairs_Count {1 1 1 1} 4 2\n6",
        "func_title": "proc get_Pairs_Count {arr n sum}"
    },
    {
        "prompt": "# Given a list of integers, find the sum of all odd length subarrays.\n# >>> Odd_Length_Sum {1 2 4}\n# 14\nproc Odd_Length_Sum {arr} {",
        "canonical_solution": "    set Sum 0\n    set l [llength $arr]\n    for {set i 0} {$i < $l} {incr i} {\n        set Sum [expr {$Sum + (((($i + 1) * ($l - $i) + 1) / 2) * [lindex $arr $i])}]\n    }\n    return $Sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Odd_Length_Sum {1 2 4}] == 14}\nassert {[Odd_Length_Sum {1 2 1 2}] == 15}\nassert {[Odd_Length_Sum {1 7}] == 8}",
        "declaration": "proc Odd_Length_Sum {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Odd_Length_Sum {1 2 4}] == 14}",
        "prompt_text": "Given a list of integers, find the sum of all odd length subarrays.",
        "prompt_explain": "Given a list of integers, find the sum of all odd length subarrays.\n>>> Odd_Length_Sum {1 2 4}\n14",
        "func_title": "proc Odd_Length_Sum {arr}"
    },
    {
        "prompt": "# Write a function to calculate the perimeter of a regular polygon.\n# >>> perimeter_polygon 4 20\n# 80\nproc perimeter_polygon {s l} {",
        "canonical_solution": "    set perimeter [expr {$s * $l}]\n    return $perimeter\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[perimeter_polygon 4 20] == 80}\nassert {[perimeter_polygon 10 15] == 150}\nassert {[perimeter_polygon 9 7] == 63}",
        "declaration": "proc perimeter_polygon {s l} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[perimeter_polygon 4 20] == 80}",
        "prompt_text": "Write a function to calculate the perimeter of a regular polygon.",
        "prompt_explain": "Write a function to calculate the perimeter of a regular polygon.\n>>> perimeter_polygon 4 20\n80",
        "func_title": "proc perimeter_polygon {s l}"
    },
    {
        "prompt": "# Given a list of integers, check whether every even index contains even numbers.\n# >>> even_position {3 2 1}\n# False\n# >>> even_position {1 2 3}\n# False\n# >>> even_position {2 1 4}\n# True\nproc even_position {nums} {",
        "canonical_solution": "    for {set i 0} {$i < [llength $nums]} {incr i} {\n        if {[expr {[lindex $nums $i] % 2}] != [expr {$i % 2}]} {\n            return 0\n        }\n    }\n    return 1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_position {3 2 1}] == 0}\nassert {[even_position {1 2 3}] == 0}\nassert {[even_position {2 1 4}] == 1}",
        "declaration": "proc even_position {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[even_position {3 2 1}] == 0}",
        "prompt_text": "Given a list of integers, check whether every even index contains even numbers.",
        "prompt_explain": "Given a list of integers, check whether every even index contains even numbers.\n>>> even_position {3 2 1}\nFalse\n>>> even_position {1 2 3}\nFalse\n>>> even_position {2 1 4}\nTrue",
        "func_title": "proc even_position {nums}"
    },
    {
        "prompt": "# Given a list of lists, return the count of lists in the given list.\n# >>> count_list {{1 3} {5 7} {9 11} {13 15 17}}\n# 4\nproc count_list {input_list} {",
        "canonical_solution": "    return [llength $input_list]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_list {{1 3} {5 7} {9 11} {13 15 17}}] == 4}\nassert {[count_list {{1 2} {2 3} {4 5}}] == 3}\nassert {[count_list {{1 0} {2 0}}] == 2}",
        "declaration": "proc count_list {input_list} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_list {{1 3} {5 7} {9 11} {13 15 17}}] == 4}",
        "prompt_text": "Given a list of lists, return the count of lists in the given list.",
        "prompt_explain": "Given a list of lists, return the count of lists in the given list.\n>>> count_list {{1 3} {5 7} {9 11} {13 15 17}}\n4",
        "func_title": "proc count_list {input_list}"
    },
    {
        "prompt": "# Given a sorted list of integers and an element, find the last position of the element in the list. Use binary search for efficiency.\n# >>> last {1 2 3} 1 3\n# 0\nproc last {arr x n} {",
        "canonical_solution": "    set low 0\n    set high [expr {$n - 1}]\n    set res -1\n    while {$low <= $high} {\n        set mid [expr {($low + $high) / 2}]\n        if {[lindex $arr $mid] > $x} {\n            set high [expr {$mid - 1}]\n        } elseif {[lindex $arr $mid] < $x} {\n            set low [expr {$mid + 1}]\n        } else {\n            set res $mid\n            set low [expr {$mid + 1}]\n        }\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[last {1 2 3} 1 3] == 0}\nassert {[last {1 1 1 2 3 4} 1 6] == 2}\nassert {[last {2 3 2 3 6 8 9} 3 7] == 3}",
        "declaration": "proc last {arr x n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[last {1 2 3} 1 3] == 0}",
        "prompt_text": "Given a sorted list of integers and an element, find the last position of the element in the list. Use binary search for efficiency.",
        "prompt_explain": "Given a sorted list of integers and an element, find the last position of the element in the list. Use binary search for efficiency.\n>>> last {1 2 3} 1 3\n0",
        "func_title": "proc last {arr x n}"
    },
    {
        "prompt": "# Given a list of integers, return the sum of all elements in the list.\n# >>> sum_list {1 2 3}\n# 6\nproc sum_list {numbers} {",
        "canonical_solution": "    set sum 0\n    foreach num $numbers {\n        set sum [expr {$sum + $num}]\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3}] == 6}\nassert {[sum_list {15 12 13 10}] == 50}\nassert {[sum_list {0 1 2}] == 3}",
        "declaration": "proc sum_list {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_list {1 2 3}] == 6}",
        "prompt_text": "Given a list of integers, return the sum of all elements in the list.",
        "prompt_explain": "Given a list of integers, return the sum of all elements in the list.\n>>> sum_list {1 2 3}\n6",
        "func_title": "proc sum_list {numbers}"
    },
    {
        "prompt": "# Given a list of integers, return the number of rotations required to generate a sorted array.\n# >>> count_Rotation {3 2 1}\n# 1\nproc count_Rotation {arr n} {",
        "canonical_solution": "    for {set i 1} {$i < $n} {incr i} {\n        if {[lindex $arr $i] < [lindex $arr [expr {$i - 1}]]} {\n            return $i\n        }\n    }\n    return 0\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Rotation {3 2 1} 3] == 1}\nassert {[count_Rotation {4 5 1 2 3} 5] == 2}\nassert {[count_Rotation {7 8 9 1 2 3} 6] == 3}",
        "declaration": "proc count_Rotation {arr n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Rotation {3 2 1} 3] == 1}",
        "prompt_text": "Given a list of integers, return the number of rotations required to generate a sorted array.",
        "prompt_explain": "Given a list of integers, return the number of rotations required to generate a sorted array.\n>>> count_Rotation {3 2 1}\n1",
        "func_title": "proc count_Rotation {arr n}"
    },
    {
        "prompt": "# Given a list of integers, write a Tcl function to check whether the product of numbers is even or not.\n# >>> is_Product_Even {1 2 3}\n# 1\nproc is_Product_Even {arr} {",
        "canonical_solution": "    foreach num $arr {\n        if {($num % 2) == 0} {\n            return 1\n        }\n    }\n    return 0\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Product_Even {1 2 3}] == 1}\nassert {[is_Product_Even {1 2 1 4}] == 1}\nassert {[is_Product_Even {1 1}] == 0}",
        "declaration": "proc is_Product_Even {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Product_Even {1 2 3}] == 1}",
        "prompt_text": "Given a list of integers, write a Tcl function to check whether the product of numbers is even or not.",
        "prompt_explain": "Given a list of integers, write a Tcl function to check whether the product of numbers is even or not.\n>>> is_Product_Even {1 2 3}\n1",
        "func_title": "proc is_Product_Even {arr}"
    },
    {
        "prompt": "# Write a function to check if two lists of tuples are identical or not.\n# >>> check_identical {{10 4} {2 5}} {{10 4} {2 5}}\n# 1\nproc check_identical {test_list1 test_list2} {",
        "canonical_solution": "    return [expr {$test_list1 == $test_list2}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_identical {{10 4} {2 5}} {{10 4} {2 5}}] == 1}\nassert {[check_identical {{1 2} {3 7}} {{12 14} {12 45}}] == 0}\nassert {[check_identical {{2 14} {12 25}} {{2 14} {12 25}}] == 1}",
        "declaration": "proc check_identical {test_list1 test_list2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_identical {{10 4} {2 5}} {{10 4} {2 5}}] == 1}",
        "prompt_text": "Write a function to check if two lists of tuples are identical or not.",
        "prompt_explain": "Write a function to check if two lists of tuples are identical or not.\n>>> check_identical {{10 4} {2 5}} {{10 4} {2 5}}\n1",
        "func_title": "proc check_identical {test_list1 test_list2}"
    },
    {
        "prompt": "# Write a function to find the area of a rhombus.\n# >>> rombus_area 10 20\n# 100\nproc rombus_area {p q} {",
        "canonical_solution": "    set area [expr {($p * $q) / 2}]\n    return $area\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[rombus_area 10 20] == 100}\nassert {[rombus_area 10 5] == 25}\nassert {[rombus_area 4 2] == 4}",
        "declaration": "proc rombus_area {p q} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[rombus_area 10 20] == 100}",
        "prompt_text": "Write a function to find the area of a rhombus.",
        "prompt_explain": "Write a function to find the area of a rhombus.\n>>> rombus_area 10 20\n100",
        "func_title": "proc rombus_area {p q}"
    },
    {
        "prompt": "# Write a function to check whether the given month number contains 28 days or not.\n# >>> check_monthnum_number 2\n# True\n# >>> check_monthnum_number 1\n# False\nproc check_monthnum_number {monthnum1} {",
        "canonical_solution": "    if {$monthnum1 == 2} {\n        return True\n    } else {\n        return False\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_monthnum_number 2] == True}\nassert {[check_monthnum_number 1] == False}\nassert {[check_monthnum_number 3] == False}",
        "declaration": "proc check_monthnum_number {monthnum1} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_monthnum_number 2] == True}",
        "prompt_text": "Write a function to check whether the given month number contains 28 days or not.",
        "prompt_explain": "Write a function to check whether the given month number contains 28 days or not.\n>>> check_monthnum_number 2\nTrue\n>>> check_monthnum_number 1\nFalse",
        "func_title": "proc check_monthnum_number {monthnum1}"
    },
    {
        "prompt": "# Given a list of lists and a column index, return the sum of the elements in that column.\n# >>> sum_column {{1 2 3 2} {4 5 6 2} {7 8 9 5}} 0\n# 12\nproc sum_column {list1 C} {",
        "canonical_solution": "    set result 0\n    foreach row $list1 {\n        set result [expr {$result + [lindex $row $C]}]\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_column {{1 2 3 2} {4 5 6 2} {7 8 9 5}} 0] == 12}\nassert {[sum_column {{1 2 3 2} {4 5 6 2} {7 8 9 5}} 1] == 15}\nassert {[sum_column {{1 2 3 2} {4 5 6 2} {7 8 9 5}} 3] == 9}",
        "declaration": "proc sum_column {list1 C} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_column {{1 2 3 2} {4 5 6 2} {7 8 9 5}} 0] == 12}",
        "prompt_text": "Given a list of lists and a column index, return the sum of the elements in that column.",
        "prompt_explain": "Given a list of lists and a column index, return the sum of the elements in that column.\n>>> sum_column {{1 2 3 2} {4 5 6 2} {7 8 9 5}} 0\n12",
        "func_title": "proc sum_column {list1 C}"
    },
    {
        "prompt": "# Given a list of integers, count the number of equal element pairs from the given list.\n# >>> count_Pairs {1 1 1 1}\n# 6\nproc count_Pairs {arr} {",
        "canonical_solution": "    set cnt 0\n    set n [llength $arr]\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $n} {incr j} {\n            if {[lindex $arr $i] == [lindex $arr $j]} {\n                incr cnt\n            }\n        }\n    }\n    return $cnt\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Pairs {1 1 1 1}] == 6}\nassert {[count_Pairs {1 5 1}] == 1}\nassert {[count_Pairs {3 2 1 7 8 9}] == 0}",
        "declaration": "proc count_Pairs {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Pairs {1 1 1 1}] == 6}",
        "prompt_text": "Given a list of integers, count the number of equal element pairs from the given list.",
        "prompt_explain": "Given a list of integers, count the number of equal element pairs from the given list.\n>>> count_Pairs {1 1 1 1}\n6",
        "func_title": "proc count_Pairs {arr}"
    },
    {
        "prompt": "# Write a function to extract the maximum numeric value from a string by using regex.\n# >>> extract_max '100klh564abc365bg'\n# 564\nproc extract_max {input} {",
        "canonical_solution": "    set numbers [regexp -all -inline {\\d+} $input]\n    set max_num 0\n    foreach num $numbers {\n        if {$num > $max_num} {\n            set max_num $num\n        }\n    }\n    return $max_num\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[extract_max '100klh564abc365bg'] == 564}\nassert {[extract_max 'hello300how546mer231'] == 546}\nassert {[extract_max 'its233beenalong343journey234'] == 343}",
        "declaration": "proc extract_max {input} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[extract_max '100klh564abc365bg'] == 564}",
        "prompt_text": "Write a function to extract the maximum numeric value from a string by using regex.",
        "prompt_explain": "Write a function to extract the maximum numeric value from a string by using regex.\n>>> extract_max '100klh564abc365bg'\n564",
        "func_title": "proc extract_max {input}"
    },
    {
        "prompt": "# Write a Tcl function to find the slope of a line given two points (x1,y1) and (x2,y2).\n# >>> slope 4 2 2 5\n# -1.5\nproc slope {x1 y1 x2 y2} {",
        "canonical_solution": "    return [expr {double($y2 - $y1) / ($x2 - $x1)}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[slope 4 2 2 5] == -1.5}\nassert {[slope 2 4 4 6] == 1}\nassert {[slope 1 2 4 2] == 0}",
        "declaration": "proc slope {x1 y1 x2 y2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[slope 4 2 2 5] == -1.5}",
        "prompt_text": "Write a Tcl function to find the slope of a line given two points (x1,y1) and (x2,y2).",
        "prompt_explain": "Write a Tcl function to find the slope of a line given two points (x1,y1) and (x2,y2).\n>>> slope 4 2 2 5\n-1.5",
        "func_title": "proc slope {x1 y1 x2 y2}"
    },
    {
        "prompt": "# Write a Tcl function to find the cube sum of first n odd natural numbers.\n# >>> cube_Sum 2\n# 28\nproc cube_Sum {n} {",
        "canonical_solution": "    set sum 0\n    for {set i 0} {$i < $n} {incr i} {\n        set odd [expr {2 * $i + 1}]\n        set sum [expr {$sum + $odd * $odd * $odd}]\n    }\n    return $sum\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[cube_Sum 2] == 28}\nassert {[cube_Sum 3] == 153}\nassert {[cube_Sum 4] == 496}",
        "declaration": "proc cube_Sum {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[cube_Sum 2] == 28}",
        "prompt_text": "Write a Tcl function to find the cube sum of first n odd natural numbers.",
        "prompt_explain": "Write a Tcl function to find the cube sum of first n odd natural numbers.\n>>> cube_Sum 2\n28",
        "func_title": "proc cube_Sum {n}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the roots of a quadratic equation are numerically equal but opposite in sign or not.\n# >>> Check_Solution 2 0 -1\n# Yes\n# >>> Check_Solution 1 -5 6\n# No\nproc Check_Solution {a b c} {",
        "canonical_solution": "    if {$b == 0} {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Check_Solution 2 0 -1] eq \"Yes\"}\nassert {[Check_Solution 1 -5 6] eq \"No\"}\nassert {[Check_Solution 2 0 2] eq \"Yes\"}",
        "declaration": "proc Check_Solution {a b c} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Check_Solution 2 0 -1] eq \"Yes\"}",
        "prompt_text": "Write a Tcl function to check whether the roots of a quadratic equation are numerically equal but opposite in sign or not.",
        "prompt_explain": "Write a Tcl function to check whether the roots of a quadratic equation are numerically equal but opposite in sign or not.\n>>> Check_Solution 2 0 -1\nYes\n>>> Check_Solution 1 -5 6\nNo",
        "func_title": "proc Check_Solution {a b c}"
    },
    {
        "prompt": "# Given a list of integers, return the number of inversions in the list.\n# An inversion is a pair of indices (i, j) such that i < j and list[i] > list[j].\n# >>> get_inv_count {1 20 6 4 5}\n# 5\nproc get_inv_count {arr} {",
        "canonical_solution": "    set inv_count 0\n    set n [llength $arr]\n    for {set i 0} {$i < $n} {incr i} {\n        for {set j [expr {$i + 1}]} {$j < $n} {incr j} {\n            if {[lindex $arr $i] > [lindex $arr $j]} {\n                incr inv_count\n            }\n        }\n    }\n    return $inv_count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_inv_count {1 20 6 4 5}] == 5}\nassert {[get_inv_count {8 4 2 1}] == 6}\nassert {[get_inv_count {3 1 2}] == 2}",
        "declaration": "proc get_inv_count {arr} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[get_inv_count {1 20 6 4 5}] == 5}",
        "prompt_text": "Given a list of integers, return the number of inversions in the list. An inversion is a pair of indices (i, j) such that i < j and list[i] > list[j].",
        "prompt_explain": "Given a list of integers, return the number of inversions in the list. An inversion is a pair of indices (i, j) such that i < j and list[i] > list[j].\n>>> get_inv_count {1 20 6 4 5}\n5",
        "func_title": "proc get_inv_count {arr}"
    },
    {
        "prompt": "# Given a number, return the number of digits in the factorial of that number.\n# >>> find_Digits 7\n# 4\nproc find_Digits {n} {",
        "canonical_solution": "    if {$n < 0} {\n        return 0\n    }\n    if {$n <= 1} {\n        return 1\n    }\n    set x [expr {($n * log10($n / exp(1))) + (log10(2 * 3.141592653589793 * $n) / 2.0)}]\n    return [expr {int($x) + 1}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Digits 7] == 4}\nassert {[find_Digits 5] == 3}\nassert {[find_Digits 4] == 2}",
        "declaration": "proc find_Digits {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Digits 7] == 4}",
        "prompt_text": "Given a number, return the number of digits in the factorial of that number.",
        "prompt_explain": "Given a number, return the number of digits in the factorial of that number.\n>>> find_Digits 7\n4",
        "func_title": "proc find_Digits {n}"
    },
    {
        "prompt": "# Given two lists of arrival and departure times of trains/buses, find the minimum number of platforms required for the station.\n# >>> find_platform {900 940 950 1100 1500 1800} {910 1200 1120 1130 1900 2000} 6\n# 3\nproc find_platform {arr dep n} {",
        "canonical_solution": "    set arr [lsort -integer $arr]\n    set dep [lsort -integer $dep]\n    set plat_needed 1\n    set result 1\n    set i 1\n    set j 0\n    while {$i < $n && $j < $n} {\n        if {[lindex $arr $i] <= [lindex $dep $j]} {\n            incr plat_needed\n            incr i\n        } else {\n            incr plat_needed -1\n            incr j\n        }\n        if {$plat_needed > $result} {\n            set result $plat_needed\n        }\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_platform {900 940 950 1100 1500 1800} {910 1200 1120 1130 1900 2000} 6] == 3}\nassert {[find_platform {100 200 300 400} {700 800 900 1000} 4] == 4}\nassert {[find_platform {5 6 7 8} {4 3 2 1} 4] == 1}",
        "declaration": "proc find_platform {arr dep n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_platform {900 940 950 1100 1500 1800} {910 1200 1120 1130 1900 2000} 6] == 3}",
        "prompt_text": "Given two lists of arrival and departure times of trains/buses, find the minimum number of platforms required for the station.",
        "prompt_explain": "Given two lists of arrival and departure times of trains/buses, find the minimum number of platforms required for the station.\n>>> find_platform {900 940 950 1100 1500 1800} {910 1200 1120 1130 1900 2000} 6\n3",
        "func_title": "proc find_platform {arr dep n}"
    },
    {
        "prompt": "# Write a function to find the area of a trapezium.\n# >>> area_trapezium 6 9 4\n# 30\nproc area_trapezium {base1 base2 height} {",
        "canonical_solution": "    set area [expr {0.5 * ($base1 + $base2) * $height}]\n    return $area\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[area_trapezium 6 9 4] == 30}\nassert {[area_trapezium 10 20 30] == 450}\nassert {[area_trapezium 15 25 35] == 700}",
        "declaration": "proc area_trapezium {base1 base2 height} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[area_trapezium 6 9 4] == 30}",
        "prompt_text": "Write a function to find the area of a trapezium.",
        "prompt_explain": "Write a function to find the area of a trapezium.\n>>> area_trapezium 6 9 4\n30",
        "func_title": "proc area_trapezium {base1 base2 height}"
    },
    {
        "prompt": "# Given a number, find the sum of all its prime divisors.\n# >>> Sum 60\n# 10\nproc Sum {N} {",
        "canonical_solution": "    set SumOfPrimeDivisors [lrepeat [expr {$N + 1}] 0]\n    for {set i 2} {$i <= $N} {incr i} {\n        if {[lindex $SumOfPrimeDivisors $i] == 0} {\n            for {set j $i} {$j <= $N} {incr j $i} {\n                lset SumOfPrimeDivisors $j [expr {[lindex $SumOfPrimeDivisors $j] + $i}]\n            }\n        }\n    }\n    return [lindex $SumOfPrimeDivisors $N]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Sum 60] == 10}\nassert {[Sum 39] == 16}\nassert {[Sum 40] == 7}",
        "declaration": "proc Sum {N} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Sum 60] == 10}",
        "prompt_text": "Given a number, find the sum of all its prime divisors.",
        "prompt_explain": "Given a number, find the sum of all its prime divisors.\n>>> Sum 60\n10",
        "func_title": "proc Sum {N}"
    },
    {
        "prompt": "# Given three angles, check if a triangle of positive area is possible with the given angles.\n# >>> is_triangleexists 50 60 70\n# 1\nproc is_triangleexists {a b c} {",
        "canonical_solution": "    if {$a != 0 && $b != 0 && $c != 0 && ($a + $b + $c) == 180} {\n        if {($a + $b) >= $c || ($b + $c) >= $a || ($a + $c) >= $b} {\n            return 1\n        } else {\n            return 0\n        }\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_triangleexists 50 60 70] == 1}\nassert {[is_triangleexists 90 45 45] == 1}\nassert {[is_triangleexists 150 30 70] == 0}",
        "declaration": "proc is_triangleexists {a b c} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_triangleexists 50 60 70] == 1}",
        "prompt_text": "Given three angles, check if a triangle of positive area is possible with the given angles.",
        "prompt_explain": "Given three angles, check if a triangle of positive area is possible with the given angles.\n>>> is_triangleexists 50 60 70\n1",
        "func_title": "proc is_triangleexists {a b c}"
    },
    {
        "prompt": "# Given two numbers N and Sum, find the sum of the inverse of the divisors of N, rounded to two decimal places.\n# >>> Sum_of_Inverse_Divisors 6 12\n# 2\nproc Sum_of_Inverse_Divisors {N Sum} {",
        "canonical_solution": "    set ans [expr {double($Sum) / double($N)}]\n    return [format \"%.2f\" $ans]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Sum_of_Inverse_Divisors 6 12] == 2}\nassert {[Sum_of_Inverse_Divisors 9 13] == 1.44}\nassert {[Sum_of_Inverse_Divisors 1 4] == 4}",
        "declaration": "proc Sum_of_Inverse_Divisors {N Sum} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Sum_of_Inverse_Divisors 6 12] == 2}",
        "prompt_text": "Given two numbers N and Sum, find the sum of the inverse of the divisors of N, rounded to two decimal places.",
        "prompt_explain": "Given two numbers N and Sum, find the sum of the inverse of the divisors of N, rounded to two decimal places.\n>>> Sum_of_Inverse_Divisors 6 12\n2",
        "func_title": "proc Sum_of_Inverse_Divisors {N Sum}"
    },
    {
        "prompt": "# Write a Tcl function to find the sum of odd factors of a number.\n# >>> sum_of_odd_Factors 30\n# 24\nproc sum_of_odd_Factors {n} {",
        "canonical_solution": "    set res 1\n    while {$n % 2 == 0} {\n        set n [expr {$n / 2}]\n    }\n    for {set i 3} {$i <= [expr {sqrt($n) + 1}]} {incr i 2} {\n        set count 0\n        set curr_sum 1\n        set curr_term 1\n        while {$n % $i == 0} {\n            incr count\n            set n [expr {$n / $i}]\n            set curr_term [expr {$curr_term * $i}]\n            set curr_sum [expr {$curr_sum + $curr_term}]\n        }\n        set res [expr {$res * $curr_sum}]\n    }\n    if {$n >= 2} {\n        set res [expr {$res * (1 + $n)}]\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_of_odd_Factors 30] == 24}\nassert {[sum_of_odd_Factors 18] == 13}\nassert {[sum_of_odd_Factors 2] == 1}",
        "declaration": "proc sum_of_odd_Factors {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_of_odd_Factors 30] == 24}",
        "prompt_text": "Write a Tcl function to find the sum of odd factors of a number.",
        "prompt_explain": "Write a Tcl function to find the sum of odd factors of a number.\n>>> sum_of_odd_Factors 30\n24",
        "func_title": "proc sum_of_odd_Factors {n}"
    },
    {
        "prompt": "# Write a Tcl function to check for even parity of a given number.\n# >>> check_Even_Parity 10\n# 1\n# >>> check_Even_Parity 11\n# 0\nproc check_Even_Parity {x} {",
        "canonical_solution": "    set parity 0\n    while {$x != 0} {\n        set x [expr {$x & ($x - 1)}]\n        incr parity\n    }\n    return [expr {$parity % 2 == 0 ? 1 : 0}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_Even_Parity 10] == 1}\nassert {[check_Even_Parity 11] == 0}\nassert {[check_Even_Parity 18] == 1}",
        "declaration": "proc check_Even_Parity {x} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_Even_Parity 10] == 1}",
        "prompt_text": "Write a Tcl function to check for even parity of a given number.",
        "prompt_explain": "Write a Tcl function to check for even parity of a given number.\n>>> check_Even_Parity 10\n1\n>>> check_Even_Parity 11\n0",
        "func_title": "proc check_Even_Parity {x}"
    },
    {
        "prompt": "# Given a text and an integer n, return a list of tuples containing the n most common words and their counts in the text.\n# >>> n_common_words \"python is a programming language\" 1\n# {python 1}\nproc n_common_words {text n} {",
        "canonical_solution": "    set words [regexp -all -inline {\\w+} $text]\n    set word_counts {}\n    foreach word $words {\n        dict incr word_counts $word\n    }\n    set sorted_counts [lsort -stride 2 -index 1 -integer -decreasing $word_counts]\n    set result {}\n    for {set i 0} {$i < $n && $i < [llength $sorted_counts]} {incr i} {\n        lappend result [lrange $sorted_counts [expr {$i * 2}] [expr {$i * 2 + 1}]]\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[n_common_words \"python is a programming language\" 1] eq {{python 1}}}\nassert {[n_common_words \"python is a programming language\" 1] eq {{python 1}}}\nassert {[n_common_words \"python is a programming language\" 5] eq {{python 1} {is 1} {a 1} {programming 1} {language 1}}}",
        "declaration": "proc n_common_words {text n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[n_common_words \"python is a programming language\" 1] eq {{python 1}}}",
        "prompt_text": "Given a text and an integer n, return a list of tuples containing the n most common words and their counts in the text.",
        "prompt_explain": "Given a text and an integer n, return a list of tuples containing the n most common words and their counts in the text.\n>>> n_common_words \"python is a programming language\" 1\n{python 1}",
        "func_title": "proc n_common_words {text n}"
    },
    {
        "prompt": "# Given a list of lists, remove sublists that are outside a given range.\n# >>> remove_list_range {{2} {0} {1 2 3} {0 1 2 3 6 7} {9 11} {13 14 15 17}} 13 17\n# {{13 14 15 17}}\nproc remove_list_range {list1 leftrange rightrange} {",
        "canonical_solution": "    set result {}\n    foreach sublist $list1 {\n        set min [lindex [lsort -integer $sublist] 0]\n        set max [lindex [lsort -integer $sublist] end]\n        if {$min >= $leftrange && $max <= $rightrange} {\n            lappend result $sublist\n        }\n    }\n    return $result\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[remove_list_range {{2} {0} {1 2 3} {0 1 2 3 6 7} {9 11} {13 14 15 17}} 13 17] eq {{13 14 15 17}}}\nassert {[remove_list_range {{2} {0} {1 2 3} {0 1 2 3 6 7} {9 11} {13 14 15 17}} 1 3] eq {{2} {1 2 3}}}\nassert {[remove_list_range {{2} {0} {1 2 3} {0 1 2 3 6 7} {9 11} {13 14 15 17}} 0 7] eq {{2} {0} {1 2 3} {0 1 2 3 6 7}}}",
        "declaration": "proc remove_list_range {list1 leftrange rightrange} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[remove_list_range {{2} {0} {1 2 3} {0 1 2 3 6 7} {9 11} {13 14 15 17}} 13 17] eq {{13 14 15 17}}}",
        "prompt_text": "Given a list of lists, remove sublists that are outside a given range.",
        "prompt_explain": "Given a list of lists, remove sublists that are outside a given range.\n>>> remove_list_range {{2} {0} {1 2 3} {0 1 2 3 6 7} {9 11} {13 14 15 17}} 13 17\n{{13 14 15 17}}",
        "func_title": "proc remove_list_range {list1 leftrange rightrange}"
    },
    {
        "prompt": "# Given a list of numbers, calculate the sum of the positive numbers using a lambda function.\n# >>> sum_positivenum {2 4 -6 -9 11 -12 14 -5 17}\n# 48\nproc sum_positivenum {nums} {",
        "canonical_solution": "    set positive_nums [lmap num $nums {if {$num > 0} {set num}}]\n    return [expr [join $positive_nums +]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_positivenum {2 4 -6 -9 11 -12 14 -5 17}] == 48}\nassert {[sum_positivenum {10 15 -14 13 -18 12 -20}] == 50}\nassert {[sum_positivenum {19 -65 57 39 152 -639 121 44 90 -190}] == 522}",
        "declaration": "proc sum_positivenum {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_positivenum {2 4 -6 -9 11 -12 14 -5 17}] == 48}",
        "prompt_text": "Given a list of numbers, calculate the sum of the positive numbers using a lambda function.",
        "prompt_explain": "Given a list of numbers, calculate the sum of the positive numbers using a lambda function.\n>>> sum_positivenum {2 4 -6 -9 11 -12 14 -5 17}\n48",
        "func_title": "proc sum_positivenum {nums}"
    },
    {
        "prompt": "# Write a function to solve the fibonacci sequence using recursion.\n# >>> fibonacci 7\n# 13\nproc fibonacci {n} {",
        "canonical_solution": "    if {$n == 1 || $n == 2} {\n        return 1\n    } else {\n        return [expr {[fibonacci [expr {$n - 1}]] + [fibonacci [expr {$n - 2}]]}]\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[fibonacci 7] == 13}\nassert {[fibonacci 8] == 21}\nassert {[fibonacci 9] == 34}",
        "declaration": "proc fibonacci {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[fibonacci 7] == 13}",
        "prompt_text": "Write a function to solve the fibonacci sequence using recursion.",
        "prompt_explain": "Write a function to solve the fibonacci sequence using recursion.\n>>> fibonacci 7\n13",
        "func_title": "proc fibonacci {n}"
    },
    {
        "prompt": "# Write a Tcl function to check whether all the bits are within a given range or not.\n# >>> all_Bits_Set_In_The_Given_Range 10 2 1\n# 1\n# >>> all_Bits_Set_In_The_Given_Range 5 2 4\n# 0\n# >>> all_Bits_Set_In_The_Given_Range 22 2 3\n# 1\nproc all_Bits_Set_In_The_Given_Range {n l r} {",
        "canonical_solution": "    set num [expr {((1 << $r) - 1) ^ ((1 << ($l - 1)) - 1)}]\n    set new_num [expr {$n & $num}]\n    if {$num == $new_num} {\n        return 1\n    }\n    return 0\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[all_Bits_Set_In_The_Given_Range 10 2 1] == 1}\nassert {[all_Bits_Set_In_The_Given_Range 5 2 4] == 0}\nassert {[all_Bits_Set_In_The_Given_Range 22 2 3] == 1}",
        "declaration": "proc all_Bits_Set_In_The_Given_Range {n l r} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[all_Bits_Set_In_The_Given_Range 10 2 1] == 1}",
        "prompt_text": "Write a Tcl function to check whether all the bits are within a given range or not.",
        "prompt_explain": "Write a Tcl function to check whether all the bits are within a given range or not.\n>>> all_Bits_Set_In_The_Given_Range 10 2 1\n1\n>>> all_Bits_Set_In_The_Given_Range 5 2 4\n0\n>>> all_Bits_Set_In_The_Given_Range 22 2 3\n1",
        "func_title": "proc all_Bits_Set_In_The_Given_Range {n l r}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the two given strings are isomorphic to each other or not.\n# >>> is_Isomorphic \"paper\" \"title\"\n# 1\n# >>> is_Isomorphic \"ab\" \"ba\"\n# 1\n# >>> is_Isomorphic \"ab\" \"aa\"\n# 0\nproc is_Isomorphic {str1 str2} {",
        "canonical_solution": "    if {[string length $str1] != [string length $str2]} {\n        return 0\n    }\n    set dict_str1 {}\n    set dict_str2 {}\n    for {set i 0} {$i < [string length $str1]} {incr i} {\n        set char1 [string index $str1 $i]\n        set char2 [string index $str2 $i]\n        if {![dict exists $dict_str1 $char1]} {\n            dict set dict_str1 $char1 $i\n        }\n        if {![dict exists $dict_str2 $char2]} {\n            dict set dict_str2 $char2 $i\n        }\n        if {[dict get $dict_str1 $char1] != [dict get $dict_str2 $char2]} {\n            return 0\n        }\n    }\n    return 1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Isomorphic \"paper\" \"title\"] == 1}\nassert {[is_Isomorphic \"ab\" \"ba\"] == 1}\nassert {[is_Isomorphic \"ab\" \"aa\"] == 0}",
        "declaration": "proc is_Isomorphic {str1 str2} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Isomorphic \"paper\" \"title\"] == 1}",
        "prompt_text": "Write a Tcl function to check whether the two given strings are isomorphic to each other or not.",
        "prompt_explain": "Write a Tcl function to check whether the two given strings are isomorphic to each other or not.\n>>> is_Isomorphic \"paper\" \"title\"\n1\n>>> is_Isomorphic \"ab\" \"ba\"\n1\n>>> is_Isomorphic \"ab\" \"aa\"\n0",
        "func_title": "proc is_Isomorphic {str1 str2}"
    },
    {
        "prompt": "# Given a list of numbers, return the sum of all the numbers in the list divided by the length of the list.\n# >>> sum_num {8 2 3 0 7}\n# 4.0\nproc sum_num {numbers} {",
        "canonical_solution": "    set total 0\n    foreach x $numbers {\n        set total [expr {$total + $x}]\n    }\n    return [expr {$total / [llength $numbers]}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_num {8 2 3 0 7}] == 4.0}\nassert {[sum_num {-10 -20 -30}] == -20.0}\nassert {[sum_num {19 15 18}] == 17.333333333333332}",
        "declaration": "proc sum_num {numbers} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_num {8 2 3 0 7}] == 4.0}",
        "prompt_text": "Given a list of numbers, return the sum of all the numbers in the list divided by the length of the list.",
        "prompt_explain": "Given a list of numbers, return the sum of all the numbers in the list divided by the length of the list.\n>>> sum_num {8 2 3 0 7}\n4.0",
        "func_title": "proc sum_num {numbers}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the given number is odd or not using bitwise operator.\n# >>> is_odd 5\n# 1\n# >>> is_odd 6\n# 0\nproc is_odd {n} {",
        "canonical_solution": "    if {($n & 1) == 1} {\n        return 1\n    } else {\n        return 0\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_odd 5] == 1}\nassert {[is_odd 6] == 0}\nassert {[is_odd 7] == 1}",
        "declaration": "proc is_odd {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_odd 5] == 1}",
        "prompt_text": "Write a Tcl function to check whether the given number is odd or not using bitwise operator.",
        "prompt_explain": "Write a Tcl function to check whether the given number is odd or not using bitwise operator.\n>>> is_odd 5\n1\n>>> is_odd 6\n0",
        "func_title": "proc is_odd {n}"
    },
    {
        "prompt": "# Given two sorted arrays, find the index of the extra element present in one of them.\n# >>> find_Extra {1 2 3 4} {1 2 3}\n# 3\nproc find_Extra {arr1 arr2 n} {",
        "canonical_solution": "    for {set i 0} {$i < $n} {incr i} {\n        if {[lindex $arr1 $i] != [lindex $arr2 $i]} {\n            return $i\n        }\n    }\n    return $n\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Extra {1 2 3 4} {1 2 3} 3] == 3}\nassert {[find_Extra {2 4 6 8 10} {2 4 6 8} 4] == 4}\nassert {[find_Extra {1 3 5 7 9 11} {1 3 5 7 9} 5] == 5}",
        "declaration": "proc find_Extra {arr1 arr2 n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[find_Extra {1 2 3 4} {1 2 3} 3] == 3}",
        "prompt_text": "Given two sorted arrays, find the index of the extra element present in one of them.",
        "prompt_explain": "Given two sorted arrays, find the index of the extra element present in one of them.\n>>> find_Extra {1 2 3 4} {1 2 3}\n3",
        "func_title": "proc find_Extra {arr1 arr2 n}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the given two numbers have the same number of digits or not.\n# >>> same_Length 12 1\n# 0\n# >>> same_Length 2 2\n# 1\n# >>> same_Length 10 20\n# 1\nproc same_Length {A B} {",
        "canonical_solution": "    while {$A > 0 && $B > 0} {\n        set A [expr {$A / 10}]\n        set B [expr {$B / 10}]\n    }\n    if {$A == 0 && $B == 0} {\n        return 1\n    }\n    return 0\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[same_Length 12 1] == 0}\nassert {[same_Length 2 2] == 1}\nassert {[same_Length 10 20] == 1}",
        "declaration": "proc same_Length {A B} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[same_Length 12 1] == 0}",
        "prompt_text": "Write a Tcl function to check whether the given two numbers have the same number of digits or not.",
        "prompt_explain": "Write a Tcl function to check whether the given two numbers have the same number of digits or not.\n>>> same_Length 12 1\n0\n>>> same_Length 2 2\n1\n>>> same_Length 10 20\n1",
        "func_title": "proc same_Length {A B}"
    },
    {
        "prompt": "# Given a list of integers, find the maximum sum of subsequences with no adjacent elements.\n# >>> max_sum_subseq {1 2 9 4 5 0 4 11 6}\n# 26\nproc max_sum_subseq {A} {",
        "canonical_solution": "    set n [llength $A]\n    if {$n == 1} {\n        return [lindex $A 0]\n    }\n    set look_up [list]\n    for {set i 0} {$i < $n} {incr i} {\n        lappend look_up 0\n    }\n    lset look_up 0 [lindex $A 0]\n    lset look_up 1 [expr {max([lindex $A 0], [lindex $A 1])}]\n    for {set i 2} {$i < $n} {incr i} {\n        set temp [expr {max([lindex $look_up [expr {$i - 1}]], [lindex $look_up [expr {$i - 2}]] + [lindex $A $i])}]\n        lset look_up $i [expr {max($temp, [lindex $A $i])}]\n    }\n    return [lindex $look_up [expr {$n - 1}]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sum_subseq {1 2 9 4 5 0 4 11 6}] == 26}\nassert {[max_sum_subseq {1 2 9 5 6 0 5 12 7}] == 28}\nassert {[max_sum_subseq {1 3 10 5 6 0 6 14 21}] == 44}",
        "declaration": "proc max_sum_subseq {A} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[max_sum_subseq {1 2 9 4 5 0 4 11 6}] == 26}",
        "prompt_text": "Given a list of integers, find the maximum sum of subsequences with no adjacent elements.",
        "prompt_explain": "Given a list of integers, find the maximum sum of subsequences with no adjacent elements.\n>>> max_sum_subseq {1 2 9 4 5 0 4 11 6}\n26",
        "func_title": "proc max_sum_subseq {A}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the word is present in a given sentence or not.\n# >>> is_Word_Present \"machine learning\" \"machine\"\n# 1\nproc is_Word_Present {sentence word} {",
        "canonical_solution": "    set words [split $sentence \" \"]\n    foreach w $words {\n        if {$w eq $word} {\n            return 1\n        }\n    }\n    return 0\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Word_Present \"machine learning\" \"machine\"] == 1}\nassert {[is_Word_Present \"easy\" \"fun\"] == 0}\nassert {[is_Word_Present \"python language\" \"code\"] == 0}",
        "declaration": "proc is_Word_Present {sentence word} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Word_Present \"machine learning\" \"machine\"] == 1}",
        "prompt_text": "Write a Tcl function to check whether the word is present in a given sentence or not.",
        "prompt_explain": "Write a Tcl function to check whether the word is present in a given sentence or not.\n>>> is_Word_Present \"machine learning\" \"machine\"\n1",
        "func_title": "proc is_Word_Present {sentence word}"
    },
    {
        "prompt": "# Write a function to find the smallest multiple of the first n numbers.\n# >>> smallest_multiple 13\n# 360360\nproc smallest_multiple {n} {",
        "canonical_solution": "    if {$n <= 2} {\n        return $n\n    }\n    set i [expr {$n * 2}]\n    set factors {}\n    for {set number $n} {$number > 1} {incr number -1} {\n        if {[expr {$number * 2}] > $n} {\n            lappend factors $number\n        }\n    }\n    while {1} {\n        foreach a $factors {\n            if {[expr {$i % $a}] != 0} {\n                set i [expr {$i + $n}]\n                break\n            }\n            if {$a == [lindex $factors end] && [expr {$i % $a}] == 0} {\n                return $i\n            }\n        }\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smallest_multiple 13] == 360360}\nassert {[smallest_multiple 2] == 2}\nassert {[smallest_multiple 1] == 1}",
        "declaration": "proc smallest_multiple {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[smallest_multiple 13] == 360360}",
        "prompt_text": "Write a function to find the smallest multiple of the first n numbers.",
        "prompt_explain": "Write a function to find the smallest multiple of the first n numbers.\n>>> smallest_multiple 13\n360360",
        "func_title": "proc smallest_multiple {n}"
    },
    {
        "prompt": "# Write a Tcl function to count the total unset bits from 1 to n.\n# >>> count_Unset_Bits 2\n# 1\n# >>> count_Unset_Bits 5\n# 4\n# >>> count_Unset_Bits 14\n# 17\nproc count_Unset_Bits {n} {",
        "canonical_solution": "    set cnt 0\n    for {set i 1} {$i <= $n} {incr i} {\n        set temp $i\n        while {$temp != 0} {\n            if {[expr {$temp % 2}] == 0} {\n                incr cnt\n            }\n            set temp [expr {$temp / 2}]\n        }\n    }\n    return $cnt\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Unset_Bits 2] == 1}\nassert {[count_Unset_Bits 5] == 4}\nassert {[count_Unset_Bits 14] == 17}",
        "declaration": "proc count_Unset_Bits {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_Unset_Bits 2] == 1}",
        "prompt_text": "Write a Tcl function to count the total unset bits from 1 to n.",
        "prompt_explain": "Write a Tcl function to count the total unset bits from 1 to n.\n>>> count_Unset_Bits 2\n1\n>>> count_Unset_Bits 5\n4\n>>> count_Unset_Bits 14\n17",
        "func_title": "proc count_Unset_Bits {n}"
    },
    {
        "prompt": "# Write a function to find the previous palindrome of a specified number.\n# >>> previous_palindrome 99\n# 88\nproc previous_palindrome {num} {",
        "canonical_solution": "    for {set x [expr {$num - 1}]} {$x > 0} {incr x -1} {\n        if {$x == [string reverse $x]} {\n            return $x\n        }\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[previous_palindrome 99] == 88}\nassert {[previous_palindrome 1221] == 1111}\nassert {[previous_palindrome 120] == 111}",
        "declaration": "proc previous_palindrome {num} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[previous_palindrome 99] == 88}",
        "prompt_text": "Write a function to find the previous palindrome of a specified number.",
        "prompt_explain": "Write a function to find the previous palindrome of a specified number.\n>>> previous_palindrome 99\n88",
        "func_title": "proc previous_palindrome {num}"
    },
    {
        "prompt": "# Write a function to validate a Gregorian date.\n# >>> check_date 11 11 2002\n# 1\n# >>> check_date 13 11 2002\n# 0\n# >>> check_date '11' '11' '2002'\n# 1\nproc check_date {m d y} {",
        "canonical_solution": "    if {[catch {clock scan \"$y-$m-$d\" -format \"%Y-%m-%d\"} result]} {\n        return 0\n    } else {\n        return 1\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_date 11 11 2002] == 1}\nassert {[check_date 13 11 2002] == 0}\nassert {[check_date '11' '11' '2002'] == 1}",
        "declaration": "proc check_date {m d y} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_date 11 11 2002] == 1}",
        "prompt_text": "Write a function to validate a Gregorian date.",
        "prompt_explain": "Write a function to validate a Gregorian date.\n>>> check_date 11 11 2002\n1\n>>> check_date 13 11 2002\n0\n>>> check_date '11' '11' '2002'\n1",
        "func_title": "proc check_date {m d y}"
    },
    {
        "prompt": "# Write a function to check for a number at the end of a string.\n# >>> end_num 'abcdef'\n# False\n# >>> end_num 'abcdef7'\n# True\n# >>> end_num 'abc'\n# False\nproc end_num {string} {",
        "canonical_solution": "    if {[regexp {.*[0-9]$} $string]} {\n        return True\n    } else {\n        return False\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[end_num 'abcdef'] == False}\nassert {[end_num 'abcdef7'] == True}\nassert {[end_num 'abc'] == False}",
        "declaration": "proc end_num {string} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[end_num 'abcdef'] == False}",
        "prompt_text": "Write a function to check for a number at the end of a string.",
        "prompt_explain": "Write a function to check for a number at the end of a string.\n>>> end_num 'abcdef'\nFalse\n>>> end_num 'abcdef7'\nTrue\n>>> end_num 'abc'\nFalse",
        "func_title": "proc end_num {string}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the given string is made up of two alternating characters or not.\n# >>> is_Two_Alter \"abab\"\n# 1\n# >>> is_Two_Alter \"aaaa\"\n# 0\nproc is_Two_Alter {s} {",
        "canonical_solution": "    set len [string length $s]\n    for {set i 0} {$i < [expr {$len - 2}]} {incr i} {\n        if {[string index $s $i] != [string index $s [expr {$i + 2}]]} {\n            return 0\n        }\n    }\n    if {[string index $s 0] == [string index $s 1]} {\n        return 0\n    }\n    return 1\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Two_Alter \"abab\"] == 1}\nassert {[is_Two_Alter \"aaaa\"] == 0}\nassert {[is_Two_Alter \"xyz\"] == 0}",
        "declaration": "proc is_Two_Alter {s} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_Two_Alter \"abab\"] == 1}",
        "prompt_text": "Write a Tcl function to check whether the given string is made up of two alternating characters or not.",
        "prompt_explain": "Write a Tcl function to check whether the given string is made up of two alternating characters or not.\n>>> is_Two_Alter \"abab\"\n1\n>>> is_Two_Alter \"aaaa\"\n0",
        "func_title": "proc is_Two_Alter {s}"
    },
    {
        "prompt": "# Given a list of coin denominations and a total amount, return the number of ways to make change for that amount using the denominations.\n# >>> coin_change {1 2 3} 3 4\n# 4\nproc coin_change {S m n} {",
        "canonical_solution": "    set table [lrepeat [expr {$n + 1}] [lrepeat $m 0]]\n    for {set i 0} {$i < $m} {incr i} {\n        lset table 0 $i 1\n    }\n    for {set i 1} {$i <= $n} {incr i} {\n        for {set j 0} {$j < $m} {incr j} {\n            set x [expr {($i - [lindex $S $j] >= 0) ? [lindex $table [expr {$i - [lindex $S $j]}] $j] : 0}]\n            set y [expr {($j >= 1) ? [lindex $table $i [expr {$j - 1}]] : 0}]\n            lset table $i $j [expr {$x + $y}]\n        }\n    }\n    return [lindex $table $n [expr {$m - 1}]]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[coin_change {1 2 3} 3 4] == 4}\nassert {[coin_change {4 5 6 7 8 9} 6 9] == 2}\nassert {[coin_change {4 5 6 7 8 9} 6 4] == 1}",
        "declaration": "proc coin_change {S m n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[coin_change {1 2 3} 3 4] == 4}",
        "prompt_text": "Given a list of coin denominations and a total amount, return the number of ways to make change for that amount using the denominations.",
        "prompt_explain": "Given a list of coin denominations and a total amount, return the number of ways to make change for that amount using the denominations.\n>>> coin_change {1 2 3} 3 4\n4",
        "func_title": "proc coin_change {S m n}"
    },
    {
        "prompt": "# Given a list of integers, return the product of all items in the list.\n# >>> multiply_list {1 -2 3}\n# -6\nproc multiply_list {items} {",
        "canonical_solution": "    set tot 1\n    foreach x $items {\n        set tot [expr {$tot * $x}]\n    }\n    return $tot\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[multiply_list {1 -2 3}] == -6}\nassert {[multiply_list {1 2 3 4}] == 24}\nassert {[multiply_list {3 1 2 3}] == 18}",
        "declaration": "proc multiply_list {items} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[multiply_list {1 -2 3}] == -6}",
        "prompt_text": "Given a list of integers, return the product of all items in the list.",
        "prompt_explain": "Given a list of integers, return the product of all items in the list.\n>>> multiply_list {1 -2 3}\n-6",
        "func_title": "proc multiply_list {items}"
    },
    {
        "prompt": "# Given a tuple of integers, return the product of all the numbers in the tuple.\n# >>> multiple_tuple {4 3 2 2 -1 18}\n# -864\nproc multiple_tuple {nums} {",
        "canonical_solution": "    set product 1\n    foreach num $nums {\n        set product [expr {$product * $num}]\n    }\n    return $product\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[multiple_tuple {4 3 2 2 -1 18}] == -864}\nassert {[multiple_tuple {1 2 3}] == 6}\nassert {[multiple_tuple {-2 -4 -6}] == -48}",
        "declaration": "proc multiple_tuple {nums} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[multiple_tuple {4 3 2 2 -1 18}] == -864}",
        "prompt_text": "Given a tuple of integers, return the product of all the numbers in the tuple.",
        "prompt_explain": "Given a tuple of integers, return the product of all the numbers in the tuple.\n>>> multiple_tuple {4 3 2 2 -1 18}\n-864",
        "func_title": "proc multiple_tuple {nums}"
    },
    {
        "prompt": "# Given a binary tree, calculate its height.\n# >>> max_height $root\n# 3\nproc max_height {node} {",
        "canonical_solution": "    if {$node eq \"\"} {\n        return 0\n    } else {\n        set left_height [max_height [dict get $node left]]\n        set right_height [max_height [dict get $node right]]\n        if {$left_height > $right_height} {\n            return [expr {$left_height + 1}]\n        } else {\n            return [expr {$right_height + 1}]\n        }\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nset root [dict create data 1 left [dict create data 2 left [dict create data 4 left \"\" right \"\"] right [dict create data 5 left \"\" right \"\"]] right [dict create data 3 left \"\" right \"\"]]\nset root1 [dict create data 1 left [dict create data 2 left [dict create data 4 left \"\" right \"\"] right \"\"] right [dict create data 3 left [dict create data 5 left \"\" right \"\"] right [dict create data 6 left \"\" right [dict create data 7 left \"\" right [dict create data 8 left \"\" right \"\"]]]]]\nset root2 [dict create data 1 left [dict create data 2 left [dict create data 4 left [dict create data 6 left \"\" right \"\"] right [dict create data 7 left \"\" right \"\"]] right [dict create data 5 left \"\" right \"\"]] right [dict create data 3 left \"\" right \"\"]]\n\nassert {[max_height $root] == 3}\nassert {[max_height $root1] == 5}\nassert {[max_height $root2] == 4}",
        "declaration": "proc max_height {node} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nset root [dict create data 1 left [dict create data 2 left [dict create data 4 left \"\" right \"\"] right [dict create data 5 left \"\" right \"\"]] right [dict create data 3 left \"\" right \"\"]]\n\nassert {[max_height $root] == 3}",
        "prompt_text": "Given a binary tree, calculate its height.",
        "prompt_explain": "Given a binary tree, calculate its height.\n>>> max_height $root\n3",
        "func_title": "proc max_height {node}"
    },
    {
        "prompt": "# Given a tuple and a value, return the count of the value in the tuple.\n# >>> count_tuplex {2 4 5 6 2 3 4 4 7} 4\n# 3\nproc count_tuplex {tuplex value} {",
        "canonical_solution": "    set count 0\n    foreach element $tuplex {\n        if {$element == $value} {\n            incr count\n        }\n    }\n    return $count\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_tuplex {2 4 5 6 2 3 4 4 7} 4] == 3}\nassert {[count_tuplex {2 4 5 6 2 3 4 4 7} 2] == 2}\nassert {[count_tuplex {2 4 7 7 7 3 4 4 7} 7] == 4}",
        "declaration": "proc count_tuplex {tuplex value} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[count_tuplex {2 4 5 6 2 3 4 4 7} 4] == 3}",
        "prompt_text": "Given a tuple and a value, return the count of the value in the tuple.",
        "prompt_explain": "Given a tuple and a value, return the count of the value in the tuple.\n>>> count_tuplex {2 4 5 6 2 3 4 4 7} 4\n3",
        "func_title": "proc count_tuplex {tuplex value}"
    },
    {
        "prompt": "# Write a function to calculate the sum of series 1+2+3+.+n.\n# >>> sum_series 7\n# 784\nproc sum_series {number} {",
        "canonical_solution": "    set total [expr {pow(($number * ($number + 1)) / 2, 2)}]\n    return $total\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_series 7] == 784}\nassert {[sum_series 5] == 225}\nassert {[sum_series 15] == 14400}",
        "declaration": "proc sum_series {number} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[sum_series 7] == 784}",
        "prompt_text": "Write a function to calculate the sum of series 1+2+3+.+n.",
        "prompt_explain": "Write a function to calculate the sum of series 1+2+3+.+n.\n>>> sum_series 7\n784",
        "func_title": "proc sum_series {number}"
    },
    {
        "prompt": "# Write a function to calculate the sum of series 1+2+3+.+n.\n# >>> series_sum 6\n# 91\nproc series_sum {number} {",
        "canonical_solution": "    set total [expr {($number * ($number + 1) * (2 * $number + 1)) / 6}]\n    return $total\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[series_sum 6] == 91}\nassert {[series_sum 7] == 140}\nassert {[series_sum 12] == 650}",
        "declaration": "proc series_sum {number} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[series_sum 6] == 91}",
        "prompt_text": "Write a function to calculate the sum of series 1+2+3+.+n.",
        "prompt_explain": "Write a function to calculate the sum of series 1+2+3+.+n.\n>>> series_sum 6\n91",
        "func_title": "proc series_sum {number}"
    },
    {
        "prompt": "# Given a list and a check list, return True if any element of the check list is present in the given list, otherwise return False.\n# >>> check_element {4 5 7 9 3} {6 7 10 11}\n# True\nproc check_element {test_tup check_list} {",
        "canonical_solution": "    set res False\n    foreach ele $check_list {\n        if {$ele in $test_tup} {\n            set res True\n            break\n        }\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_element {4 5 7 9 3} {6 7 10 11}] == True}\nassert {[check_element {1 2 3 4} {4 6 7 8 9}] == True}\nassert {[check_element {3 2 1 4 5} {9 8 7 6}] == False}",
        "declaration": "proc check_element {test_tup check_list} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[check_element {4 5 7 9 3} {6 7 10 11}] == True}",
        "prompt_text": "Given a list and a check list, return True if any element of the check list is present in the given list, otherwise return False.",
        "prompt_explain": "Given a list and a check list, return True if any element of the check list is present in the given list, otherwise return False.\n>>> check_element {4 5 7 9 3} {6 7 10 11}\nTrue",
        "func_title": "proc check_element {test_tup check_list}"
    },
    {
        "prompt": "# Given a string, write a function to separate and print the numbers and their position in the string.\n# >>> num_position \"there are 70 flats in this apartment\"\n# 10\nproc num_position {text} {",
        "canonical_solution": "    set positions {}\n    set i 0\n    while {$i < [string length $text]} {\n        if {[string is digit [string index $text $i]]} {\n            set start $i\n            while {$i < [string length $text] && [string is digit [string index $text $i]]} {\n                incr i\n            }\n            lappend positions $start\n        } else {\n            incr i\n        }\n    }\n    if {[llength $positions] > 0} {\n        return [lindex $positions 0]\n    } else {\n        return -1\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[num_position \"there are 70 flats in this apartment\"] == 10}\nassert {[num_position \"every adult have 32 teeth\"] == 17}\nassert {[num_position \"isha has 79 chocolates in her bag\"] == 9}",
        "declaration": "proc num_position {text} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[num_position \"there are 70 flats in this apartment\"] == 10}",
        "prompt_text": "Given a string, write a function to separate and print the numbers and their position in the string.",
        "prompt_explain": "Given a string, write a function to separate and print the numbers and their position in the string.\n>>> num_position \"there are 70 flats in this apartment\"\n10",
        "func_title": "proc num_position {text}"
    },
    {
        "prompt": "# Given integers n, r, and p, compute the value of nCr mod p.\n# >>> nCr_mod_p 10 2 13\n# 6\nproc nCr_mod_p {n r p} {",
        "canonical_solution": "    if {$r > [expr {$n - $r}]} {\n        set r [expr {$n - $r}]\n    }\n    set C [lrepeat [expr {$r + 1}] 0]\n    lset C 0 1\n    for {set i 1} {$i <= $n} {incr i} {\n        for {set j [expr {min($i, $r)}]} {$j > 0} {incr j -1} {\n            lset C $j [expr {([lindex $C $j] + [lindex $C [expr {$j - 1}]]) % $p}]\n        }\n    }\n    return [lindex $C $r]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[nCr_mod_p 10 2 13] == 6}\nassert {[nCr_mod_p 11 3 14] == 11}\nassert {[nCr_mod_p 18 14 19] == 1}",
        "declaration": "proc nCr_mod_p {n r p} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[nCr_mod_p 10 2 13] == 6}",
        "prompt_text": "Given integers n, r, and p, compute the value of nCr mod p.",
        "prompt_explain": "Given integers n, r, and p, compute the value of nCr mod p.\n>>> nCr_mod_p 10 2 13\n6",
        "func_title": "proc nCr_mod_p {n r p}"
    },
    {
        "prompt": "# Given a list of integers, find the minimum number of subsets with distinct elements.\n# >>> subset {1 2 3 4}\n# 1\n# >>> subset {5 6 9 3 4 3 4}\n# 2\nproc subset {ar} {",
        "canonical_solution": "    set res 0\n    set ar [lsort -integer $ar]\n    set n [llength $ar]\n    for {set i 0} {$i < $n} {incr i} {\n        set count 1\n        for {set j [expr {$i + 1}]} {$j < $n} {incr j} {\n            if {[lindex $ar $i] == [lindex $ar $j]} {\n                incr count\n            } else {\n                break\n            }\n        }\n        set res [expr {max($res, $count)}]\n    }\n    return $res\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[subset {1 2 3 4}] == 1}\nassert {[subset {5 6 9 3 4 3 4}] == 2}\nassert {[subset {1 2 3}] == 1}",
        "declaration": "proc subset {ar} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[subset {1 2 3 4}] == 1}",
        "prompt_text": "Given a list of integers, find the minimum number of subsets with distinct elements.",
        "prompt_explain": "Given a list of integers, find the minimum number of subsets with distinct elements.\n>>> subset {1 2 3 4}\n1\n>>> subset {5 6 9 3 4 3 4}\n2",
        "func_title": "proc subset {ar}"
    },
    {
        "prompt": "# Write a function that gives profit amount if the given amount has profit else return none.\n# >>> profit_amount 1500 1200\n# 300\n# >>> profit_amount 100 200\n# None\n# >>> profit_amount 2000 5000\n# None\nproc profit_amount {actual_cost sale_amount} {",
        "canonical_solution": "    if {$actual_cost > $sale_amount} {\n        set amount [expr {$actual_cost - $sale_amount}]\n        return $amount\n    } else {\n        return \"None\"\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[profit_amount 1500 1200] == 300}\nassert {[profit_amount 100 200] eq \"None\"}\nassert {[profit_amount 2000 5000] eq \"None\"}",
        "declaration": "proc profit_amount {actual_cost sale_amount} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[profit_amount 1500 1200] == 300}",
        "prompt_text": "Write a function that gives profit amount if the given amount has profit else return none.",
        "prompt_explain": "Write a function that gives profit amount if the given amount has profit else return none.\n>>> profit_amount 1500 1200\n300\n>>> profit_amount 100 200\nNone\n>>> profit_amount 2000 5000\nNone",
        "func_title": "proc profit_amount {actual_cost sale_amount}"
    },
    {
        "prompt": "# Given a number, determine if it is an abundant number. An abundant number is a number for which the sum of its proper divisors is greater than the number itself.\n# >>> is_abundant 12\n# 1\n# >>> is_abundant 13\n# 0\nproc is_abundant {n} {",
        "canonical_solution": "    set sum 0\n    for {set i 1} {$i < $n} {incr i} {\n        if {$n % $i == 0} {\n            incr sum $i\n        }\n    }\n    return [expr {$sum > $n}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_abundant 12] == 1}\nassert {[is_abundant 13] == 0}\nassert {[is_abundant 9] == 0}",
        "declaration": "proc is_abundant {n} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[is_abundant 12] == 1}",
        "prompt_text": "Given a number, determine if it is an abundant number. An abundant number is a number for which the sum of its proper divisors is greater than the number itself.",
        "prompt_explain": "Given a number, determine if it is an abundant number. An abundant number is a number for which the sum of its proper divisors is greater than the number itself.\n>>> is_abundant 12\n1\n>>> is_abundant 13\n0",
        "func_title": "proc is_abundant {n}"
    },
    {
        "prompt": "# Given a list of numbers, return the average of the list.\n# >>> Average {15 9 55 41 35 20 62 49}\n# 35.75\nproc Average {lst} {",
        "canonical_solution": "    set sum 0\n    foreach num $lst {\n        set sum [expr {$sum + $num}]\n    }\n    return [expr {$sum / double([llength $lst])}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Average {15 9 55 41 35 20 62 49}] == 35.75}\nassert {[Average {4 5 1 2 9 7 10 8}] == 5.75}\nassert {[Average {1 2 3}] == 2}",
        "declaration": "proc Average {lst} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[Average {15 9 55 41 35 20 62 49}] == 35.75}",
        "prompt_text": "Given a list of numbers, return the average of the list.",
        "prompt_explain": "Given a list of numbers, return the average of the list.\n>>> Average {15 9 55 41 35 20 62 49}\n35.75",
        "func_title": "proc Average {lst}"
    },
    {
        "prompt": "# Write a function to convert a roman numeral to an integer.\n# >>> roman_to_int \"MMMCMLXXXVI\"\n# 3986\nproc roman_to_int {s} {",
        "canonical_solution": "    set rom_val {I 1 V 5 X 10 L 50 C 100 D 500 M 1000}\n    set int_val 0\n    set length [string length $s]\n    for {set i 0} {$i < $length} {incr i} {\n        set current_char [string index $s $i]\n        set current_val [dict get $rom_val $current_char]\n        if {$i > 0} {\n            set prev_char [string index $s [expr {$i - 1}]]\n            set prev_val [dict get $rom_val $prev_char]\n            if {$current_val > $prev_val} {\n                set int_val [expr {$int_val + $current_val - 2 * $prev_val}]\n            } else {\n                set int_val [expr {$int_val + $current_val}]\n            }\n        } else {\n            set int_val [expr {$int_val + $current_val}]\n        }\n    }\n    return $int_val\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[roman_to_int \"MMMCMLXXXVI\"] == 3986}\nassert {[roman_to_int \"MMMM\"] == 4000}\nassert {[roman_to_int \"C\"] == 100}",
        "declaration": "proc roman_to_int {s} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[roman_to_int \"MMMCMLXXXVI\"] == 3986}",
        "prompt_text": "Write a function to convert a roman numeral to an integer.",
        "prompt_explain": "Write a function to convert a roman numeral to an integer.\n>>> roman_to_int \"MMMCMLXXXVI\"\n3986",
        "func_title": "proc roman_to_int {s}"
    },
    {
        "prompt": "# Write a Tcl function to check whether the length of the word is even or not.\n# >>> word_len \"program\"\n# False\n# >>> word_len \"solution\"\n# True\n# >>> word_len \"data\"\n# True\nproc word_len {s} {",
        "canonical_solution": "    set words [split $s \" \"]\n    foreach word $words {\n        if {[expr {[string length $word] % 2}] == 0} {\n            return True\n        } else {\n            return False\n        }\n    }\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[word_len \"program\"] eq False}\nassert {[word_len \"solution\"] eq True}\nassert {[word_len \"data\"] eq True}",
        "declaration": "proc word_len {s} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[word_len \"program\"] eq False}",
        "prompt_text": "Write a Tcl function to check whether the length of the word is even or not.",
        "prompt_explain": "Write a Tcl function to check whether the length of the word is even or not.\n>>> word_len \"program\"\nFalse\n>>> word_len \"solution\"\nTrue\n>>> word_len \"data\"\nTrue",
        "func_title": "proc word_len {s}"
    },
    {
        "prompt": "# Given a periodic function defined by A, B, and N, find the maximum possible value for the function.\n# >>> floor_Max 11 10 9\n# 9\nproc floor_Max {A B N} {",
        "canonical_solution": "    set x [expr {min($B - 1, $N)}]\n    return [expr {($A * $x) / $B}]\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[floor_Max 11 10 9] == 9}\nassert {[floor_Max 5 7 4] == 2}\nassert {[floor_Max 2 2 1] == 1}",
        "declaration": "proc floor_Max {A B N} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[floor_Max 11 10 9] == 9}",
        "prompt_text": "Given a periodic function defined by A, B, and N, find the maximum possible value for the function.",
        "prompt_explain": "Given a periodic function defined by A, B, and N, find the maximum possible value for the function.\n>>> floor_Max 11 10 9\n9",
        "func_title": "proc floor_Max {A B N}"
    },
    {
        "prompt": "# Write a function to find minimum of two numbers.\n# >>> min_of_two 10 20\n# 10\nproc min_of_two {x y} {",
        "canonical_solution": "    if {$x < $y} {\n        return $x\n    }\n    return $y\n}",
        "test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_of_two 10 20] == 10}\nassert {[min_of_two 19 15] == 15}\nassert {[min_of_two -10 -20] == -20}",
        "declaration": "proc min_of_two {x y} {",
        "example_test": "proc assert {condition} {\n    if {![uplevel 1 expr $condition]} {\n        return -code error \"Assertion failed\"\n    }\n}\n\nassert {[min_of_two 10 20] == 10}",
        "prompt_text": "Write a function to find minimum of two numbers.",
        "prompt_explain": "Write a function to find minimum of two numbers.\n>>> min_of_two 10 20\n10",
        "func_title": "proc min_of_two {x y}"
    }
]